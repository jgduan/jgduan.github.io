<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-06-28T15:19:09.670Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1忽略build文件夹后找不到BuildConfig]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/">
        </link>
        <updated>2021-06-28T15:14:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在Android Studio版本升级到4.1+后，新建了一个项目并在<code>build.gradle</code>文件中配置了<code>buildConfigField-http/log</code>等相关公共字段的配置并同步，然后因要关联至SVN，便修改了项目中的忽略配置以避免上传部分不需要提交的文件内容，具体配置如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628170410668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="忽略配置" loading="lazy"><br>
配置完毕后，当打开使用到<code>BuildConfig</code>文件的类时，发现编辑器报错并提示找不到该文件，具体如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628171128972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="buildConfig" loading="lazy"></p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>刚碰到该问题，第一时间怀疑是<strong>相关文件未构建成功</strong>，多次<code>Build-&gt;ReBuild Project</code>都毫无作用。</p>
<p>后来想到对应Module的<code>build</code>目录下去查看是否已生成文件（BuildConfig默认的生成在<code>xx/ProjectName/ModuleName/build/generated/source/buildConfig/buildTypes(debug/release/xxx/包名、)</code>目录下），发现在Project预览模式下，无法找到build文件。</p>
<p>最后各种尝试后，定位到可能是因为忽略文件配置导致Project无法预览build文件目录下的内容，导致编辑器报错找不到文件，<strong>直接取消setting-&gt;Editor-&gt;File Types-&gt;.gitignore中的build文件夹的忽略配置即可</strong>。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava3实现倒计时功能]]></title>
        <id>https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/</id>
        <link href="https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/">
        </link>
        <updated>2021-06-28T14:52:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-导入rxjava3">一、导入RxJava3</h1>
<p>在需要使用RxJava的Module中，打开<code>build.gradle</code>文件在<code>dependencies</code>标签内添加如下代码引入RxJava：</p>
<pre><code class="language-java">implementation &quot;io.reactivex.rxjava3:rxjava:3.0.6&quot;
implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
</code></pre>
<hr>
<h1 id="二-倒计时实现">二、倒计时实现</h1>
<ul>
<li><strong>使用<code>intervalRange</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">/**
 * start：开始的数值
 * count：输出值的个数（执行几次）
 * initialDelay：延迟多久执行
 * period：间隔多久执行一次
 * TimeUnit：延迟/间隔数值单位，NANOSECONDS（纳秒），MICROSECONDS（微秒），MILLISECONDS（毫秒），
 * SECONDS（秒），MINUTES（分钟），HOURS（小时），DAYS（天）
 */
Observable.intervalRange(0, 1, 5, 0, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnComplete {
        LogUtil.e(TAG,&quot;start to MainActivity...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }.subscribe()
</code></pre>
<ul>
<li><strong>使用<code>timer</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">// 延时1s进入MainActivity
Observable.timer(1, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe {
        LogUtil.e(TAG,&quot;start to MainActivity2...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】创建签名提示“迁移到行业标准格式PKCS12”问题]]></title>
        <id>https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/">
        </link>
        <updated>2021-06-28T14:21:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>Android Studio新建项目签名时创建签名文件时，提示“迁移到行业标准格式PKCS12”。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>在Android Studio上，通过命令行创建签名文件。</p>
<ol>
<li>输入以下命令：</li>
</ol>
<pre><code class="language-java">keytool -genkey -alias 这里替换成你的应用别名 -keypass 这里填写你的别名密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore 签名文件的存储路径\你得项目名称\app\xxx.jks -storepass 你的签名密码
</code></pre>
<p>你需要修改以下四处：</p>
<ul>
<li>应用别名（alias）</li>
<li>别名密码（alias password）</li>
<li>签名文件保存的路径（全路径，如：D:/TestProject/app/test.jks）</li>
<li>签名密码</li>
</ul>
<ol start="2">
<li>第1步完成后，回车，然后填写签名作者相关信息</li>
</ol>
<pre><code class="language-java">您的名字与姓氏是什么?
  [Unknown]:  zihao
您的组织单位名称是什么?
  [Unknown]:  xxxx
您的组织名称是什么?
  [Unknown]:  xxxx
您所在的城市或区域名称是什么?
  [Unknown]:  HeFei
您所在的省/市/自治区名称是什么?
  [Unknown]:  AnHui
该单位的双字母国家/地区代码是什么?
  [Unknown]:  0086
CN=zihao, OU=xxxx, O=xxxx L=HeFei, ST=AnHui, C=0086是否正确?
  [否]:  y
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【DOHENES】基于Kotlin的v3.0架构规范]]></title>
        <id>https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/</id>
        <link href="https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/">
        </link>
        <updated>2021-06-25T14:17:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>项目采用了<code>MVVM</code>架构方式+组件化方案+<code>Jetpack</code>常用库，基于<code>Kotlin 1.4.32</code>编译版本，在个别<code>Module</code>的部分区域混合使用了<code>Java（Java 8版本）</code>来进行开发工作，具体使用的三方库及其使用方法、示例将在文末进行讲解。</p>
<hr>
<h1 id="一-架构模式-mvvm">一、架构模式-MVVM</h1>
<p>项目采用<code>MVVM</code>架构模式，这里通过<code>Jetpack</code>的<code>ViewModel</code>组件来更换传统的<code>ViewModel</code>。</p>
<p><a href="https://www.jianshu.com/p/449136bddff6">Android MVVM 模式</a></p>
<hr>
<h1 id="二-project-组件化">二、Project-组件化</h1>
<p>为了各个功能模块之间解耦、<code>Module</code>灵活组合编译运行，便于团队协作开发及后期维护，3.0版本架构在多<code>Module</code>的基础上，采用了组件化方案来进一步优化项目架构。</p>
<ul>
<li>
<p><strong>模块解耦</strong><br>
项目采用组件化方案进行模块的<strong>解耦</strong>处理。</p>
</li>
<li>
<p><strong>组件分类及命名规范</strong><br>
整体架构分层与v2.0版本类似，除了最上层的<code>base、common</code>两大Library基础库，功能成分库继续采用<code>component-xxx</code>来进行命名，包含界面、具体业务逻辑的Library继续用<code>module-xxx</code>进行命名。</p>
</li>
</ul>
<blockquote>
<p>具体可参考<a href="https://jgduan.github.io/post/dohenes-tb-gai-ban-v20-zheng-ti-jia-gou-gui-fan/">【DOHENES】TB改版v2.0整体架构规范</a></p>
</blockquote>
<ul>
<li>
<p><strong>统一的引用配置</strong><br>
为保持引用库版本一致，规避开发过程中不必要的冲突。项目中通过Project根目录下的<code>config.gradle</code>文件，定义通用的构建元素字段，供各个模块进行引用。</p>
</li>
<li>
<p><strong>独立编译运行</strong><br>
发挥组件化方案的优势，通过在<code>config.gradle</code>中配置对应控制变量对各<code>moudle</code>进行<code>library-&gt;application</code>的灵活控制，让<code>module</code>既可以独立编译运行，又可以集成编译，按需灵活配置，方便开发人员协作。</p>
</li>
</ul>
<hr>
<h1 id="三-屏幕分辨率适配">三、屏幕（分辨率适配）</h1>
<p>依据实际的<code>UI</code>设计图，我们以<code>sw-375dp</code>为基准进行屏幕的适配工作，相应适配文件存放于<code>base-&gt;res/values、values-swxxxdp/measure.xml</code>内。<br>
在实际开发中根据UI设计图尺寸直接设置对应控件的尺寸即可（<code>@dimen/common_measure_xxxdp</code>），具体使用示例如下：</p>
<pre><code class="language-java">// 在需要使用地方添加对应的尺寸
android:layout_height=&quot;@dimen/common_measure_xxxdp&quot;
</code></pre>
<hr>
<h1 id="四-数据存储">四、数据存储</h1>
<ul>
<li>
<p><strong>ROOM</strong><br>
<a href="https://blog.csdn.net/yu540135101/article/details/110670477">Android kotlin+协程+Room数据库的简单使用</a><br>
<a href="https://www.jianshu.com/p/0dde643ac045">Android Room的简单使用</a></p>
</li>
<li>
<p><strong>DataStore</strong></p>
</li>
<li>
<p><strong>Native Files</strong><br>
当我们在开发过程涉及到一些需要缓存的文件时，很多应用采取的策略是到<code>SD卡</code>的根目录上创建自己的文件夹然后保存到对应的文件路径下（之前的泰邦设计也是这样做的），虽然达到了缓存文件的目的，但它并不被Android所推荐——当应用卸载后，这些被创建的文件夹仍然存在，造成手机内多出了不少的垃圾文件，这样是极不友好的。<br>
Android建议我们在缓存文件时使用应用专属（这里又分内部存储与外部存储，建议是尽可能使用外部存储进行缓存）的缓存路径进行文件的缓存，当应用被卸载后，这些数据也会随之而消失，从而规避了上述问题。<br>
关于应用专属内、外部存储的更多了解，建议阅读以下文章或自行了解后再进行相关的操作：<br>
<a href="https://blog.csdn.net/s13383754499/article/details/82910704">彻底搞懂Android文件存储---内部存储，外部存储以及各种存储路径解惑</a><br>
<a href="https://www.jianshu.com/p/b752b2e70b8c">Android文件缓存目录</a><br>
重点关注：getExternalCacheDir、getExternalFilesDir。</p>
</li>
</ul>
<hr>
<h1 id="五-kotlin">五、Kotlin</h1>
<ul>
<li>
<p><strong>协程</strong><br>
<a href="https://www.jianshu.com/p/6e6835573a9c">Kotlin协程</a></p>
</li>
<li>
<p><strong>不再使用findViewById</strong><br>
在Module的build.gradle中加上：<code>apply plugin: 'kotlin-android-extensions'</code>，然后就可以直接使用布局中定义的id去访问对应的控件了。</p>
</li>
</ul>
<blockquote>
<p>在使用的时候，你会发现导入的包是<code>import kotlinx.android.synthetic.main.activity_main.*</code>(如layout名称为activity_main.xml)</p>
</blockquote>
<hr>
<h1 id="六-项目中三方库使用规范及示例">六、项目中三方库使用规范及示例</h1>
<ul>
<li>
<p><strong>ARouter——路由</strong></p>
<ul>
<li>概述<br>
一款阿里开源的路由框架，是一个帮助Android进行模块化、组件化开发的开源库。它支持模块间的路由、通信、解耦。</li>
<li>引入
<ul>
<li>添加依赖和配置<pre><code class="language-java">android {
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile 'com.alibaba:arouter-api:x.x.x'
    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'
    ...
}
// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'
// Kotlin配置参考文末'其他#5'

</code></pre>
<blockquote>
<p>所有使用ARouter的Module都必须在<code>build.gradle</code>中<code>dependencies</code>标签内添加<code>annotationProcessor 'com.alibaba:arouter-compiler:x.x.x</code>注释处理器。</p>
</blockquote>
</li>
<li>添加注解<pre><code class="language-java">// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = &quot;/test/activity&quot;)
public class YourActivity extend Activity {
    ...
}
</code></pre>
</li>
<li>初始化SDK<pre><code class="language-java">if (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
}
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化

</code></pre>
</li>
<li>发起路由操作<pre><code class="language-java">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build(&quot;/test/1&quot;)
            .withLong(&quot;key1&quot;, 666L)
            .withString(&quot;key3&quot;, &quot;888&quot;)
            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))
            .navigation();

</code></pre>
</li>
<li>使用 Gradle 插件实现路由表的自动加载 (可选)<pre><code class="language-java">apply plugin: 'com.alibaba.arouter'

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath &quot;com.alibaba:arouter-register:?&quot;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>使用规范<br>
在开发过程中，当我们对要进行跳转的页面上添加支持路由的注解时，我们需要遵循以下规则：<br>
<strong>路径需要注意的是至少需要有两级，/xx/xx，我们以/moduleName/className为基准进行对应的命名。</strong></li>
<li>使用示例<pre><code class="language-java">    @Route(path = &quot;/mine/mineActivity&quot;)
    class MineActivity {
    ...
    }
</code></pre>
</li>
<li>注意事项<br>
<strong>在使用该库的每个类的build.gradle文件中要添加如下配置：</strong><pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        // ARouter--每个使用到路由的Module必须加
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
        ...
    }
    ...
}
dependencies {
    // ARouter--每个使用到路由的Module必须加
    annotationProcessor rootProject.ext.dependencies['arouter-compiler']
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>DataBinding——数据绑定</strong></p>
<ul>
<li>
<p>概述<br>
数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</li>
<li>
<p>引入<br>
在使用DataBinding的Module中的build.gradle文件中进行如下操作：</p>
<ul>
<li>
<p>在文件最顶端(android标签外部)添加如下插件声明</p>
<pre><code class="language-java">plugins {
    ...
    id 'kotlin-kapt'
}
</code></pre>
</li>
<li>
<p>在android标签内部添加databinding引用（AndroidStudio 4.0+与之前写法不同）</p>
<pre><code class="language-java">buildFeatures {
    dataBinding = true
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用</p>
<ul>
<li>修改对应的布局<br>
使用Databinding的布局，最外层必须套一层layout标签，我们要修改对应的布局如下：<pre><code class="language-java">&lt;layout&gt;
    &lt;data&gt;
        ...
    &lt;/data&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        ...
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;/layout&gt;
</code></pre>
</li>
<li>给对应的控件绑定数据（这里以TextView为例）<br>
首先，在布局中添加一个TextView控件，然后在<code>&lt;data&gt;</code>标签内添加一个属性标签<code>&lt;variable&gt;</code>，其中name属性是指变量名称，type属性是指变量类型<pre><code class="language-java">&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    
    &lt;data&gt;

        &lt;variable
            name=&quot;titleStr&quot;
            type=&quot;String&quot; /&gt;
    &lt;/data&gt;
    
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        &lt;TextView
            android:id=&quot;@+id/tv_title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{titleStr}&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;layou/&gt;
</code></pre>
在页面中进行赋值操作：<pre><code class="language-java">DataBindingUtil.setContentView&lt;ActivitySimpleBindingImpl&gt;(this, R.layout.activity_simple)
    .apply {
        titleStr = &quot;DataBinding test&quot;
    }
</code></pre>
<blockquote>
<p>注：使用DataBinding的Activity会自动生成<code>ActivityXXXBindingImpl</code>，如SimpleActivity会生成ActivitySimpleBindingImpl类。</p>
</blockquote>
</li>
<li>点击事件的使用</li>
<li>RecyclerView的使用</li>
<li>ImageView加载一张网络图片</li>
</ul>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/e8cf690ee8cc">DataBinding + Kotlin</a></p>
</blockquote>
<ul>
<li>
<p><strong>Paging——分页</strong></p>
<ul>
<li>
<p>概述<br>
Paging 库可帮助您加载和显示来自本地存储或网络中更大的数据集中的数据页面。此方法可让您的应用更高效地利用网络带宽和系统资源。Paging 库的组件旨在契合推荐的 Android 应用架构，流畅集成其他 Jetpack 组件，并提供一流的 Kotlin 支持。</p>
<p>使用 Paging 库，您可以更加轻松地在应用的 RecyclerView 中逐步、流畅地加载数据。</p>
</li>
<li>
<p>引入</p>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
<li>
<p><strong>BottomNavigation——底部导航栏</strong><br>
<a href="https://www.jianshu.com/p/f0021265845f">Kotlin-BottomNavigationView</a><br>
<a href="https://blog.csdn.net/afei__/article/details/80950288">Android底部导航栏，三种风格和实现</a><br>
<a href="https://www.jianshu.com/p/1cebf8cd1a86">Android 底部导航之BottomNavigationBar</a><br>
<a href="https://blog.csdn.net/abs1004/article/details/77330726">安卓 BottomNavigationBar 底部导航栏 最简单用法详解</a></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】git命令行登陆github进行操作]]></title>
        <id>https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/</id>
        <link href="https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/">
        </link>
        <updated>2021-06-24T16:32:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>转载自<a href="https://www.jianshu.com/p/6e3f9e4e8e69">git命令行登陆github进行操作</a>，侵删。</strong></p>
</blockquote>
<p>登陆github必须先创建SSH key<br>
因为本地Git仓库和GitHub仓库之间的传输是通过SSH加密传输的，GitHub需要识别是否是你推送，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送，所以需要配置ssh key。</p>
<hr>
<h2 id="1创建ssh-key">1.创建SSH Key。</h2>
<p>在用户主目录（C:\Users\Administrator）下，看看有没有.ssh文件，如果有，再看文件下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接到下一步。如果没有，打开Git Bash，输入命令，创建SSH Key</p>
<p><code>$ ssh-keygen -t rsa -C &quot;你自己注册GitHub的邮箱&quot;</code></p>
<hr>
<h2 id="2接下来到github上打开account-settings-ssh-keys页面然后点击add-ssh-key填上title随意写在key文本框里粘贴-id_rsapub文件里的全部内容">2.接下来到GitHub上，打开“Account settings”--“SSH Keys”页面，然后点击“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容。</h2>
<p>id_rsa.pub 默认在C:\Users\Administrator.ssh</p>
<p>每台想要登陆某个github账号的主机都需要有一个对应的key，例如你有一个github账号，你在你的笔记本和台式上都要创建key</p>
<hr>
<h2 id="3git-bash里输入下面的命令登陆">3.git bash里输入下面的命令登陆</h2>
<p><code>$ ssh -T git@github.com</code></p>
<p>如果看到 hi + 你的用户名说明密钥验证通过了，你已经可以上传下载了<br>
<img src="https://jgduan.github.io//post-images/1624552568098.png" alt="" loading="lazy"></p>
<hr>
<h2 id="4设置username和email因为github每次commit都会记录他们">4.设置username和email，因为github每次commit都会记录他们</h2>
<p>git commit 命令会记录提交者的信息，所以使用git前必须先添加两条信息</p>
<p><code>$ git config --global user.name &quot;你的GitHub登陆名&quot;</code><br>
<code>$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
<blockquote>
<p>（其实可以不和github上面的用户名邮箱一致，只是为了避免混淆）</p>
</blockquote>
<hr>
<h2 id="5接下来就是把本地仓库传到github上去">5.接下来就是把本地仓库传到github上去</h2>
<p><code>$ git remote add origin git@github.com:userName/yourProject.git</code></p>
<p>//关联一个远程库命令，git@后面填写你的github repository（仓库），在github里面创建仓库后有http和ssh的链接，origin是你给这个仓库起的名字，可以自定义，下面命令中的origin也要相应改变</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1624552692583.webp" alt="" loading="lazy"></figure>
<p>git push -u origin master //把本地已经commit 的结果push到github的origin 仓库的master分支中</p>
<hr>
<p>##【拓展阅读】<br>
<a href="https://www.cnblogs.com/luhuan/p/9072820.html">Windows下配置Git多账号github码云</a></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Plugin version (1.4.32) is not the same as library version (1.4.10) 警告的解决办法]]></title>
        <id>https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/</id>
        <link href="https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/">
        </link>
        <updated>2021-06-24T15:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在开发<code>Kotlin</code>项目的过程中，使用<code>kotlin-stdlib</code>标准库时，遇到了如下警告提示：</p>
<pre><code class="language-java">Plugin version(1.4.32) is not the same as library version(1.4.10)
</code></pre>
<p>提示的大致意思是说我们的插件版本和依赖库的版本不一致，原因是因为一些第三方的Library库所依赖的版本比较低，而我们在项目中所指定的依赖版本比较高，从而导致AndroidStudio给我们提出了警示。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p><strong>直接在module的build.gradle中删除依赖即可解决问题</strong></p>
<pre><code class="language-java">// 删除moudle-build.gralde文件中的该段
implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
</code></pre>
<p>详情请移步官网查看官方声明的这篇文章：<a href="https://kotlinlang.org/docs/whatsnew14.html#dependency-on-the-standard-library-added-by-default">What's new in Kotlin 1.4</a><br>
<img src="https://jgduan.github.io//post-images/1624550094222.png" alt="" loading="lazy"></p>
<p>图中的意思是：</p>
<blockquote>
<p>Kotlin默认添加了stdlib的依赖，您不再需要stdlib在任何 Kotlin Gradle 项目（包括多平台项目）中声明对库的依赖。默认情况下添加依赖项。</p>
</blockquote>
<blockquote>
<p>自动添加的标准库将是 Kotlin Gradle 插件的相同版本，因为它们具有相同的版本。</p>
</blockquote>
<blockquote>
<p>对于特定于平台的源集，使用库的相应特定于平台的变体，同时将公共标准库添加到其余部分。Kotlin Gradle 插件将根据您的 Gradle 构建脚本的kotlinOptions.jvmTarget 编译器选项选择合适的 JVM 标准库。</p>
</blockquote>
<p>上面所说的Kotlin插件，是指Project根目录下的build.gradle文件中的Kotlin插件，具体如下图所示：<br>
<img src="https://jgduan.github.io//post-images/1624550446644.png" alt="" loading="lazy"></p>
<p>这样一来，让人糟心的警告就不见了。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Handler】This Handler class should be static or leaks might occur (anonymous android.os.Handler)]]></title>
        <id>https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/</id>
        <link href="https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/">
        </link>
        <updated>2021-06-20T15:12:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Android开发者在日常开发过程中，经常会使用到<code>Handler</code>用来接收消息进行后续处理，然而当我们在<code>Handler#handleMessage(Message msg)</code>方法中做UI相关操作时，AndroidStudio就会报出如下警告：</p>
<pre><code class="language-java">This Handler class should be static or leaks might occur (anonymous android.os.Handler)
Inspection info:Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected.
If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue.
If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows:
   1. Declare the Handler as a static class;
   2. In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler;
   3. Make all references to members of the outer class using the WeakReference object.
</code></pre>
<p>警告内容是提示我们在内部类<code>Handler#handleMessage(Message msg)</code>方法中处理UI相关操作时，可能会造成内存泄漏风险，同时在警告内容中，指导给开发者相应的解决方案——内部类Handler静态化、使用弱引用<code>WeakReference</code>来进行抑制处理、访问所有的外部成员通过<code>WeakReference</code>引用对象来进行访问。</p>
<blockquote>
<p>除此之外，我们还可以在Activity被销毁时通过<code>Handler#removeCallbacksAndMessages(Object token)</code>方法来销毁对应<code>Handler</code>所有的消息队列。</p>
</blockquote>
<hr>
<h1 id="主动创造一个引起内存泄漏的handler">主动创造一个引起内存泄漏的Handler</h1>
<p>这里我们通过创造一个有内存泄漏风险的<code>Handler</code>通过不断切换<code>Activity</code>横竖屏来进行测试，看是否会引发内存泄漏，示例如下：</p>
<pre><code class="language-java">// HandlerTestActivity.java
public class HandlerTestActivity extends AppCompatActivity {
 
    // 创建匿名Handler内部类的对象
    private Handler leakHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };
 
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_handler_test);
 
        leakHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                Logger.d(&quot;leakHandler 延迟执行,内存泄露测试&quot;);
            }
        }, 5 * 60 * 1000);
    }
}
</code></pre>
<p>通过多次运行分析后，我们发现：应用内存占用出现了明显了升高;</p>
<p><strong>简单描述下原因:</strong><br>
由于上面的<code>Handler</code>内部类定义在<code>UI</code>线程中,因此使用的主线程的<code>Looper</code>和 <code>MessageQueue</code>;<br>
<code>MessageQueue</code>中的<code>Message</code>会持有<code>Handler</code>对象;<br>
匿名<code>Handler</code>内部类对象持有着外部<code>Activity</code>的强引用;<br>
以上三点导致当有<code>Message</code>未被处理之前, 外部类<code>Activity</code>会一直被强引用,导致即使发生了销毁,也无法被GC回收;</p>
<p>因此处理方法通常有两种:</p>
<p>在外部类<code>Activity</code>销毁时取消所有的<code>Message</code>,即 <code>leakHandler.removeCallbacksAndMessages(null)</code>;<br>
让内部类不要持有外部<code>Activity</code>的强引用;<br>
<code>AndroidStudio</code>给出的提示方案属于第二种。</p>
<blockquote>
<p>我们通过smali源码来一步步探究验证下;<br>
<a href="https://blog.csdn.net/weixin_33923762/article/details/91430429">[smali] This Handler class should be static or leaks might occur</a></p>
</blockquote>
<hr>
<h1 id="弱引用的handler">弱引用的Handler</h1>
<p>因大家在项目中可能存在多出使用<code>Handler</code>，我们可以封装一个公共的<code>WeakHandler</code>类，抽取公共方法供其它使用区域在此基础上继承实现，实现后的代码如下：</p>
<pre><code class="language-java">public class WeakHandler&lt;T extends Activity&gt; extends Handler {
    private final WeakReference&lt;T&gt; mWkActivity;

    public WeakHandler(T activity) {
        mWkActivity = new WeakReference&lt;&gt;(activity);
    }

    public T getActivity() {
        return mWkActivity.get();
    }

//    @Override
//    public void handleMessage(Message msg) {
//        super.handleMessage(msg);
//        T targetAct = mWkActivity.get();
//        // 通过`WeakReference`对象去操作外部`Activity`属性和事件
//        if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
////           targetAct.对象
//        }
//    }

}
</code></pre>
<p>那么在其它地方我们可以通过继承<code>WeakHandler</code>类的方式来实现弱引用的<code>Handler</code>，示例如下：</p>
<pre><code class="language-java">SimpleWeakHandler simpleWeakHandler = new SimpleWeakHandler(SimpleActivity.this);
    private static class SimpleWeakHandler extends WeakHandler&lt;SimpleActivity&gt; {

        public SimpleWeakHandler(SimpleActivity activity) {
            super(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            SimpleActivity targetAct = getActivity();
            if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
                targetAct.tvTitle.setText(&quot;SimpleWeakHandler&quot;);
            }
        }
    }
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【合肥】Android 15k+招聘列表]]></title>
        <id>https://jgduan.github.io/post/he-fei-android-15kzhao-pin-lie-biao/</id>
        <link href="https://jgduan.github.io/post/he-fei-android-15kzhao-pin-lie-biao/">
        </link>
        <updated>2021-06-03T14:58:17.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>企业名称</th>
<th>规模</th>
<th>薪资范围</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.zhipin.com/job_detail/d9520547f8e6810d1nZy3tq9EFdX.html?ka=search_list_jname_8_blank&amp;lid=7e4TsFRJ8rx.search.8&amp;securityId=0MTB9UTp35FML-l1tN71WWrZdpvDkTdQdp0jtNzeS5lcmAtQ8wv1VdQLP3YVyd5Xy3UBVVzjpwpYlY0x9STelScv443n1JGi0G7yWuffajDwOKpI">声智科技</a></td>
<td>100-499人</td>
<td>14-24K·14薪</td>
<td>B轮，BLE优先，注册2000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/74de27973b151e941nZ73dy9ElVQ.html?ka=search_list_jname_3_blank&amp;lid=7e4TsFRJ8rx.search.3&amp;securityId=HfXkRdJw7U651-R1vFwoW-XeqQl5ZoKj1anZnXOqGs60SC1EfasnQnIdIK3EnyhoJ2o1rNlqN9owlPzRsX2wuv-8Ancc2PlIkCqosrsj8puBDtHIvDD0">星河智联</a></td>
<td>100-499人</td>
<td>15-30K·14薪</td>
<td>讯飞+广汽，注册8500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/0d3783ca84c5f16b1nZ73dy9ElJX.html?ka=search_list_jname_71_blank&amp;lid=7e4TsFRJ8rx.search.71&amp;securityId=qdLjqsTw-P7Vu-H1m690t_zxqjhl400DMnDG082DGT-6d006_5a_3fgfMWzNxlvJFSP0vQKe9t-OE4sjYhi1sySlW3TR6R6ml4H6QS2m8jK2VR5fpZPd">星河智联</a></td>
<td>100-499人</td>
<td>16-27K·15薪</td>
<td>4年SDK经验，注册8500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/50f7f60b0a9068d41nV-3ti4FVZS.html?ka=search_list_jname_6_blank&amp;lid=7e4TsFRJ8rx.search.6&amp;securityId=G2WqzXeq8ogk--g1SGrF1nc1V_3PLxRAoYreJU8V-d7AqMY17YqztlCLMUSOZe9eCXs3WTem1LMiAObfsJehCPy6BvPDrTUVQyQM1xxQL8Ul9jBGbw%7E%7E">至博光电</a></td>
<td>20-99人</td>
<td>18-28K·14薪</td>
<td>注册9900万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/49ecb91030fa20e91XVy29S5EFA~.html?ka=search_list_jname_9_blank&amp;lid=7e4TsFRJ8rx.search.9&amp;securityId=eWosVjUVb3HS8-11jIVSN4J16MYm_8CuV__TbocyKiLQxONVmiwuQoiv93OY4U3Jf7D9eSiKwUAyFyZreQbCjhUT29wss61jXiZpxFpTeKx7YFQJ">ZOOM</a></td>
<td>500-999人</td>
<td>12-23K·14薪</td>
<td>已上市，注册730w美元</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/a4d1bf001f7554841nd62tW5E1BW.html?ka=search_list_jname_13_blank&amp;lid=7e4TsFRJ8rx.search.13&amp;securityId=Ofye-K8cl5Mr7-n1spJMDl6QcFkPzBstSB0fn-6nRjeY06nK399YAc--VLHkq3iS0fJKKp_PAG-QupbUsSbxKq8bU59b5iUgvOHg2iqZadmlGmlM">爱点击</a></td>
<td>1000-9999人</td>
<td>15-30K·14薪</td>
<td>注册26900万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/034df4a46d925f801nZz0tu9ElpT.html?ka=search_list_jname_16_blank&amp;lid=7e4TsFRJ8rx.search.16&amp;securityId=a53zI2spdrmlz-B1qslaixw2qt05RR0t8TJgaCw9GGekrRovpiiCEyfnVkNNRnodHLSqZh82KRTcQg6RdmfdusG8FL0Zh9wQtKnkU9lErdkNwvhvXQ%7E%7E">深圳优仕康</a></td>
<td>20-99人</td>
<td>12-24K</td>
<td>独立开发，注册1000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/cefdcaa23625427e33x83Nm_FVE~.html?ka=search_list_jname_17_blank&amp;lid=7e4TsFRJ8rx.search.17&amp;securityId=Cf_9WxXyCOAI5-F1d0cV5Jj3sG8CShCZPtbm32ZUFfG0VtoJYNicvVgv4P-ZG-V9NIZ6Il3orBtjiRGJs62pzajXzOQbWn_UEk5Z7nnLWu7u4ZTG">米娱科技</a></td>
<td>100-499人</td>
<td>12-22K·14薪</td>
<td>注册500万人民币</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/7b8fab8a3f28be1433Ny2d29FVA~.html?ka=search_list_jname_52_blank&amp;lid=7e4TsFRJ8rx.search.52&amp;securityId=yXTSOx7BEdbnS-R1rBucgK20hxY-5uH6Vq4elL65HxvmkHs7WVYxsdoVI4Amst7jCZ1hNhG0AUjJwaiXRZweQUs0sYJu3PUCaGfl7zCDz0scu5bt">米娱科技</a></td>
<td>100-499人</td>
<td>15-25K·14薪</td>
<td>独立开发要求，注册500万人民币</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/3b9003a1a5de83fa1nZ939u8EldU.html?ka=search_list_jname_18_blank&amp;lid=7e4TsFRJ8rx.search.18&amp;securityId=CudY8Fq5WN8e9-a1JkTZp7BZLnF2DGymHrDuxAYGp1nhzrhr6X1TjUdWDhzTcUGWqBSU1PujSTOjpJdOUi3kuqwsGLVKyPCgwP5oUUk3RSYgKeTNVD0%7E">中科数盾</a></td>
<td>100-499人</td>
<td>20-30K·14薪</td>
<td>Android Leader岗，注册2200万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/25f432e3e85bfcd11nRy2tu5GVdT.html?ka=search_list_jname_19_blank&amp;lid=7e4TsFRJ8rx.search.19&amp;securityId=LtF76yyJ_924q-a1BFRtZ61eZYx4n6MgLi17RXcX4jUO2WH0GNO8gWFkPzq6eQQ9vN0mrJB5CFiaU4ks5twx6rQ4oTe4_v6OE8_h75ko_oZbmL_KaXg%7E">徽娱传媒</a></td>
<td>20-99人</td>
<td>12-22K·14薪</td>
<td>注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/ff34bebf7c8627291nd43dq5FltS.html?ka=search_list_jname_21_blank&amp;lid=7e4TsFRJ8rx.search.21&amp;securityId=_Sf8VeIr-oMZQ-p1g-lg_6TMKseg2RKl602khYJHQVj8VO1SJzCZQ8eQOuUel2E6waM9ydSDjtuqxSorCC_gJKswb-MKsRJDm-Kuu98mELqALCM69V0%7E">的卢深视</a></td>
<td>100-499人</td>
<td>14-28K·15薪</td>
<td>Android平台算法SDK，注册595万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/3060c00d3a1713203nJ92Ni4Flc~.html?ka=search_list_jname_24_blank&amp;lid=7e4TsFRJ8rx.search.24&amp;securityId=uZFPD8cGA1FgP-41owavIWLodXP6ho090YOYEFq104bQfmE7C-LL3ZeZmuFRGmzO2ddwIrowMt37bMlBk5JAEJcWx8O4FbXl-HGUZjLg7ikWme6A">瀚茗斯</a></td>
<td>20-99人</td>
<td>14-28K</td>
<td>Android Leader岗，注册1000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/291d91989aaa84b51nZ-2tS4FlNT.html?ka=search_list_jname_25_blank&amp;lid=7e4TsFRJ8rx.search.25&amp;securityId=IczMxAR1txtjz-v1NacOcigcr-f00fD-68Ziy6wJiEtXyPlKADl7rVKxNNQVd2Qxw0UnvT3-YTA26CGrVJgkhbd0pJBBY5ggZ4LiBDkOBGeQYY0O4dk%7E">屯大软件</a></td>
<td>20-99人</td>
<td>15-23K</td>
<td>可能是外包，注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/d293564f07f222c51nB83ty8ElBY.html?ka=search_list_jname_51_blank&amp;lid=7e4TsFRJ8rx.search.51&amp;securityId=LlQ9wQKZ_pZL3-o1b29PKzxqdFmiAcb6LV8xQErkKfDFgRqtZmLvCJoMIGrZIfi9o_Aq-7Dh3AO-reG8eROmJYM3YWQ8szVjctV0YaiGa_7uRKbo">科大讯飞</a></td>
<td>10000人以上</td>
<td>15-25K·14薪</td>
<td>RN/Flutter优先，注册222473万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/eac33ac5cf350d521nBz3d2_FFBU.html?ka=search_list_jname_66_blank&amp;lid=7e4TsFRJ8rx.search.66&amp;securityId=w3fBWRwbCVmPx-E1jyrIoTX7l-ZnfrtoRp-vgH_fi0Vg6BaFpyGWTD2iph1hYmlneBDJjAKkh9P2BkhnAEwyEMe7K_eNFwwCQyXVGnELtOStkMI%7E">科大讯飞</a></td>
<td>10000人以上</td>
<td>13-23K·14薪</td>
<td>注册222473万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/b1e62a6936767a641nZ_09m-FlpT.html?ka=comp_joblist_1">江湖科技</a></td>
<td>20-99人</td>
<td>15-20K</td>
<td>Flutter，注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/b2214314e8c5bc131nZz29q4EFBW.html?ka=job_recommend_1">一视科技</a></td>
<td>20-99人</td>
<td>15-25K·14薪</td>
<td>注册500万</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>持续维护中。。。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Activity面试题进阶]]></title>
        <id>https://jgduan.github.io/post/android-activity-mian-shi-ti-jin-jie/</id>
        <link href="https://jgduan.github.io/post/android-activity-mian-shi-ti-jin-jie/">
        </link>
        <updated>2021-05-25T15:10:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-有两个activity-a和activity-b在activity-a中打开activity-b时它们都会有哪些生命周期回调">1. 有两个Activity A和Activity B，在Activity A中打开Activity B时，它们都会有哪些生命周期回调？</h1>
<ul>
<li>当被启动的目标<code>launchMode</code>为默认<code>standard</code>的情况下，在Activity A中打开Activity B时，生命周期回调顺序为：<br>
A.onPause()-&gt;B.onCreate()-&gt;B.onStart()-&gt;B.onResume()-&gt;A.onStop()；</li>
<li>当被启动的目标<code>launchMode</code>为<code>singleTop</code>且目标在栈顶的情况下，生命周期回调顺序为：<br>
B.onPause()-&gt;B.onNewIntent()-&gt;B.onResume()；</li>
<li>当被启动的目标<code>launchMode</code>为<code>singleInstance、singleTask</code>的情况下且对应的目标Activity有可复用的实例时，生命周期回调顺序为：`A.onPause()-&gt;B.onNewIntent()-&gt;B.onRestart()-&gt;B.onStart()-&gt;B.onResume()-&gt;A.onStop()-&gt;A.onDestory()（A被移出栈时调用）。</li>
</ul>
<hr>
<h1 id="2在activity中弹出dialog会对其生命周期造成什么影响">2.在Activity中弹出Dialog会对其生命周期造成什么影响？</h1>
<ul>
<li>如果启动的是常规的<code>Dialog</code><br>
因生命周期的回调都是<code>AMS</code>通过<code>Binder</code>通知应用进程的，而弹出<code>Dialog、Toast、PopupWindow</code>本质上都是通过<code>WindowsManager.addView()</code>显示的，并没有经过<code>ActivityManagerService</code>，所以不会对<code>Activity</code>的生命周期产生影响。</li>
<li>如果启动的是<code>Theme为Dialog的Activity</code><br>
会对<code>Activity</code>的生命周期造成影响，会触发如下生命周期回调（原<code>Activity</code>为A，弹出来的<code>DialogActivity</code>为B）：<br>
A.onPause()-&gt;B.onCreate()-&gt;B.onStart()-&gt;B.onResume()。</li>
</ul>
<blockquote>
<p>注：这个相对于上面的<code>Activity</code>互相之间的启动，你会发现，<strong>原<code>Activity</code>并没有触发<code>onStop</code>回调</strong>，这是因为<code>Activity</code>只有切换到后台不可见时才会触发<code>onStop</code>回调方法，而当弹出一个<code>Theme为Dialog的Activity</code>时，此前的一个页面还处于可见的情况，只是失去了焦点，所以仅回调了<code>onPause</code>方法。</p>
</blockquote>
<hr>
<h1 id="3为什么activity在onresume之后才显示">3.为什么Activity在onResume之后才显示？</h1>
<p>我们的Activity一般是在onCreate方法中通过setContentView来进行设置，那么为什么Activity要在onResume之后才显示呢？这中间经历了什么？</p>
<p>当我们在onCreate中通过setContentView方法设置布局时，实际上是直接调用了Window的setContentView，创建了一个DecorView用来包裹我们的布局：</p>
<pre><code class="language-java">PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } 
    ...
    // 加载布局，添加到 mContentParent
    // mContentParent 又是 DecorView 的一个子布局  
    mLayoutInflater.inflate(layoutResID, mContentParent);
}
</code></pre>
<p>其实这一步只是加载好了布局，生成了一个ViewTree，具体怎么把ViewTree显示出来，答案就在下面：</p>
<pre><code class="language-java">ActivityThread.java
public void handleResumeActivity(...){
    // onResume 回调
    ActivityClientRecord r = performResumeActivity(...)
    final Activity a = r.activity;
    if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {
        r.window = r.activity.getWindow();
        View decor = r.window.getDecorView();
        ViewManager wm = a.getWindowManager();
        wm.addView(decor, l);// 重点
    }
}
</code></pre>
<p>WindowManager的addView方法最终将DecorView添加到WMS，实现绘制到屏幕、接触触摸事件，具体调用如下：</p>
<pre><code class="language-java">   WindowManagerImpl.addView
-&gt; WindowManagerGlobal.addView
-&gt; ViewRootImpl.setView     
-&gt; ViewRootImpl.requestLayout() // 执行 View 的绘制流程
   // 通过 Binder 调用 WMS ，WMS 会添加一个 Window 相关的对象
   // 应用端通过 mWindowSession 调用 WMS
   // WMS 通过 mWindow (一个 Binder 对象) 调用应用端  
   mWindowSession.addToDisplay(mWindow) 
</code></pre>
<p>综上，在 onResume 回调之后，会创建一个 ViewRootImpl ，有了它之后应用端就可以和 WMS 进行双向调用了。</p>
<hr>
<h1 id="4onactivityresult在哪两个生命线周期之间回调">4.onActivityResult在哪两个生命线周期之间回调</h1>
<p><code>onActivityResult</code>不属于Activity的生命周期组成，<code>onActivityResult</code>该方法的源码注释中写到<code>You will receive this call immediately before onResume() when your activity is re-starting.</code>，跟一下代码（<code>TransactionExecutor.execute</code>有兴趣的可以自己打断点跟一下），会发现<code>onActivityResult</code>回调先于该<code>Activity</code>的所有生命周期回调，从B Activity到A Activity的生命周期回调为：<br>
B.onPause()-&gt;A.onActivityResult()-&gt;A.onRestart()-&gt;A.onStart()-&gt;A.onResume()。</p>
<hr>
<h1 id="5oncreate方法里面写死循环会触发anr吗">5.onCreate方法里面写死循环会触发ANR吗？</h1>
<p>不会触发，因为Activity的生命周期中写死循环，只要不进行其它操作，不满足触发ANR的条件。</p>
<blockquote>
<p>ANR产生的四种场景：<br>
1.Service TimeOut:  service 未在规定时间执行完成：前台服务 20s，后台 200s；<br>
2.BroadCastQueue TimeOut: 未在规定时间内未处理完广播：前台广播 10s 内, 后台 60s 内；<br>
3.ContentProvider TimeOut:  publish 在 10s 内没有完成；<br>
4.Input Dispatching timeout:  5s 内未响应键盘输入、触摸屏幕等事件。</p>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】一线面试题汇总]]></title>
        <id>https://jgduan.github.io/post/android-yi-xian-mian-shi-ti-hui-zong/</id>
        <link href="https://jgduan.github.io/post/android-yi-xian-mian-shi-ti-hui-zong/">
        </link>
        <updated>2021-05-19T14:19:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-基础系列">一、基础系列</h1>
<ol>
<li><strong>Activity的四种启动模式；</strong></li>
<li><strong>Activity生命周期中在onStart、onStop中做了什么；</strong></li>
<li><strong>为什么Activity之间传递对象需要序列化；</strong></li>
<li><strong>Http由哪些部分组成？Http与Https有什么区别；</strong></li>
<li><strong>请描述一个Http的请求过程；</strong></li>
<li><strong>用过哪些网络请求框架？okhttp如何复用连接？</strong></li>
<li><strong>什么是强引用、什么是弱引用，它们能干什么；</strong></li>
<li><strong>线程、线程池的概念描述；</strong></li>
<li><strong>动画有哪些种类？都适用于什么场景；</strong></li>
<li><strong>Android中的三级缓存是什么；</strong></li>
<li><strong>Sharepreferences的使用场景？能跨进程访问吗？工作原理是什么；</strong></li>
<li><strong>常用的数据库有哪些？如何进行升降级；</strong></li>
<li><strong>MVC、MVP、MVVM架构模式概念描述，常用哪个；</strong></li>
<li><strong>对Jetpack哪些组件比较了解？简单描述下其工作原理及适用场景；</strong></li>
<li><strong>简述Android的启动流程；</strong></li>
<li><strong>android:style与android:theme的区别是什么；</strong></li>
<li><strong>请简述Intent概念（含Filter），Intent传递对象大小有限制吗、为什么；</strong></li>
<li><strong>请简述Service前后台服务及其使用场景，Android8.0+如何兼容；</strong></li>
<li><strong>BroadcastReceiver动、静态注册；</strong></li>
<li><strong>ContentProvider是什么，请介绍其使用场景；</strong></li>
<li><strong>Java与Kotlin有什么区别？优缺点；</strong></li>
<li><strong>View的绘制流程是什么样的？如果屏幕方向发生改变会影响到什么；</strong></li>
<li><strong>请简述事件分发机制；</strong></li>
<li><strong>View与ViewGroup的关系描述；</strong></li>
<li><strong>你是如何做屏幕适配的（sw策略）；</strong></li>
<li><strong>Window、View、Activity之间的关系；</strong></li>
<li><strong>介绍下Handler的原理；</strong></li>
<li><strong>性能优化有哪些方式。</strong></li>
</ol>
<hr>
<h1 id="二-进阶系列">二、进阶系列</h1>
<ol>
<li><strong>WindowManagerService简述及其作用；</strong></li>
<li><strong>ActivityManagerService简述及其作用；</strong></li>
<li><strong>ConstraintLayout为什么效果好？为什么多了层级，性能可能会差很多；</strong></li>
<li><strong>什么是ANR？如何避免；</strong></li>
<li><strong>如何防止内存泄漏、OOM；</strong></li>
<li><strong>如何降低App异常崩溃提高稳定性；</strong></li>
<li><strong>什么是IPC？IPC有哪些实现方式；</strong></li>
<li><strong>内存优化工具LeakCanary和MAT的原理是什么；</strong></li>
<li><strong>什么是JVM，简述下内存模型；</strong></li>
<li><strong>Java为什么能够跨平台；</strong></li>
<li><strong>Java类文件的编译过程；</strong></li>
<li><strong>什么是组件化？你在项目中是如何实现组件化的？功能模块之间的相互引用如何处理、会有哪些问题；</strong></li>
<li><strong>Java同步机制有哪些，volatile和syncronized区别；</strong></li>
<li><strong>HashMap和HashTable区别；</strong></li>
<li><strong>List、ArrayList、LinkedList之间的关系、区别；</strong></li>
<li><strong>简述下PackageManagerService的工作流程；</strong></li>
<li><strong>Android是如何加载so文件的；</strong></li>
<li><strong>请介绍下Binder的原理及流程；</strong></li>
<li><strong>Java同步机制有哪些；</strong></li>
<li><strong>Recycleview如何做到回收复用的。</strong></li>
</ol>
<hr>
]]></content>
    </entry>
</feed>