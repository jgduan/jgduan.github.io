<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-06-28T14:45:52.025Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【Android】创建签名提示“迁移到行业标准格式PKCS12”问题]]></title>
        <id>https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/">
        </link>
        <updated>2021-06-28T14:21:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>Android Studio新建项目签名时创建签名文件时，提示“迁移到行业标准格式PKCS12”。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>在Android Studio上，通过命令行创建签名文件。</p>
<ol>
<li>输入以下命令：</li>
</ol>
<pre><code class="language-java">keytool -genkey -alias 这里替换成你的应用别名 -keypass 这里填写你的别名密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore 签名文件的存储路径\你得项目名称\app\xxx.jks -storepass 你的签名密码
</code></pre>
<p>你需要修改以下四处：</p>
<ul>
<li>应用别名（alias）</li>
<li>别名密码（alias password）</li>
<li>签名文件保存的路径（全路径，如：D:/TestProject/app/test.jks）</li>
<li>签名密码</li>
</ul>
<ol start="2">
<li>第1步完成后，回车，然后填写签名作者相关信息</li>
</ol>
<pre><code class="language-java">您的名字与姓氏是什么?
  [Unknown]:  zihao
您的组织单位名称是什么?
  [Unknown]:  xxxx
您的组织名称是什么?
  [Unknown]:  xxxx
您所在的城市或区域名称是什么?
  [Unknown]:  HeFei
您所在的省/市/自治区名称是什么?
  [Unknown]:  AnHui
该单位的双字母国家/地区代码是什么?
  [Unknown]:  0086
CN=zihao, OU=xxxx, O=xxxx L=HeFei, ST=AnHui, C=0086是否正确?
  [否]:  y
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【DOHENES】基于Kotlin的v3.0架构规范]]></title>
        <id>https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/</id>
        <link href="https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/">
        </link>
        <updated>2021-06-25T14:17:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>项目采用了<code>MVVM</code>架构方式+组件化方案+<code>Jetpack</code>常用库，基于<code>Kotlin 1.4.32</code>编译版本，在个别<code>Module</code>的部分区域混合使用了<code>Java（Java 8版本）</code>来进行开发工作，具体使用的三方库及其使用方法、示例将在文末进行讲解。</p>
<hr>
<h1 id="一-架构模式-mvvm">一、架构模式-MVVM</h1>
<p>项目采用<code>MVVM</code>架构模式，这里通过<code>Jetpack</code>的<code>ViewModel</code>组件来更换传统的<code>ViewModel</code>。</p>
<p><a href="https://www.jianshu.com/p/449136bddff6">Android MVVM 模式</a></p>
<hr>
<h1 id="二-project-组件化">二、Project-组件化</h1>
<p>为了各个功能模块之间解耦、<code>Module</code>灵活组合编译运行，便于团队协作开发及后期维护，3.0版本架构在多<code>Module</code>的基础上，采用了组件化方案来进一步优化项目架构。</p>
<ul>
<li>
<p><strong>模块解耦</strong><br>
项目采用组件化方案进行模块的<strong>解耦</strong>处理。</p>
</li>
<li>
<p><strong>组件分类及命名规范</strong><br>
整体架构分层与v2.0版本类似，除了最上层的<code>base、common</code>两大Library基础库，功能成分库继续采用<code>component-xxx</code>来进行命名，包含界面、具体业务逻辑的Library继续用<code>module-xxx</code>进行命名。</p>
</li>
</ul>
<blockquote>
<p>具体可参考<a href="https://jgduan.github.io/post/dohenes-tb-gai-ban-v20-zheng-ti-jia-gou-gui-fan/">【DOHENES】TB改版v2.0整体架构规范</a></p>
</blockquote>
<ul>
<li>
<p><strong>统一的引用配置</strong><br>
为保持引用库版本一致，规避开发过程中不必要的冲突。项目中通过Project根目录下的<code>config.gradle</code>文件，定义通用的构建元素字段，供各个模块进行引用。</p>
</li>
<li>
<p><strong>独立编译运行</strong><br>
发挥组件化方案的优势，通过在<code>config.gradle</code>中配置对应控制变量对各<code>moudle</code>进行<code>library-&gt;application</code>的灵活控制，让<code>module</code>既可以独立编译运行，又可以集成编译，按需灵活配置，方便开发人员协作。</p>
</li>
</ul>
<hr>
<h1 id="三-屏幕分辨率适配">三、屏幕（分辨率适配）</h1>
<p>依据实际的<code>UI</code>设计图，我们以<code>sw-375dp</code>为基准进行屏幕的适配工作，相应适配文件存放于<code>base-&gt;res/values、values-swxxxdp/measure.xml</code>内。<br>
在实际开发中根据UI设计图尺寸直接设置对应控件的尺寸即可（<code>@dimen/common_measure_xxxdp</code>），具体使用示例如下：</p>
<pre><code class="language-java">// 在需要使用地方添加对应的尺寸
android:layout_height=&quot;@dimen/common_measure_xxxdp&quot;
</code></pre>
<hr>
<h1 id="四-数据存储">四、数据存储</h1>
<ul>
<li>
<p><strong>ROOM</strong><br>
<a href="https://blog.csdn.net/yu540135101/article/details/110670477">Android kotlin+协程+Room数据库的简单使用</a><br>
<a href="https://www.jianshu.com/p/0dde643ac045">Android Room的简单使用</a></p>
</li>
<li>
<p><strong>DataStore</strong></p>
</li>
<li>
<p><strong>Native Files</strong><br>
当我们在开发过程涉及到一些需要缓存的文件时，很多应用采取的策略是到<code>SD卡</code>的根目录上创建自己的文件夹然后保存到对应的文件路径下（之前的泰邦设计也是这样做的），虽然达到了缓存文件的目的，但它并不被Android所推荐——当应用卸载后，这些被创建的文件夹仍然存在，造成手机内多出了不少的垃圾文件，这样是极不友好的。<br>
Android建议我们在缓存文件时使用应用专属（这里又分内部存储与外部存储，建议是尽可能使用外部存储进行缓存）的缓存路径进行文件的缓存，当应用被卸载后，这些数据也会随之而消失，从而规避了上述问题。<br>
关于应用专属内、外部存储的更多了解，建议阅读以下文章或自行了解后再进行相关的操作：<br>
<a href="https://blog.csdn.net/s13383754499/article/details/82910704">彻底搞懂Android文件存储---内部存储，外部存储以及各种存储路径解惑</a><br>
<a href="https://www.jianshu.com/p/b752b2e70b8c">Android文件缓存目录</a><br>
重点关注：getExternalCacheDir、getExternalFilesDir。</p>
</li>
</ul>
<hr>
<h1 id="五-kotlin">五、Kotlin</h1>
<ul>
<li>
<p><strong>协程</strong><br>
<a href="https://www.jianshu.com/p/6e6835573a9c">Kotlin协程</a></p>
</li>
<li>
<p><strong>不再使用findViewById</strong><br>
在Module的build.gradle中加上：<code>apply plugin: 'kotlin-android-extensions'</code>，然后就可以直接使用布局中定义的id去访问对应的控件了。</p>
</li>
</ul>
<blockquote>
<p>在使用的时候，你会发现导入的包是<code>import kotlinx.android.synthetic.main.activity_main.*</code>(如layout名称为activity_main.xml)</p>
</blockquote>
<hr>
<h1 id="六-项目中三方库使用规范及示例">六、项目中三方库使用规范及示例</h1>
<ul>
<li>
<p><strong>ARouter——路由</strong></p>
<ul>
<li>概述<br>
一款阿里开源的路由框架，是一个帮助Android进行模块化、组件化开发的开源库。它支持模块间的路由、通信、解耦。</li>
<li>引入
<ul>
<li>添加依赖和配置<pre><code class="language-java">android {
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile 'com.alibaba:arouter-api:x.x.x'
    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'
    ...
}
// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'
// Kotlin配置参考文末'其他#5'

</code></pre>
<blockquote>
<p>所有使用ARouter的Module都必须在<code>build.gradle</code>中<code>dependencies</code>标签内添加<code>annotationProcessor 'com.alibaba:arouter-compiler:x.x.x</code>注释处理器。</p>
</blockquote>
</li>
<li>添加注解<pre><code class="language-java">// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = &quot;/test/activity&quot;)
public class YourActivity extend Activity {
    ...
}
</code></pre>
</li>
<li>初始化SDK<pre><code class="language-java">if (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
}
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化

</code></pre>
</li>
<li>发起路由操作<pre><code class="language-java">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build(&quot;/test/1&quot;)
            .withLong(&quot;key1&quot;, 666L)
            .withString(&quot;key3&quot;, &quot;888&quot;)
            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))
            .navigation();

</code></pre>
</li>
<li>使用 Gradle 插件实现路由表的自动加载 (可选)<pre><code class="language-java">apply plugin: 'com.alibaba.arouter'

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath &quot;com.alibaba:arouter-register:?&quot;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>使用规范<br>
在开发过程中，当我们对要进行跳转的页面上添加支持路由的注解时，我们需要遵循以下规则：<br>
<strong>路径需要注意的是至少需要有两级，/xx/xx，我们以/moduleName/className为基准进行对应的命名。</strong></li>
<li>使用示例<pre><code class="language-java">    @Route(path = &quot;/mine/mineActivity&quot;)
    class MineActivity {
    ...
    }
</code></pre>
</li>
<li>注意事项<br>
<strong>在使用该库的每个类的build.gradle文件中要添加如下配置：</strong><pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        // ARouter--每个使用到路由的Module必须加
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
        ...
    }
    ...
}
dependencies {
    // ARouter--每个使用到路由的Module必须加
    annotationProcessor rootProject.ext.dependencies['arouter-compiler']
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>DataBinding——数据绑定</strong></p>
<ul>
<li>
<p>概述<br>
数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</li>
<li>
<p>引入<br>
在使用DataBinding的Module中的build.gradle文件中进行如下操作：</p>
<ul>
<li>
<p>在文件最顶端(android标签外部)添加如下插件声明</p>
<pre><code class="language-java">plugins {
    ...
    id 'kotlin-kapt'
}
</code></pre>
</li>
<li>
<p>在android标签内部添加databinding引用（AndroidStudio 4.0+与之前写法不同）</p>
<pre><code class="language-java">buildFeatures {
    dataBinding = true
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用</p>
<ul>
<li>修改对应的布局<br>
使用Databinding的布局，最外层必须套一层layout标签，我们要修改对应的布局如下：<pre><code class="language-java">&lt;layout&gt;
    &lt;data&gt;
        ...
    &lt;/data&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        ...
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;/layout&gt;
</code></pre>
</li>
<li>给对应的控件绑定数据（这里以TextView为例）<br>
首先，在布局中添加一个TextView控件，然后在<code>&lt;data&gt;</code>标签内添加一个属性标签<code>&lt;variable&gt;</code>，其中name属性是指变量名称，type属性是指变量类型<pre><code class="language-java">&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    
    &lt;data&gt;

        &lt;variable
            name=&quot;titleStr&quot;
            type=&quot;String&quot; /&gt;
    &lt;/data&gt;
    
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        &lt;TextView
            android:id=&quot;@+id/tv_title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{titleStr}&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;layou/&gt;
</code></pre>
在页面中进行赋值操作：<pre><code class="language-java">DataBindingUtil.setContentView&lt;ActivitySimpleBindingImpl&gt;(this, R.layout.activity_simple)
    .apply {
        titleStr = &quot;DataBinding test&quot;
    }
</code></pre>
<blockquote>
<p>注：使用DataBinding的Activity会自动生成<code>ActivityXXXBindingImpl</code>，如SimpleActivity会生成ActivitySimpleBindingImpl类。</p>
</blockquote>
</li>
<li>点击事件的使用</li>
<li>RecyclerView的使用</li>
<li>ImageView加载一张网络图片</li>
</ul>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/e8cf690ee8cc">DataBinding + Kotlin</a></p>
</blockquote>
<ul>
<li>
<p><strong>Paging——分页</strong></p>
<ul>
<li>
<p>概述<br>
Paging 库可帮助您加载和显示来自本地存储或网络中更大的数据集中的数据页面。此方法可让您的应用更高效地利用网络带宽和系统资源。Paging 库的组件旨在契合推荐的 Android 应用架构，流畅集成其他 Jetpack 组件，并提供一流的 Kotlin 支持。</p>
<p>使用 Paging 库，您可以更加轻松地在应用的 RecyclerView 中逐步、流畅地加载数据。</p>
</li>
<li>
<p>引入</p>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
<li>
<p><strong>BottomNavigation——底部导航栏</strong><br>
<a href="https://www.jianshu.com/p/f0021265845f">Kotlin-BottomNavigationView</a><br>
<a href="https://blog.csdn.net/afei__/article/details/80950288">Android底部导航栏，三种风格和实现</a><br>
<a href="https://www.jianshu.com/p/1cebf8cd1a86">Android 底部导航之BottomNavigationBar</a><br>
<a href="https://blog.csdn.net/abs1004/article/details/77330726">安卓 BottomNavigationBar 底部导航栏 最简单用法详解</a></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】git命令行登陆github进行操作]]></title>
        <id>https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/</id>
        <link href="https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/">
        </link>
        <updated>2021-06-24T16:32:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>转载自<a href="https://www.jianshu.com/p/6e3f9e4e8e69">git命令行登陆github进行操作</a>，侵删。</strong></p>
</blockquote>
<p>登陆github必须先创建SSH key<br>
因为本地Git仓库和GitHub仓库之间的传输是通过SSH加密传输的，GitHub需要识别是否是你推送，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送，所以需要配置ssh key。</p>
<hr>
<h2 id="1创建ssh-key">1.创建SSH Key。</h2>
<p>在用户主目录（C:\Users\Administrator）下，看看有没有.ssh文件，如果有，再看文件下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接到下一步。如果没有，打开Git Bash，输入命令，创建SSH Key</p>
<p><code>$ ssh-keygen -t rsa -C &quot;你自己注册GitHub的邮箱&quot;</code></p>
<hr>
<h2 id="2接下来到github上打开account-settings-ssh-keys页面然后点击add-ssh-key填上title随意写在key文本框里粘贴-id_rsapub文件里的全部内容">2.接下来到GitHub上，打开“Account settings”--“SSH Keys”页面，然后点击“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容。</h2>
<p>id_rsa.pub 默认在C:\Users\Administrator.ssh</p>
<p>每台想要登陆某个github账号的主机都需要有一个对应的key，例如你有一个github账号，你在你的笔记本和台式上都要创建key</p>
<hr>
<h2 id="3git-bash里输入下面的命令登陆">3.git bash里输入下面的命令登陆</h2>
<p><code>$ ssh -T git@github.com</code></p>
<p>如果看到 hi + 你的用户名说明密钥验证通过了，你已经可以上传下载了<br>
<img src="https://jgduan.github.io//post-images/1624552568098.png" alt="" loading="lazy"></p>
<hr>
<h2 id="4设置username和email因为github每次commit都会记录他们">4.设置username和email，因为github每次commit都会记录他们</h2>
<p>git commit 命令会记录提交者的信息，所以使用git前必须先添加两条信息</p>
<p><code>$ git config --global user.name &quot;你的GitHub登陆名&quot;</code><br>
<code>$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
<blockquote>
<p>（其实可以不和github上面的用户名邮箱一致，只是为了避免混淆）</p>
</blockquote>
<hr>
<h2 id="5接下来就是把本地仓库传到github上去">5.接下来就是把本地仓库传到github上去</h2>
<p><code>$ git remote add origin git@github.com:userName/yourProject.git</code></p>
<p>//关联一个远程库命令，git@后面填写你的github repository（仓库），在github里面创建仓库后有http和ssh的链接，origin是你给这个仓库起的名字，可以自定义，下面命令中的origin也要相应改变</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1624552692583.webp" alt="" loading="lazy"></figure>
<p>git push -u origin master //把本地已经commit 的结果push到github的origin 仓库的master分支中</p>
<hr>
<p>##【拓展阅读】<br>
<a href="https://www.cnblogs.com/luhuan/p/9072820.html">Windows下配置Git多账号github码云</a></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Plugin version (1.4.32) is not the same as library version (1.4.10) 警告的解决办法]]></title>
        <id>https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/</id>
        <link href="https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/">
        </link>
        <updated>2021-06-24T15:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在开发<code>Kotlin</code>项目的过程中，使用<code>kotlin-stdlib</code>标准库时，遇到了如下警告提示：</p>
<pre><code class="language-java">Plugin version(1.4.32) is not the same as library version(1.4.10)
</code></pre>
<p>提示的大致意思是说我们的插件版本和依赖库的版本不一致，原因是因为一些第三方的Library库所依赖的版本比较低，而我们在项目中所指定的依赖版本比较高，从而导致AndroidStudio给我们提出了警示。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p><strong>直接在module的build.gradle中删除依赖即可解决问题</strong></p>
<pre><code class="language-java">// 删除moudle-build.gralde文件中的该段
implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
</code></pre>
<p>详情请移步官网查看官方声明的这篇文章：<a href="https://kotlinlang.org/docs/whatsnew14.html#dependency-on-the-standard-library-added-by-default">What's new in Kotlin 1.4</a><br>
<img src="https://jgduan.github.io//post-images/1624550094222.png" alt="" loading="lazy"></p>
<p>图中的意思是：</p>
<blockquote>
<p>Kotlin默认添加了stdlib的依赖，您不再需要stdlib在任何 Kotlin Gradle 项目（包括多平台项目）中声明对库的依赖。默认情况下添加依赖项。</p>
</blockquote>
<blockquote>
<p>自动添加的标准库将是 Kotlin Gradle 插件的相同版本，因为它们具有相同的版本。</p>
</blockquote>
<blockquote>
<p>对于特定于平台的源集，使用库的相应特定于平台的变体，同时将公共标准库添加到其余部分。Kotlin Gradle 插件将根据您的 Gradle 构建脚本的kotlinOptions.jvmTarget 编译器选项选择合适的 JVM 标准库。</p>
</blockquote>
<p>上面所说的Kotlin插件，是指Project根目录下的build.gradle文件中的Kotlin插件，具体如下图所示：<br>
<img src="https://jgduan.github.io//post-images/1624550446644.png" alt="" loading="lazy"></p>
<p>这样一来，让人糟心的警告就不见了。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Handler】This Handler class should be static or leaks might occur (anonymous android.os.Handler)]]></title>
        <id>https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/</id>
        <link href="https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/">
        </link>
        <updated>2021-06-20T15:12:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Android开发者在日常开发过程中，经常会使用到<code>Handler</code>用来接收消息进行后续处理，然而当我们在<code>Handler#handleMessage(Message msg)</code>方法中做UI相关操作时，AndroidStudio就会报出如下警告：</p>
<pre><code class="language-java">This Handler class should be static or leaks might occur (anonymous android.os.Handler)
Inspection info:Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected.
If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue.
If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows:
   1. Declare the Handler as a static class;
   2. In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler;
   3. Make all references to members of the outer class using the WeakReference object.
</code></pre>
<p>警告内容是提示我们在内部类<code>Handler#handleMessage(Message msg)</code>方法中处理UI相关操作时，可能会造成内存泄漏风险，同时在警告内容中，指导给开发者相应的解决方案——内部类Handler静态化、使用弱引用<code>WeakReference</code>来进行抑制处理、访问所有的外部成员通过<code>WeakReference</code>引用对象来进行访问。</p>
<blockquote>
<p>除此之外，我们还可以在Activity被销毁时通过<code>Handler#removeCallbacksAndMessages(Object token)</code>方法来销毁对应<code>Handler</code>所有的消息队列。</p>
</blockquote>
<hr>
<h1 id="主动创造一个引起内存泄漏的handler">主动创造一个引起内存泄漏的Handler</h1>
<p>这里我们通过创造一个有内存泄漏风险的<code>Handler</code>通过不断切换<code>Activity</code>横竖屏来进行测试，看是否会引发内存泄漏，示例如下：</p>
<pre><code class="language-java">// HandlerTestActivity.java
public class HandlerTestActivity extends AppCompatActivity {
 
    // 创建匿名Handler内部类的对象
    private Handler leakHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };
 
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_handler_test);
 
        leakHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                Logger.d(&quot;leakHandler 延迟执行,内存泄露测试&quot;);
            }
        }, 5 * 60 * 1000);
    }
}
</code></pre>
<p>通过多次运行分析后，我们发现：应用内存占用出现了明显了升高;</p>
<p><strong>简单描述下原因:</strong><br>
由于上面的<code>Handler</code>内部类定义在<code>UI</code>线程中,因此使用的主线程的<code>Looper</code>和 <code>MessageQueue</code>;<br>
<code>MessageQueue</code>中的<code>Message</code>会持有<code>Handler</code>对象;<br>
匿名<code>Handler</code>内部类对象持有着外部<code>Activity</code>的强引用;<br>
以上三点导致当有<code>Message</code>未被处理之前, 外部类<code>Activity</code>会一直被强引用,导致即使发生了销毁,也无法被GC回收;</p>
<p>因此处理方法通常有两种:</p>
<p>在外部类<code>Activity</code>销毁时取消所有的<code>Message</code>,即 <code>leakHandler.removeCallbacksAndMessages(null)</code>;<br>
让内部类不要持有外部<code>Activity</code>的强引用;<br>
<code>AndroidStudio</code>给出的提示方案属于第二种。</p>
<blockquote>
<p>我们通过smali源码来一步步探究验证下;<br>
<a href="https://blog.csdn.net/weixin_33923762/article/details/91430429">[smali] This Handler class should be static or leaks might occur</a></p>
</blockquote>
<hr>
<h1 id="弱引用的handler">弱引用的Handler</h1>
<p>因大家在项目中可能存在多出使用<code>Handler</code>，我们可以封装一个公共的<code>WeakHandler</code>类，抽取公共方法供其它使用区域在此基础上继承实现，实现后的代码如下：</p>
<pre><code class="language-java">public class WeakHandler&lt;T extends Activity&gt; extends Handler {
    private final WeakReference&lt;T&gt; mWkActivity;

    public WeakHandler(T activity) {
        mWkActivity = new WeakReference&lt;&gt;(activity);
    }

    public T getActivity() {
        return mWkActivity.get();
    }

//    @Override
//    public void handleMessage(Message msg) {
//        super.handleMessage(msg);
//        T targetAct = mWkActivity.get();
//        // 通过`WeakReference`对象去操作外部`Activity`属性和事件
//        if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
////           targetAct.对象
//        }
//    }

}
</code></pre>
<p>那么在其它地方我们可以通过继承<code>WeakHandler</code>类的方式来实现弱引用的<code>Handler</code>，示例如下：</p>
<pre><code class="language-java">SimpleWeakHandler simpleWeakHandler = new SimpleWeakHandler(SimpleActivity.this);
    private static class SimpleWeakHandler extends WeakHandler&lt;SimpleActivity&gt; {

        public SimpleWeakHandler(SimpleActivity activity) {
            super(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            SimpleActivity targetAct = getActivity();
            if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
                targetAct.tvTitle.setText(&quot;SimpleWeakHandler&quot;);
            }
        }
    }
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【合肥】Android 15k+招聘列表]]></title>
        <id>https://jgduan.github.io/post/he-fei-android-15kzhao-pin-lie-biao/</id>
        <link href="https://jgduan.github.io/post/he-fei-android-15kzhao-pin-lie-biao/">
        </link>
        <updated>2021-06-03T14:58:17.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>企业名称</th>
<th>规模</th>
<th>薪资范围</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.zhipin.com/job_detail/d9520547f8e6810d1nZy3tq9EFdX.html?ka=search_list_jname_8_blank&amp;lid=7e4TsFRJ8rx.search.8&amp;securityId=0MTB9UTp35FML-l1tN71WWrZdpvDkTdQdp0jtNzeS5lcmAtQ8wv1VdQLP3YVyd5Xy3UBVVzjpwpYlY0x9STelScv443n1JGi0G7yWuffajDwOKpI">声智科技</a></td>
<td>100-499人</td>
<td>14-24K·14薪</td>
<td>B轮，BLE优先，注册2000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/74de27973b151e941nZ73dy9ElVQ.html?ka=search_list_jname_3_blank&amp;lid=7e4TsFRJ8rx.search.3&amp;securityId=HfXkRdJw7U651-R1vFwoW-XeqQl5ZoKj1anZnXOqGs60SC1EfasnQnIdIK3EnyhoJ2o1rNlqN9owlPzRsX2wuv-8Ancc2PlIkCqosrsj8puBDtHIvDD0">星河智联</a></td>
<td>100-499人</td>
<td>15-30K·14薪</td>
<td>讯飞+广汽，注册8500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/0d3783ca84c5f16b1nZ73dy9ElJX.html?ka=search_list_jname_71_blank&amp;lid=7e4TsFRJ8rx.search.71&amp;securityId=qdLjqsTw-P7Vu-H1m690t_zxqjhl400DMnDG082DGT-6d006_5a_3fgfMWzNxlvJFSP0vQKe9t-OE4sjYhi1sySlW3TR6R6ml4H6QS2m8jK2VR5fpZPd">星河智联</a></td>
<td>100-499人</td>
<td>16-27K·15薪</td>
<td>4年SDK经验，注册8500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/50f7f60b0a9068d41nV-3ti4FVZS.html?ka=search_list_jname_6_blank&amp;lid=7e4TsFRJ8rx.search.6&amp;securityId=G2WqzXeq8ogk--g1SGrF1nc1V_3PLxRAoYreJU8V-d7AqMY17YqztlCLMUSOZe9eCXs3WTem1LMiAObfsJehCPy6BvPDrTUVQyQM1xxQL8Ul9jBGbw%7E%7E">至博光电</a></td>
<td>20-99人</td>
<td>18-28K·14薪</td>
<td>注册9900万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/49ecb91030fa20e91XVy29S5EFA~.html?ka=search_list_jname_9_blank&amp;lid=7e4TsFRJ8rx.search.9&amp;securityId=eWosVjUVb3HS8-11jIVSN4J16MYm_8CuV__TbocyKiLQxONVmiwuQoiv93OY4U3Jf7D9eSiKwUAyFyZreQbCjhUT29wss61jXiZpxFpTeKx7YFQJ">ZOOM</a></td>
<td>500-999人</td>
<td>12-23K·14薪</td>
<td>已上市，注册730w美元</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/a4d1bf001f7554841nd62tW5E1BW.html?ka=search_list_jname_13_blank&amp;lid=7e4TsFRJ8rx.search.13&amp;securityId=Ofye-K8cl5Mr7-n1spJMDl6QcFkPzBstSB0fn-6nRjeY06nK399YAc--VLHkq3iS0fJKKp_PAG-QupbUsSbxKq8bU59b5iUgvOHg2iqZadmlGmlM">爱点击</a></td>
<td>1000-9999人</td>
<td>15-30K·14薪</td>
<td>注册26900万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/034df4a46d925f801nZz0tu9ElpT.html?ka=search_list_jname_16_blank&amp;lid=7e4TsFRJ8rx.search.16&amp;securityId=a53zI2spdrmlz-B1qslaixw2qt05RR0t8TJgaCw9GGekrRovpiiCEyfnVkNNRnodHLSqZh82KRTcQg6RdmfdusG8FL0Zh9wQtKnkU9lErdkNwvhvXQ%7E%7E">深圳优仕康</a></td>
<td>20-99人</td>
<td>12-24K</td>
<td>独立开发，注册1000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/cefdcaa23625427e33x83Nm_FVE~.html?ka=search_list_jname_17_blank&amp;lid=7e4TsFRJ8rx.search.17&amp;securityId=Cf_9WxXyCOAI5-F1d0cV5Jj3sG8CShCZPtbm32ZUFfG0VtoJYNicvVgv4P-ZG-V9NIZ6Il3orBtjiRGJs62pzajXzOQbWn_UEk5Z7nnLWu7u4ZTG">米娱科技</a></td>
<td>100-499人</td>
<td>12-22K·14薪</td>
<td>注册500万人民币</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/7b8fab8a3f28be1433Ny2d29FVA~.html?ka=search_list_jname_52_blank&amp;lid=7e4TsFRJ8rx.search.52&amp;securityId=yXTSOx7BEdbnS-R1rBucgK20hxY-5uH6Vq4elL65HxvmkHs7WVYxsdoVI4Amst7jCZ1hNhG0AUjJwaiXRZweQUs0sYJu3PUCaGfl7zCDz0scu5bt">米娱科技</a></td>
<td>100-499人</td>
<td>15-25K·14薪</td>
<td>独立开发要求，注册500万人民币</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/3b9003a1a5de83fa1nZ939u8EldU.html?ka=search_list_jname_18_blank&amp;lid=7e4TsFRJ8rx.search.18&amp;securityId=CudY8Fq5WN8e9-a1JkTZp7BZLnF2DGymHrDuxAYGp1nhzrhr6X1TjUdWDhzTcUGWqBSU1PujSTOjpJdOUi3kuqwsGLVKyPCgwP5oUUk3RSYgKeTNVD0%7E">中科数盾</a></td>
<td>100-499人</td>
<td>20-30K·14薪</td>
<td>Android Leader岗，注册2200万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/25f432e3e85bfcd11nRy2tu5GVdT.html?ka=search_list_jname_19_blank&amp;lid=7e4TsFRJ8rx.search.19&amp;securityId=LtF76yyJ_924q-a1BFRtZ61eZYx4n6MgLi17RXcX4jUO2WH0GNO8gWFkPzq6eQQ9vN0mrJB5CFiaU4ks5twx6rQ4oTe4_v6OE8_h75ko_oZbmL_KaXg%7E">徽娱传媒</a></td>
<td>20-99人</td>
<td>12-22K·14薪</td>
<td>注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/ff34bebf7c8627291nd43dq5FltS.html?ka=search_list_jname_21_blank&amp;lid=7e4TsFRJ8rx.search.21&amp;securityId=_Sf8VeIr-oMZQ-p1g-lg_6TMKseg2RKl602khYJHQVj8VO1SJzCZQ8eQOuUel2E6waM9ydSDjtuqxSorCC_gJKswb-MKsRJDm-Kuu98mELqALCM69V0%7E">的卢深视</a></td>
<td>100-499人</td>
<td>14-28K·15薪</td>
<td>Android平台算法SDK，注册595万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/3060c00d3a1713203nJ92Ni4Flc~.html?ka=search_list_jname_24_blank&amp;lid=7e4TsFRJ8rx.search.24&amp;securityId=uZFPD8cGA1FgP-41owavIWLodXP6ho090YOYEFq104bQfmE7C-LL3ZeZmuFRGmzO2ddwIrowMt37bMlBk5JAEJcWx8O4FbXl-HGUZjLg7ikWme6A">瀚茗斯</a></td>
<td>20-99人</td>
<td>14-28K</td>
<td>Android Leader岗，注册1000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/291d91989aaa84b51nZ-2tS4FlNT.html?ka=search_list_jname_25_blank&amp;lid=7e4TsFRJ8rx.search.25&amp;securityId=IczMxAR1txtjz-v1NacOcigcr-f00fD-68Ziy6wJiEtXyPlKADl7rVKxNNQVd2Qxw0UnvT3-YTA26CGrVJgkhbd0pJBBY5ggZ4LiBDkOBGeQYY0O4dk%7E">屯大软件</a></td>
<td>20-99人</td>
<td>15-23K</td>
<td>可能是外包，注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/d293564f07f222c51nB83ty8ElBY.html?ka=search_list_jname_51_blank&amp;lid=7e4TsFRJ8rx.search.51&amp;securityId=LlQ9wQKZ_pZL3-o1b29PKzxqdFmiAcb6LV8xQErkKfDFgRqtZmLvCJoMIGrZIfi9o_Aq-7Dh3AO-reG8eROmJYM3YWQ8szVjctV0YaiGa_7uRKbo">科大讯飞</a></td>
<td>10000人以上</td>
<td>15-25K·14薪</td>
<td>RN/Flutter优先，注册222473万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/eac33ac5cf350d521nBz3d2_FFBU.html?ka=search_list_jname_66_blank&amp;lid=7e4TsFRJ8rx.search.66&amp;securityId=w3fBWRwbCVmPx-E1jyrIoTX7l-ZnfrtoRp-vgH_fi0Vg6BaFpyGWTD2iph1hYmlneBDJjAKkh9P2BkhnAEwyEMe7K_eNFwwCQyXVGnELtOStkMI%7E">科大讯飞</a></td>
<td>10000人以上</td>
<td>13-23K·14薪</td>
<td>注册222473万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/b1e62a6936767a641nZ_09m-FlpT.html?ka=comp_joblist_1">江湖科技</a></td>
<td>20-99人</td>
<td>15-20K</td>
<td>Flutter，注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/b2214314e8c5bc131nZz29q4EFBW.html?ka=job_recommend_1">一视科技</a></td>
<td>20-99人</td>
<td>15-25K·14薪</td>
<td>注册500万</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>持续维护中。。。</p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Activity面试题进阶]]></title>
        <id>https://jgduan.github.io/post/android-activity-mian-shi-ti-jin-jie/</id>
        <link href="https://jgduan.github.io/post/android-activity-mian-shi-ti-jin-jie/">
        </link>
        <updated>2021-05-25T15:10:29.000Z</updated>
        <content type="html"><![CDATA[<h1 id="1-有两个activity-a和activity-b在activity-a中打开activity-b时它们都会有哪些生命周期回调">1. 有两个Activity A和Activity B，在Activity A中打开Activity B时，它们都会有哪些生命周期回调？</h1>
<ul>
<li>当被启动的目标<code>launchMode</code>为默认<code>standard</code>的情况下，在Activity A中打开Activity B时，生命周期回调顺序为：<br>
A.onPause()-&gt;B.onCreate()-&gt;B.onStart()-&gt;B.onResume()-&gt;A.onStop()；</li>
<li>当被启动的目标<code>launchMode</code>为<code>singleTop</code>且目标在栈顶的情况下，生命周期回调顺序为：<br>
B.onPause()-&gt;B.onNewIntent()-&gt;B.onResume()；</li>
<li>当被启动的目标<code>launchMode</code>为<code>singleInstance、singleTask</code>的情况下且对应的目标Activity有可复用的实例时，生命周期回调顺序为：`A.onPause()-&gt;B.onNewIntent()-&gt;B.onRestart()-&gt;B.onStart()-&gt;B.onResume()-&gt;A.onStop()-&gt;A.onDestory()（A被移出栈时调用）。</li>
</ul>
<hr>
<h1 id="2在activity中弹出dialog会对其生命周期造成什么影响">2.在Activity中弹出Dialog会对其生命周期造成什么影响？</h1>
<ul>
<li>如果启动的是常规的<code>Dialog</code><br>
因生命周期的回调都是<code>AMS</code>通过<code>Binder</code>通知应用进程的，而弹出<code>Dialog、Toast、PopupWindow</code>本质上都是通过<code>WindowsManager.addView()</code>显示的，并没有经过<code>ActivityManagerService</code>，所以不会对<code>Activity</code>的生命周期产生影响。</li>
<li>如果启动的是<code>Theme为Dialog的Activity</code><br>
会对<code>Activity</code>的生命周期造成影响，会触发如下生命周期回调（原<code>Activity</code>为A，弹出来的<code>DialogActivity</code>为B）：<br>
A.onPause()-&gt;B.onCreate()-&gt;B.onStart()-&gt;B.onResume()。</li>
</ul>
<blockquote>
<p>注：这个相对于上面的<code>Activity</code>互相之间的启动，你会发现，<strong>原<code>Activity</code>并没有触发<code>onStop</code>回调</strong>，这是因为<code>Activity</code>只有切换到后台不可见时才会触发<code>onStop</code>回调方法，而当弹出一个<code>Theme为Dialog的Activity</code>时，此前的一个页面还处于可见的情况，只是失去了焦点，所以仅回调了<code>onPause</code>方法。</p>
</blockquote>
<hr>
<h1 id="3为什么activity在onresume之后才显示">3.为什么Activity在onResume之后才显示？</h1>
<p>我们的Activity一般是在onCreate方法中通过setContentView来进行设置，那么为什么Activity要在onResume之后才显示呢？这中间经历了什么？</p>
<p>当我们在onCreate中通过setContentView方法设置布局时，实际上是直接调用了Window的setContentView，创建了一个DecorView用来包裹我们的布局：</p>
<pre><code class="language-java">PhoneWindow.java
public void setContentView(int layoutResID) {
    if (mContentParent == null) {
        installDecor();
    } 
    ...
    // 加载布局，添加到 mContentParent
    // mContentParent 又是 DecorView 的一个子布局  
    mLayoutInflater.inflate(layoutResID, mContentParent);
}
</code></pre>
<p>其实这一步只是加载好了布局，生成了一个ViewTree，具体怎么把ViewTree显示出来，答案就在下面：</p>
<pre><code class="language-java">ActivityThread.java
public void handleResumeActivity(...){
    // onResume 回调
    ActivityClientRecord r = performResumeActivity(...)
    final Activity a = r.activity;
    if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) {
        r.window = r.activity.getWindow();
        View decor = r.window.getDecorView();
        ViewManager wm = a.getWindowManager();
        wm.addView(decor, l);// 重点
    }
}
</code></pre>
<p>WindowManager的addView方法最终将DecorView添加到WMS，实现绘制到屏幕、接触触摸事件，具体调用如下：</p>
<pre><code class="language-java">   WindowManagerImpl.addView
-&gt; WindowManagerGlobal.addView
-&gt; ViewRootImpl.setView     
-&gt; ViewRootImpl.requestLayout() // 执行 View 的绘制流程
   // 通过 Binder 调用 WMS ，WMS 会添加一个 Window 相关的对象
   // 应用端通过 mWindowSession 调用 WMS
   // WMS 通过 mWindow (一个 Binder 对象) 调用应用端  
   mWindowSession.addToDisplay(mWindow) 
</code></pre>
<p>综上，在 onResume 回调之后，会创建一个 ViewRootImpl ，有了它之后应用端就可以和 WMS 进行双向调用了。</p>
<hr>
<h1 id="4onactivityresult在哪两个生命线周期之间回调">4.onActivityResult在哪两个生命线周期之间回调</h1>
<p><code>onActivityResult</code>不属于Activity的生命周期组成，<code>onActivityResult</code>该方法的源码注释中写到<code>You will receive this call immediately before onResume() when your activity is re-starting.</code>，跟一下代码（<code>TransactionExecutor.execute</code>有兴趣的可以自己打断点跟一下），会发现<code>onActivityResult</code>回调先于该<code>Activity</code>的所有生命周期回调，从B Activity到A Activity的生命周期回调为：<br>
B.onPause()-&gt;A.onActivityResult()-&gt;A.onRestart()-&gt;A.onStart()-&gt;A.onResume()。</p>
<hr>
<h1 id="5oncreate方法里面写死循环会触发anr吗">5.onCreate方法里面写死循环会触发ANR吗？</h1>
<p>不会触发，因为Activity的生命周期中写死循环，只要不进行其它操作，不满足触发ANR的条件。</p>
<blockquote>
<p>ANR产生的四种场景：<br>
1.Service TimeOut:  service 未在规定时间执行完成：前台服务 20s，后台 200s；<br>
2.BroadCastQueue TimeOut: 未在规定时间内未处理完广播：前台广播 10s 内, 后台 60s 内；<br>
3.ContentProvider TimeOut:  publish 在 10s 内没有完成；<br>
4.Input Dispatching timeout:  5s 内未响应键盘输入、触摸屏幕等事件。</p>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】一线面试题汇总]]></title>
        <id>https://jgduan.github.io/post/android-yi-xian-mian-shi-ti-hui-zong/</id>
        <link href="https://jgduan.github.io/post/android-yi-xian-mian-shi-ti-hui-zong/">
        </link>
        <updated>2021-05-19T14:19:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-基础系列">一、基础系列</h1>
<ol>
<li><strong>Activity的四种启动模式；</strong></li>
<li><strong>Activity生命周期中在onStart、onStop中做了什么；</strong></li>
<li><strong>为什么Activity之间传递对象需要序列化；</strong></li>
<li><strong>Http由哪些部分组成？Http与Https有什么区别；</strong></li>
<li><strong>请描述一个Http的请求过程；</strong></li>
<li><strong>用过哪些网络请求框架？okhttp如何复用连接？</strong></li>
<li><strong>什么是强引用、什么是弱引用，它们能干什么；</strong></li>
<li><strong>线程、线程池的概念描述；</strong></li>
<li><strong>动画有哪些种类？都适用于什么场景；</strong></li>
<li><strong>Android中的三级缓存是什么；</strong></li>
<li><strong>Sharepreferences的使用场景？能跨进程访问吗？工作原理是什么；</strong></li>
<li><strong>常用的数据库有哪些？如何进行升降级；</strong></li>
<li><strong>MVC、MVP、MVVM架构模式概念描述，常用哪个；</strong></li>
<li><strong>对Jetpack哪些组件比较了解？简单描述下其工作原理及适用场景；</strong></li>
<li><strong>简述Android的启动流程；</strong></li>
<li><strong>android:style与android:theme的区别是什么；</strong></li>
<li><strong>请简述Intent概念（含Filter），Intent传递对象大小有限制吗、为什么；</strong></li>
<li><strong>请简述Service前后台服务及其使用场景，Android8.0+如何兼容；</strong></li>
<li><strong>BroadcastReceiver动、静态注册；</strong></li>
<li><strong>ContentProvider是什么，请介绍其使用场景；</strong></li>
<li><strong>Java与Kotlin有什么区别？优缺点；</strong></li>
<li><strong>View的绘制流程是什么样的？如果屏幕方向发生改变会影响到什么；</strong></li>
<li><strong>请简述事件分发机制；</strong></li>
<li><strong>View与ViewGroup的关系描述；</strong></li>
<li><strong>你是如何做屏幕适配的（sw策略）；</strong></li>
<li><strong>Window、View、Activity之间的关系；</strong></li>
<li><strong>介绍下Handler的原理；</strong></li>
<li><strong>性能优化有哪些方式。</strong></li>
</ol>
<hr>
<h1 id="二-进阶系列">二、进阶系列</h1>
<ol>
<li><strong>WindowManagerService简述及其作用；</strong></li>
<li><strong>ActivityManagerService简述及其作用；</strong></li>
<li><strong>ConstraintLayout为什么效果好？为什么多了层级，性能可能会差很多；</strong></li>
<li><strong>什么是ANR？如何避免；</strong></li>
<li><strong>如何防止内存泄漏、OOM；</strong></li>
<li><strong>如何降低App异常崩溃提高稳定性；</strong></li>
<li><strong>什么是IPC？IPC有哪些实现方式；</strong></li>
<li><strong>内存优化工具LeakCanary和MAT的原理是什么；</strong></li>
<li><strong>什么是JVM，简述下内存模型；</strong></li>
<li><strong>Java为什么能够跨平台；</strong></li>
<li><strong>Java类文件的编译过程；</strong></li>
<li><strong>什么是组件化？你在项目中是如何实现组件化的？功能模块之间的相互引用如何处理、会有哪些问题；</strong></li>
<li><strong>Java同步机制有哪些，volatile和syncronized区别；</strong></li>
<li><strong>HashMap和HashTable区别；</strong></li>
<li><strong>List、ArrayList、LinkedList之间的关系、区别；</strong></li>
<li><strong>简述下PackageManagerService的工作流程；</strong></li>
<li><strong>Android是如何加载so文件的；</strong></li>
<li><strong>请介绍下Binder的原理及流程；</strong></li>
<li><strong>Java同步机制有哪些；</strong></li>
<li><strong>Recycleview如何做到回收复用的。</strong></li>
</ol>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【蓝牙】干货！一文看懂蓝牙Mesh技术]]></title>
        <id>https://jgduan.github.io/post/lan-ya-gan-huo-yi-wen-kan-dong-lan-ya-mesh-ji-zhu/</id>
        <link href="https://jgduan.github.io/post/lan-ya-gan-huo-yi-wen-kan-dong-lan-ya-mesh-ji-zhu/">
        </link>
        <updated>2021-05-10T14:58:18.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>内容来自 ：新电子<br>
转载自 半导体行业观察-<a href="http://www.semiinsights.com/s/electronic_components/23/35018.shtml">一文看懂蓝牙Mesh技术</a><br>
转载请注明来源和出处</p>
</blockquote>
<hr>
<h1 id="导读">导读</h1>
<p>对蓝牙技术而言，Mesh规格的制定，象征着形态的转变，而其影响层面之庞大，也让它成为一项典范转移。</p>
<p>蓝牙从2000年推出以来即积极追求成长，初衷只是希望取代有线技术，但旋即成为无线音讯与电脑周边产品的重要标准，例如无线滑鼠和键盘。</p>
<p>2010年，低功耗蓝牙的诞生让蓝牙技术又向前迈进一大步。其影响力既深且广，应用范围涵盖智能型手机和平板、医疗和健身、智能家庭，以及穿戴式装置市场。以Mesh网络拓扑建立的无线通讯系统，已证实能够有效提供大范围的涵盖率，不仅能延伸涵盖范围，而且相当稳定可靠。然而，在此之前这类网络都是建构在特殊技术之上，无法与大多数消费者的电脑、智能型手机与周边配件相容，亦不适用于企业端。</p>
<p>此次蓝牙Mesh技术规格的制定是120家蓝牙技术联盟企业会员共同努力的成果，远远超越了一般正常的规模，也因此才能满足全球对于蓝牙网状网络产业标准的要求。对蓝牙技术而言，Mesh规格的制定，象征着型态的转变，而其影响层面之庞大，也让它成为一项典范转移。本文章共分上下篇，上篇叙述蓝牙Mesh应用与特点，下篇则描述蓝牙Mesh技术与设计架构。</p>
<hr>
<h1 id="蓝牙mesh实现智能建筑">蓝牙Mesh实现智能建筑</h1>
<p>想像一下，在一个天还未亮的冬日清晨，您开车去上班，经过公司保全系统之后，系统自动分配一个车位给您(图1)。车位上方的编号自动亮起，引导您轻松将车停好。接着，车位分配系统立即将这个车位标记为已占用。<br>
<img src="https://jgduan.github.io//post-images/1620658887742.png" alt="图1 蓝牙Mesh网状网络涵盖整个办公室和停车场" loading="lazy"></p>
<p>走进大楼，人员感应器侦测到您的存在，立即透过您的穿戴式装置辨认您的身分。您走进电梯，搭到二楼，然后走出电梯。一如往常，您又是第一个进办公室。当电梯门开启，从电梯口到您办公室及厨房的沿路，灯光自动亮起，咖啡是您公司不可或缺的要素，为了节能，其他区域依然保持在黑暗中。</p>
<p>您走进办公室，身后的门自动关上。天花板及您桌上的台灯都已经为您开启，并且调整在您觉得最舒适的亮度。您注意到室内的温度似乎比整个办公室稍微温暖一点，这正好是您个人最爱的温度。您一坐下，您的电脑就自动将您登入。</p>
<p>您的一天就此顺利展开，大楼自动回应了您的需求，甚至贴心地配合您的喜好。所有系统都很有效率地运作，而这一切是如何办到的？</p>
<p>几个月前，公司安装了一套蓝牙<strong>Mesh网状网络，一开始先安装的是Mesh照明系统</strong>；<em><strong>后来人员感应器、环境感应器、无线暖气空调及停车管理系统也陆续加入Mesh网络当中</strong></em>。公司因此省下了不少的电费和暖气费，而且工作环境也变得更有人性，大幅提升了个人的工作效率。不仅如此，维护成本也因而降低，因为公司再也不必为了增加新的照明开关而大费周章地布线，既省下昂贵的成本，又不会干扰正常营运。</p>
<p>与此同时，大楼管理团队也能透过各种资料来了解整个大楼及各项服务的状况，同时掌握人们的使用情况，然后再利用这些资料将系统调整至最佳状况。</p>
<p>蓝牙Mesh网状网络让您轻松、经济地掌握整栋建筑的各项服务，并透过无线方式来操控并设定自动化行为。回想起来，您还真不知道以前没有这套先进系统时是怎么过活的。</p>
<hr>
<h1 id="蓝牙mesh技术基本概念">蓝牙Mesh技术基本概念</h1>
<p>要了解蓝牙Mesh网状网络拓扑，首先要先对一些蓝牙以外的最新科技名词和概念有所认识。本章节将介绍一些最基本的名词和概念。</p>
<ul>
<li>
<p><strong>「网状网络」与「点对点」</strong><br>
大多数的低功耗蓝牙装置都是经由简单的「点对点」网络拓扑来和其他装置通讯(一对一通讯)，在蓝牙的核心规格当中，这样的网络称为「Piconet」微微网。</p>
<p>想像一支智能型手机和一台心率监视器之间建立了点对点连线，并将资料传输到手机上。蓝牙有一项不错的特性就是装置可以建立多个连线，因此这支智能型手机还可和另一个活动纪录器建立点对点连线。尽管这支智能型手机可以同时和两个外部装置直接通讯，但外部装置彼此之间却无法直接通讯。</p>
<p>反观网状网络则是一种「多对多」的网络拓扑(图2)，网状网络中的每个装置都能与其他任一装置通讯，这一点会在后续的文章当中详细说明。装置之间通讯的方式是透过讯息，而且每一装置都可以转发讯息，因此从两端的通讯距离可以超越个别节点无线射频功率所及的范围。<br>
<img src="https://jgduan.github.io//post-images/1620659033651.png" alt="图2 采用讯息转发架构的多对多网络拓扑" loading="lazy"></p>
</li>
<li>
<p><strong>装置与节点</strong><br>
网状网络中的每一个装置就是一个节点，而尚未加入的装置则称为「未启动配置装置」(Unprovisioned Device)。因此，一个未启动配置装置转变成网络节点的过程就叫做「启动配置」(Provisioning)。想像一个情境，使用者新买了一个支援蓝牙Mesh技术的灯具带回家安装，而为了将它加入蓝牙Mesh网络，必须先启动配置灯具以便能够透过现有的蓝牙照明开关或调光器来操作。</p>
<p>启动配置是一个安全的程序，经过此一程序，未启动配置的装置会获得一连串的加密金钥，并且向「启动配置器」(Provisioner)装置(通常是平板或智能型手机)注册，其中一把金钥是「网络金钥」，简称NetKey。</p>
<p>Mesh网络中的所有节点至少都会有一把网络金钥，也正因为拥有此一金钥，装置才可算是该网络的成员，并称为一个节点。不过，节点在能发挥作用之前，还要满足几项条件；首先最基本的就是透过一个安全的配置程序取得一把网络金钥。</p>
</li>
<li>
<p><strong>元素</strong><br>
有些节点会有多个组成单元，每一个单元都能够独立被操控。在蓝牙Mesh技术的术语中，这些组成单元叫做「元素」(Element)。图3显示一个LED灯具，当它加入蓝牙Mesh网状网络时，会变成一个拥有三个元素的单一节点，每一元素则分别对应至不同的LED灯。<br>
<img src="https://jgduan.github.io//post-images/1620659097338.png" alt="图3 包含三个「元素」的照明节点" loading="lazy"></p>
</li>
<li>
<p><strong>讯息</strong><br>
当一节点须要查询其他节点的状态，或者操控其他节点时，就要传送某种类型的讯息；若节点需要向其他节点通报自己的状态，也是藉由发送讯息通报。</p>
<p>网状网络中的所有通讯都是透过「讯息」来达成，蓝牙Mesh技术已定义了许多讯息类型，每一类都有自己独特的代码(Opcode)。</p>
<p>讯息主要分成两大类：「须确认」(Acknowledged)和「不须确认」(Unacknowledged)两种。须确认讯息的接收端节点必须做出回应，回应有两项目的：第一，确认讯息已收到；第二，将接收端的资料传回发送端。</p>
<p>须确认讯息的发送端若未收到预期的回应，可重新发送讯息，因此须确认讯息必须具备等幂(Idempotent)特质。换句话说，当某个节点收到多次相同的须确认讯息，效果和收到一次是一样的，不须确认讯息则不须回应。</p>
</li>
<li>
<p><strong>位址</strong><br>
讯息的传递必须从某一位址到另一位址，蓝牙Mesh技术定义了三种位址。单点传播(Unicast)位址用来对应单一元素定址，在配置程序中，单点传播位址会被指派至装置。</p>
<p>群组位址是一种群播(Multicast)位址，可用来对应一个或多个元素定址。群组位址可由蓝牙技术联盟定义或动态指派，前者就是所谓的「SIG固定群组位址」(SIG Fixed Group Addresses)。目前共定义了四个SIG固定群组位址，包括All-proxies、All-friends、All-relays及All-nodes。本文后续会对代理(Proxy)、好友(Friend)和转发(Relay)等名词的意义做进一步解释。</p>
<p>动态群组位址的用意是要让使用者透过一个组态设定程式，建立并对应一栋建筑的实体组态。</p>
<p>例如，建筑中的每一个房间都有对应的群组位址，虚拟位址则用来对应一个或多个元素定址的位址，并可涵盖多个节点。其格式是一个128位元的通用唯一识别码(UUID)，可对应任何元素，就如同标签的作用。</p>
</li>
<li>
<p><strong>发布 / 订阅</strong><br>
「发布」就是传送讯息的动作，而设定让节点从特定位址接收某些讯息的动作，就是「订阅」。一般来说，讯息会发送至群组位址或虚拟位址。群组和虚拟位址的名称，通常会让使用者一看就知道用意，因此在使用上既方便又直觉。</p>
<p>如图4，我们看到「开关1」节点会发布讯息到「厨房」群组位址。「灯泡1」、「灯泡2」、「灯泡3」这三个节点，则订阅了「厨房」这个位址， 因此会接收及处理发布至该位址的讯息。换句话说，「灯泡1」、「灯泡2」和「灯泡3」即可透过「开关1」来操控。<br>
<img src="https://jgduan.github.io//post-images/1620659214851.png" alt="图4 发布/订阅情境示意图" loading="lazy"></p>
<p>「开关2」会发布讯息到「餐厅」这个位址。而图中只有「灯泡3」订阅了该位址的讯息，因此「开关2」只能控制此一灯泡。请特别留意，此范例也示范了节点可订阅不只一个位址的讯息，这样的设计既强大又弹性。</p>
<p>同样地，请特别留意「开关5」和「开关6」两个节点皆可发布讯息至「花园」这个位址。采用群组和虚拟位址并搭配「发布/订阅」的通讯机制的另一绝佳优点，就是当网络中移除、更换或新增节点时，不须重新设定其他节点。</p>
<p>想像一下，如果餐厅需要新增安装一盏灯会需要哪些流程。首先，新的装置必须经过配置程序加入网络，并且设定订阅「餐厅」的位址讯息；而其他的节点完全不会因改变而受到影响。「开关2」就像之前一样，依然将讯息发布至「餐厅」，但现在「灯泡3」，以及新的灯泡都会做出回应。</p>
</li>
<li>
<p><strong>状态与属性</strong><br>
元素可以有多种状态，在蓝牙Mesh技术当中，这样的概念是透过状态值来表示。「状态」为一元素当中某种类型的数值(请参阅文后的「伺服器」模型章节)。除了数值以外，状态还有一些对应的行为，且无法重复应用在其他情境。</p>
<p>例如一颗简单的灯泡，其状态不是「开」就是「关」。蓝牙Mesh技术定义了一个叫做「通用开关」(Generic OnOff) 的状态。灯泡即含有这样的状态，因此，数值「On」对应的就是灯泡开启的状态，或者让灯泡点亮。</p>
<p>反观一个数值为「Off」的Generic OnOff状态，对应的就是灯泡关闭的状态，或者让灯泡熄灭。</p>
<p>稍后我们会再谈到Generic通用定义的重要性。属性与状态一样，都含有关于某元素的数值，这方面两者类似，但在其他方面却截然不同。对于熟悉低功耗蓝牙的读者可能会联想到特性(Characteristic)，这是一种没有对应行为定义的资料类型，因此可应用至各种不同情境，属性提供解读某个特性的情境。</p>
<p>为了示范情境对于属性的重要性及使用方式，本文举「Temperature 8」为例，这是一个8位元的温度状态类型，并且有一些对应的属性，包括当前室内周遭温度(Present Indoor Ambient Temperature)与当前室外周遭温度(Present Outdoor Ambient Temperature)。</p>
<p>这两个属性可让感应器发布感应器读值，供接收讯息的装置可以根据温度的情境，更正确地解读温度数值。属性主要分成两大类：制造商(Manufacturer)属性是一种唯读属性，系统管理员(Admin)属性则是读写两用属性。</p>
</li>
<li>
<p><strong>讯息/状态/属性</strong><br>
讯息是用来触发Mesh网络装置运作的机制。形式上，讯息类型代表着一种针对个别或一群状态数值的操作。所有讯息都可归为三大类型，各自反映蓝牙Mesh技术所支援的操作类型，这三大类分别为，读取(GET)、设定(SET)和状态(STATUS)。</p>
<p>读取讯息用以取得一个或多个节点的状态数值。状态讯息则是用来回应读取讯息，内含对应状态的数值。设定讯息用来改变某状态的数值。须确认的设定讯息最后会产生一个状态讯息，以回应设定讯息；不须确认的设定讯息则不须回应。状态讯息则用来回应读取讯息、须确认的设定讯息，或者单独使用无关的其他讯息，例如某个元素上的计时器所触发的状态讯息。</p>
<p>讯息所参照到的个别状态，必须从讯息的代码导出其意义；属性则不然，在通用属性相关讯息当中，它是直接以一个16位元属性识别码(ID)来表示。</p>
</li>
<li>
<p><strong>状态转换</strong><br>
从某一状态变成另一个状态就叫做「状态转换」。状态转换可以是瞬间的，或者持续一段时间才完成，这段时间就叫做「转换时间」。状态的转换很可能会对节点在应用层的行为产生影响。</p>
</li>
<li>
<p><strong>状态绑定</strong><br>
状态之间彼此可能会存在着某种关系，因此改变一个状态，可能会连带影响另一个状态。这样的关系就是「状态绑定」(State Binding)。一个状态可以跟其他多个状态绑定。例如某个透过调光器控制的灯泡有两个状态：通用开关通用高低(Generic Level)，彼此互相关联。假使将亮度调整至通用高低的数值「零」(也就是全暗状态)，就会使得通用开关的状态从「On」转换至「Off」。</p>
</li>
<li>
<p><strong>模型</strong><br>
模型则将前面所介绍的概念都集合起来，用来定义一个元素在网状网络当中的部分或所有功能，模型基本上分成三种。</p>
<p>第一种是「伺服器」模型，此模型定义了一些状态、状态转换、状态绑定，以及包含此模型的元素可能发送或接收的讯息。此外，伺服器模型也定义了讯息、状态、状态转换对应的行为。</p>
<p>第二种是「用户端」模型，此模型未定义任状态，但定义了其可能发送或接收的讯息，以便「读取」、「设定」状态或接收其对应伺服器模型中所定义的「状态」讯息。第三种是「控制」模型，此模型同时结合了「伺服器」模型(可与其他用户端模型通讯)以及「用户端」模型(可与伺服器模型通讯)。</p>
<p>当然，也可以透过延伸其他模型来建立模型，未延伸过的模型称为根模型(Root Model)。模型一旦定义就永远不能改变，换句话说，不能透过新增或移除行为来改变模型，要满足新的需求，唯一正确且允许的方式就是延伸既有的模型。</p>
</li>
<li>
<p><strong>Generic通用定义</strong><br>
有许多不同类型的装置，其基本上都有一些意义相同的状态。最简单的就是「开」和「关」两种状态，例如灯泡、风扇、插座，全部都可切换成「开」或「关」。</p>
<p>因此，蓝牙Mesh模型规格定义了一系列可重复使用且通用的状态，例如通用开关和通用高低。同样地，也定义了一系列作用于通用状态的通用讯息，例如：通用开关读取「Generic OnOff Get」和通用高低设定「Generic Level Set」。</p>
<p>通用状态和通用讯息基本上用于通用模型，例如：通用伺服器模型「Generic OnOff Server」和通用用户端模型「Generic Level Client」(图5)。这些通用定义可以让许多类型的装置不须自行建立模型就能轻松支援蓝牙Mesh技术，也可以藉由延伸其他模型来建立模型，因此，当有新型的装置须要支援时，就延伸通用模型来快速建立模型。<br>
<img src="https://jgduan.github.io//post-images/1620659427559.png" alt="图5 Generic模型" loading="lazy"></p>
</li>
<li>
<p><strong>场景</strong><br>
所谓「场景」(Scene)是指一组状态，可在接收到某种类型的讯息，或者在指定的时间内套用成当下的状态。场景是以一个在网状Mesh中独一无二的16位元场景编号(Scene Number)表示。</p>
<p>有了场景，就能统一地将一群节点设定成先前储存且互相搭配的状态。想像一下当夜晚来临，您可能希望家中的客厅温度维持在摄氏20度左右，并将天花板上的六颗LED灯泡维持在特定亮度，房间角落桌上的台灯设定成舒适温暖的黄色。当将各装置都手动设定成想要的状态，就能透过一个设定应用程式将这些状态储存成场景，等未来有需要时即可发送一个场景Mesh讯息，或者在排定的时间，自动将这组设定调出来套用。</p>
</li>
<li>
<p><strong>启动配置</strong><br>
「启动配置」是让装置加入网状网络成为其中一个节点的程序，过程包含了好几个阶段，并且会产生好几把安全金钥，而启动配置本身也是一个安全的程序。启动配置需要透过装置(如平板)上的应用程式来完成，此时装置的角色是引导整个启动配置程序的进行，因此称为「启动配置器」(Provisioner)。</p>
<p>启动配置程序共有五个步骤，以下分别详细说明：</p>
<ul>
<li>
<p>发出讯号<br>
为了支援各种不同的蓝牙Mesh功能，包括但不限于配置程序，蓝牙在规格中导入了一些新的GAP广播类型，其中之一就是「Mesh Beacon」广播类型。<br>
一个未配置的装置需在广播封包(Advertising Packet)当中使用「Mesh Beacon」广播类型，以让网络知道它的存在。使用者可能需要让新的装置启动并进入此状态来发送广播封包，例如同时按下某几个按钮，或者按住某个按钮一段时间。</p>
</li>
<li>
<p>邀请<br>
当进入此步骤时，启动配置器会发送一个邀请给配置中的装置，也就是「Provisioning Invite PDU」。接着，在前一步骤当中发出讯号的装置要透过一个「Provisioning Capabilities PDU」来回应一些有关于自己的资讯。</p>
</li>
<li>
<p>交换公开金钥<br>
接下来，启动配置器及启动配置中的装置要互相交换公开金钥，此金钥可以是永久或临时的，交换方式可以是直接交换或透过频外(OOB)方式。</p>
</li>
<li>
<p>认证<br>
在认证步骤中，启动配置中的装置需根据自身的能力，透过某种方式发送一个随机的个位数或多位数号码给使用者。例如，启动装置可以让某个LED闪几下。此时，使用者要在启动配置器上输入装置所发送的号码，两个装置之间会利用此随机号码进行一连串的加密资料交换，借此认证对方的装置。</p>
</li>
<li>
<p>发送启动配置资料<br>
当认证成功之后，双方装置都会利用自己的私密金钥加上对方提供的公开金钥，来产生一个连线阶段金钥(Session Key)。这个连线阶段金钥将用来保护后续配置程序所需发送的资料，如前面提过的NetKey网络金钥。<br>
当启动配置程序完成后，已启动配置的装置就会拥有网状网络的网络金钥、一个称为「IV Index」的Mesh安全性参数，以及一个启动配置器配发的单点传送位址(Unicast Address)，至此，装置就正式成为一个节点。</p>
</li>
</ul>
</li>
<li>
<p><strong>选择性功能</strong><br>
所有节点都能发送及接收网状网络讯息，但节点还可能有一些选择性的特殊功能。目前有四种选择性功能：转发(Relay)、代理(Proxy)、好友(Friend)以及低功耗(Low Power)；一个节点可以自行决定是否支援，或支援多个选择性功能，此外，任何选择性功能都可以随时启用或停用。</p>
</li>
<li>
<p><strong>转发(Relay)节点</strong><br>
凡是支援「转发」功能的节点即可称为转发节点，这类节点可将其收到的讯息再传送出去。透过转发的机制，讯息就能穿越整个网状网络，沿途经过多次转跳(Hop)。</p>
<p>Mesh网络的协议资料单元(PDU)当中包含了一个栏位叫做TTL(Time To Live)存活时间。这是一个整数值，用来限制讯息在网络中的转跳次数。比方说，如果将TTL设成「3」，那讯息在途中最多能转发三次。</p>
<p>假使将它设为「0」，那讯息就无法转发，必须直接传送至目的地。Mesh网络中的节点只要稍微了解拓扑的组态，以及网络上有那些成员，就能利用TTL栏位来提升网状网络的使用效率。</p>
</li>
<li>
<p><strong>低功耗(Low Power)节点与好友(Friend)节点</strong><br>
某些类型的节点供电能力有限，因此必须尽可能节省电力。此外，这类装置可能绝大部分时间都在传送讯息，但偶尔还是需要接收一些讯息。</p>
<p>以温度感应器为例，它很可能透过一颗小小的钮扣型电池来供电。当温度超过或低于某个预先设定的上、下门槛值时，就会每分钟传送一次温度计读值。假使温度维持在上、下门槛值之间，那它就不会发出讯息。这样的运作方式不难达成，而且不须消耗太多电力。</p>
<p>但问题是，使用者有时必须传送讯息给感应器来设定新的门槛值。这种情况虽不多，但感应器必须能够支援。然而，接收讯息的需求会增加装置的负荷，进而消耗电力，如果装置随时处于待命状态，就可不漏接任何温度门槛的设定讯息，但却将因此消耗大量电力；若装置处于低度待命状态，固然可以节省电力，但却可能让感应器漏接一些设定讯息。</p>
<p>要解决这样的困境，答案就在「好友」节点以及「友谊」的概念，以前述温度感应器为例，我们可将感应器设定成「低功耗节点」(LPN)，这一点可透过在感应器的设定资料中加入一个功能旗标来达成。</p>
<p>LPN需要另一个节点的配合才能运作，一个没有供电能力限制的节点(例如随时连接着插座的节点)，此节点就是所谓的「好友」节点。好友节点负责帮忙储存发送给LPN的讯息，而LPN再透过轮巡(Poll)的方式向好友节点查询是否有「等待接收的讯息」。</p>
<p>只要LPN向好友节点轮巡的频率不要太高，就能兼顾省电与适时接收讯息的需求。每当LPN向好友节点轮巡的时候，好友节点就会将其储存的所有讯息，逐一传送给LPN，并且透过一个MD(More Data)旗标来让LPN知道好友节点还有更多的讯息待传。</p>
<p>LPN与好友节点之间的关系称为「友谊」(Friendship)。对于电力相当有限却又必须接收讯息的节点来说，友谊的概念非常重要，如此才能让它在蓝牙Mesh网状网络当中持续保持运作，却又能够发挥能源效率。</p>
</li>
<li>
<p><strong>代理(Proxy)节点</strong><br>
全世界支援低功耗蓝牙的装置数量非常庞大，大多数的智能型手机及平板即是一例。</p>
<p>然而，当蓝牙Mesh网络正式获得采纳时，市场上的蓝牙装置并不具备蓝牙Mesh技术。不过它们却能支援低功耗蓝牙，因此可透过GATT(Generic Attribute Profile)通用属性设定档与其他装置连接并互动。</p>
<p>「代理」(Pxoxy)节点的作用即在此，这类节点会提供一个GATT介面让低功耗蓝牙装置与Mesh网络互动。蓝牙定义了一套「Proxy Protocol」的通讯协定，以供连线导向的载体(Bearer)装置(如GATT)使用；GATT装置会从Proxy节点以GATT特性(Characteristic)读取和写入Proxy Protocol PDU ，Proxy节点会将这些PDU转换成Mesh PDU，反之亦然(图6)。<br>
<img src="https://jgduan.github.io//post-images/1620659868882.png" alt="图6 智能型手机经由Mesh代理节点进行通讯，P=代理功能开启。" loading="lazy"><br>
简而言之，Proxy节点可让不具备蓝牙Mesh技术的低功耗蓝牙装置能与Mesh网状网络中的节点互动。</p>
</li>
<li>
<p><strong>节点组态</strong><br>
每个节点皆支援一套标准的组态状态，会在组态伺服器模型(Configuration Server Model)当中执行，并且透过组态用户端模型(Configuration Client Model)来存取。组态状态资料关乎到节点在Mesh网状网络内的能力和行为，但与个别应用或装置类型的行为无关。</p>
<p>举例来说，一个节点所支援的功能，不论是否为代理节点、转发节点等，都是透过组态伺服器状态来标示。一个节点所订阅的位址，会储存在Subion List订阅清单当中，网络和子网络金钥会标示节点所属的网络，并列在组态区块(Configuration Block)当中，节点所持有的应用金钥亦然。蓝牙Mesh网络定义一系列的组态讯息，以供组态用户端模型和组态伺服器模型，能够在组态伺服器模型的状态下执行读取、设定和状态等操作。</p>
</li>
</ul>
<hr>
<h1 id="蓝牙mesh网状网络架构解析">蓝牙Mesh网状网络架构解析</h1>
<p>本节将深入介绍蓝牙Mesh网状网络的架构及其各个层次与负责的作用。此外也将说明Mesh架构(图1)与低功耗蓝牙核心架构之间的关系。</p>
<p>在Mesh网状网络架构的最底层称为「低功耗蓝牙」。然而，事实上这并不单纯只是Mesh架构的其中一层，而是指整个低功耗蓝牙技术，如此一来才能提供基础的无线通讯能力，让在这之上的Mesh架构能够运作。</p>
<p>显然地，蓝牙Mesh系统必须要有低功耗蓝牙技术存在的状况下才能运作。接下来我们将从最底层开始，逐一说明Mesh架构的每一层。</p>
<ul>
<li>
<p><strong>载体层</strong><br>
Mesh网络的讯息需要一套通讯系统负责传送和接收。这就是「载体层」(Bearer Layer)的作用，该层定义通讯系统该如何处理Mesh PDU。目前蓝牙Mesh技术只定义两个载体，分别为广播载体(Advertising Bearer)与GATT载体(GATT Bearer)。</p>
<p>广播载体会利用低功耗蓝牙的GAP广播与扫描功能来发送和接收Mesh PDU。GATT载体则可让不支援广播载体的装置，经由前述的「Proxy Protocol」通讯协定与Mesh网状网络内支援广播载体的节点间接通讯。</p>
<p>Proxy Protocol是封装在GATT运作中，藉由特别定义的GATT特性来达成。Mesh网络的代理节点会执行GATT特性并支援GATT载体与广播载体，因此能在两种载体之间转换并转发讯息。</p>
</li>
<li>
<p><strong>网络层</strong><br>
「网络层」(Network Layer)定义了各种讯息位址类型以及网络讯息格式，让载体层可以传送传输层PDU。该层可支援多个载体，每一载体各有多个网络介面，包括可让同一节点内的多个元素彼此沟通的本地端介面。</p>
<p>网络层会判断讯息该经由哪一网络介面输出。来自载体层的讯息会经过一个输入过滤条器(Input Filter)，以决定是否要将讯息传送至网络层作进一步处理。同样地，输出讯息也会经过一个输出过滤器(Output Filter)来决定是否该抛弃讯息或者传送至载体层。至于转发(Relay)和代理(Proxy)的功能则是可以经由网络层来执行。</p>
</li>
<li>
<p><strong>下层传输层</strong><br>
「下层传输层」(Lower Transport Layer)会从上层传输层接收PDU，之后将PDU传送到另一装置的下层传输层；必要时，该层也会进行PDU的切割与重组。当PDU较长而无法塞入单一Transport PDU时，下层传输层就会加以切割，将该PDU分成多个Transport PDU。接收端装置的下层传输层，则会将这些分割过的PDU重组成单一的上层传输层PDU，并且往上一层传送。</p>
</li>
<li>
<p><strong>上层传输层</strong><br>
「上层传输层」(Upper Transport Layer)负责将来自存取层以及要传给存取层的应用资料进行加密、解密与认证。此外，该层也负责处理讯息的传输与控制，讯息由各节点的上层传输层内部产生，并彼此互相传递，包括「友谊」(Friendship)和「心跳」(Heartbeat)相关的讯息。</p>
</li>
<li>
<p><strong>存取层</strong><br>
「存取层」(Access Layer)负责定义各种应用该如何存取上层传输层，包括：<br>
．定义应用资料格式。<br>
．定义及控制上层传输层所负责执行的加密、解密流程。<br>
．确认从上层传输层所收到的资料是否送到正确网络，才将资料往上一层传。</p>
</li>
<li>
<p><strong>基础模型层</strong><br>
「基础模型层」(Foundation Models Layer)负责执行与Mesh网状网络组态及管理相关的模型。</p>
</li>
<li>
<p><strong>模型层</strong><br>
「模型层」(Models Layer)负责依照模型的规格定义，执行模型以及相关的行为、讯息、状态、状态绑定等等。</p>
</li>
<li>
<p><strong>Mesh网状网络安全采强制规定</strong><br>
低功耗蓝牙提供了多种安全机制让设定档的设计者选择，如不同的配对方式，或每一特性对应的个别安全要求等等。但事实上，安全性完全是一项选择性功能，因此也可以造出完全没有任何安全防护或限制的开放式装置。</p>
<p>装置设计者或制造商必须自行分析其面临的威胁，然后决定其产品的安全性需求与解决方案(图2)。然而，对于蓝牙Mesh网状网络来说，安全性是强制的。不论是网络本身，或是个别应用和装置，全都有安全机制保护，而且无法透过任何方式加以关闭或削弱。</p>
</li>
<li>
<p><strong>Mesh网状网络安全基本原则</strong><br>
蓝牙Mesh网状网络具备以下基本安全原则：<br>
．所有Mesh讯息皆经过加密和认证。<br>
．网络安全、应用安全与装置安全，各自独立分开。<br>
．安全金钥在Mesh网状网络中的生命周期可透过「金钥更新」(Key Refresh)程序来变更。<br>
．讯息标头编码让网络内传递的讯息难以被追踪，提供了私密性机制让节点无法被追踪。<br>
．蓝牙Mesh的安全机制可防范网络遭到回放攻击(Replay Attack)。<br>
．装置新增至Mesh网络以成为节点的程序具安全性。<br>
．节点可安全地从网络移除，并且可防范垃圾桶(Trashcan)攻击。</p>
</li>
<li>
<p><strong>依不同安全考量进行隔离</strong><br>
蓝牙Mesh安全机制的核心是由三种金钥所构成的。这些金钥分别保护着Mesh网状网络的不同部分，将不同的安全考量分离。</p>
<p>为了解这样的设计并体会其重要性，我们来看一个可作为转发节点的Mesh灯泡案例。当灯泡扮演转发的角色时，它可能会经手Mesh网络上一些有关大楼门禁系统的讯息。然而，一个灯泡不该有权限读取并处理这类讯息的内容，但却必须将讯息转发给其他节点。</p>
<p>为解决这样的冲突，蓝牙Mesh技术采用了不同的安全金钥，分别保护讯息在网络层的传输与应用(如照明、保全、暖气等等)相关的资料。</p>
<p>所有Mesh网络当中的节点都有一把网络金钥(NetKey)。事实上，正是因为持有共同的金钥，节点才能成为该网络的成员。这把网络金钥还可衍生出网络加密金钥，以及一把私密金钥。</p>
<p>节点持有的网络金钥，最高仅能解开并验证到网络层的通讯，因此节点能够转发讯息，但无法解开应用相关资料。网络或许还会进一步分隔成多个子网络(Subnet)，而且每个子网络都有专属的网络金钥，唯有子网络内的成员才拥有。网络金钥可以用来隔离实体空间，例如饭店内的每一间客房。</p>
<p>要解开特定应用相关的资料，节点必须拥有对应的应用金钥(AppKey)。在Mesh网络的所有节点之中，可能存在着许多不同的应用金钥，但通常每个应用金钥只会被少数的节点所持有，即为能够参与该项应用的节点类型。举例而言，灯泡和照明开关，会拥有照明应用的应用金钥，但是却不会拥有暖气系统的应用金钥；后者通常是温度控制开关、散热器控制阀等节点才有。</p>
<p>上层传输层会使用应用金钥来加密及验证讯息，而后才将讯息传给存取层，多把应用金钥会对应到一把网络金钥。</p>
<p>这样的关系称之为「金钥绑定」，代表着一些特定的应用必须持有应用金钥，而且只能在某个特定网络上运作，但是一个网络却能容纳多个互相独立而安全的应用。</p>
<p>最后一把金钥是装置金钥(DevKey)，为一种特别的应用金钥。每个节点都有独一无二的装置金钥，且唯有启动配置器装置才知道。装置金钥用于启动配置程序之中，负责保障启动配置器与节点之间的通讯安全。</p>
</li>
<li>
<p><strong>移除节点/启动金钥提升安全性</strong><br>
如前所述，节点持有多种Mesh的安全金钥。假设节点发生故障而必须拆除，或者持有者决定将它卖给他人，很重要的一件事就是要确保该装置不被拿来攻击其原本所属的网络。</p>
<p>为此，蓝牙Mesh技术定义了一套移除网络节点的程序。使用者可利用启动配置器的应用程式，而将某个节点列入黑名单，并启动「金钥更新」的程序。</p>
<p>金钥更新程序会使得网络上的所有节点(除了黑名单中的节点之外)收到新的网络金钥、应用金钥以及所有相关的衍生资料。换句话说，负责保障网络和应用安全的整套安全金钥全部都会换掉。如此一来，移除节点所持有的网络金钥和应用金钥都变得无效，该节点将不再是网络的成员，因此就不会构成威胁。</p>
</li>
<li>
<p><strong>私密性</strong><br>
从网络金钥衍生而来的私密金钥，是用来编码网络PDU的标头(Header)资料，例如来源位址。编码可确保窃听者无法轻易追踪装置及装置使用者的行踪。此外，也让一些根据流量分析的攻击难以达成。这项技巧的安全程度也确实符合其用途。</p>
</li>
<li>
<p><strong>回放攻击</strong><br>
在网络安全的领域中，「回放攻击」(Replay Attack)是指窃听者从网络上拦截、撷取到一个或多个讯息，并将该讯息重新传送一次，目的是希望欺骗接收端执行一些攻击端装置没有权限执行的动作。常见的例子是汽车免钥匙系统，骇客藉由撷取车主与车辆之间的认证程序讯息，并对免钥匙系统回放这些讯息，就能打开车门，将车偷走。</p>
<p>蓝牙Mesh网状网络便内建了防范回放攻击的机制。基本上是利用两个网络PDU栏位：Sequence Number(SEQ)和IV Index。</p>
<p>元素在每次发布讯息时，就会将SEQ数值加一。当节点收到来自某个元素的讯息时，其SEQ值若小于或等于上一个有效讯息的SEQ，那么该讯息将被抛弃，因为这很可能就是来自回放攻击。</p>
<p>至于IV Index则是另一个栏位，用来搭配SEQ。来自同一元素的讯息，其内含的IV Index必定等于或大于来自该元素上一个有效讯息的数值。</p>
</li>
<li>
<p><strong>蓝牙Mesh技术采管理式网络泛洪机制</strong><br>
Wi-Fi网络是围绕着一个中央节点(也就是路由器)来运作，所有网络流量都会经过此处，万一路由器故障，整个网络就跟着停摆。</p>
<p>反观蓝牙Mesh网络采用的是「管理式网络泛洪机制」的讯息传送技巧。所有讯息一旦由节点发布之后，就会广播到网络上，而非透过路由方式传送至一个或多个特定节点。</p>
<p>所有在无线射频可达范围内的节点都会收到讯息，并可转发所收到的讯息(如果有设定的话)。所谓转发，就是将收到的讯息再广播一次，以让距离原发送节点较远的节点能够接收到讯息。</p>
<p>除此之外，蓝牙技术采用管理式网络泛洪的另一个重要意义就是，讯息可经由网络内的多重路径到达目的地。如此可形成一个非常稳定可靠的网络，而这也是为何当初蓝牙Mesh网状网络的设计会选择采用洪水式的传递方法，而非采用路由的方式。</p>
</li>
<li>
<p><strong>管理式网络泛洪机制特点</strong><br>
蓝牙Mesh网状网络善用了洪水式方法的优点，并且加以优化，因此能够兼具稳定性以及效率，同时也反映了「管理式网络泛洪机制」所代表的涵意。这些方法包括：</p>
<ul>
<li>心跳<br>
节点会定时发出「心跳」讯息，每一次的心跳讯息，都是告知网络内的其他节点，自己仍然在正常运作。此外，心跳讯息亦含有一些资料可让收到的节点判断发送端与自己距离，即是要经过几次转跳才会到达，这项情报就能够有效用在TTL栏位。</li>
<li>TTL<br>
TTL(Time To Live)存活时间是所有蓝牙Mesh PDU都拥有的栏位。此一栏位用来控制讯息转发过程中转跳的最大次数。藉由TTL的设定，节点就能够掌控讯息的转发，并且达到节能的效果，以避免讯息不会无意义地转发太多次。心跳讯息可以让节点判断每次发布讯息时TTL的最大设定值。</li>
<li>讯息快取(Message Cache)<br>
所有节点都必须执行讯息快取。包含节点最近收到的所有讯息，当节点收到一个讯息时，即可比对快取内是否有相同的讯息。若有，即代表该讯息已经接受并处理过，可以立即抛弃。</li>
<li>好友节点<br>
蓝牙Mesh网状网络中重要的最佳化机制为「好友」节点与「低功耗」节点的组合。如上所述，好友节点可提供讯息储存功能，并且将讯息转传给相关的低功耗节点。如此一来，低功耗节点就能发挥优异的能源效率。消息的内部传递当一节点接收到讯息时，会将讯息从架构最底下的低功耗蓝牙，一层一层往上传(从载体层到网络层)。接着，网络层会进行各项检查来决定是否将讯息传给上一层，或者直接抛弃。</li>
<li>消息的内部传递<br>
当一节点接收到讯息时，会将讯息从架构最底下的低功耗蓝牙，一层一层往上传(从载体层到网络层)。接着，网络层会进行各项检查来决定是否将讯息传给上一层，或者直接抛弃。</li>
</ul>
<p>此外，PDU当中有一个网络识别码(Network ID)栏位，可用来快速判断讯息使用的网络金钥。如果接收端的网络层无法辨识该网络金钥，就代表接收端装置不属于该网络的成员，而会将PDU抛弃。此外，还有一个网络讯息完整性检查(MIC) 栏位。节点会辨识PDU网络识别码对应的网络金钥，如果检查失败，讯息便会直接被抛弃。在发送端节点讯号范围内的所有节点都会收到发出的讯息，与收到装置不相干的讯息则会迅速被抛弃，例如来自不同的网络或子网络的讯息。</p>
<p>同样的原则在上层传输层也一样适用。不过，该层检查的是讯息的应用金钥，也就是PDU当中的应用识别码(AID)栏位。如果收到的节点无法辨识PDU中的应用识别码，上层传输层就会将PDU直接抛弃。此外，若是传输讯息的完整性检查(TransMIC)失败，讯息也会被抛弃。</p>
</li>
</ul>
<p>相信经过本文的介绍，读者应该已经对蓝牙Mesh技术以及其功能、概念与名词有了一些基本的认识。虽然蓝牙技术与我们所认识的有点不同，但却是一种能让装置透过全新拓扑彼此通讯的蓝牙技术；最重要的是，这项技术也让广泛应用的低功耗蓝牙无线技术能够开拓全新的领域与产业。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【蓝牙】经典蓝牙与BLE低功耗蓝牙]]></title>
        <id>https://jgduan.github.io/post/lan-ya-jing-dian-lan-ya-yu-ble-di-gong-hao-lan-ya/</id>
        <link href="https://jgduan.github.io/post/lan-ya-jing-dian-lan-ya-yu-ble-di-gong-hao-lan-ya/">
        </link>
        <updated>2021-05-10T14:07:01.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-蓝牙的概述">一、蓝牙的概述</h1>
<p>1999年蓝牙1.0发布，紧随其后的是蓝牙2.1。蓝牙2.1的版本使用最广，很多产品都是这个版本，也就是我们所谓的经典蓝牙，以前非智能手机也是支持这个版本的。到了蓝牙3.0，又名为高速蓝牙，在2.1的基础上大大提升了传输速度(24Mbps)。后面4.0 / 4.1引入了低功耗蓝牙。蓝牙5.0也已经发布。主要是在信号范围，连接速度，以及广播速度进行了优化，蓝牙5.0还对物联网方向做了单独的改进。</p>
<p><strong>一般一个蓝牙可以同时支持7个设备</strong>。相关拓展阅读<a href="https://blog.csdn.net/weixin_35011300/article/details/112137779">android 获取蓝牙已连接的设备_冷知识：一个蓝牙可同时连接多个蓝牙设备</a></p>
<ul>
<li>
<p><strong>蓝牙模块</strong><br>
是指集成蓝牙功能的芯片基本电路集合，用于短距离2.4G的无线通讯模块。对于最终用户来说，蓝牙模块是半成品，通过在模块的基础上功能再开发、封装外壳等工序，实现能够利用蓝牙通讯的最终产品。</p>
</li>
<li>
<p><strong>经典蓝牙</strong><br>
泛指支持蓝牙协议在4.0以下的模块，一般用于数据量比较大的传输，如：语音、音乐等较高数据量的传输。<br>
经典蓝牙模块又可细分为：<em><strong>传统蓝牙和高速蓝牙模块。</strong></em><br>
传统蓝牙模块在2004年推出，主要代表是支持蓝牙2.1协议的模块，在智能手机爆发的时期得到了广泛的使用。<br>
高速蓝牙模块在2009年推出，速率提高到约<strong>24Mbps</strong>，传输速率是经典蓝牙的八倍，可以轻松的应用于录像机到电视、PC到PMP、UMPC到打印机之间的资料传输。<br>
传统蓝牙有3个功率级别，Class1,Class2,Class3,分别支持100m,10m,1m的传输距离。</p>
</li>
<li>
<p><strong>BLE蓝牙</strong><br>
全称是<strong>Bluetooth Low Energy</strong>，简称BLE。是指支持蓝牙协议4.0或以上的模块，也被称为BLE模块，最大的特点就是成本和功耗的降低，可以应用于实时性要求较高的产品当中，比如：智能家居类（蓝牙锁、蓝牙灯）、传感设备的数据发送（血压计、温度传感器）、消费类电子（电子烟、遥控玩具）等。</p>
<p>蓝牙低功耗技术是低成本、短距离、可互操作的鲁棒性（是英文robustness一词的音译,也可意译为稳健性）无线技术，工作在<strong>免许可的2.4GHz ISM射频频段</strong>。因为BLE技术采用非常快速的连接方式，<strong>因此平时可以处于“非连接”状态（节省能源）</strong>，此时链路两端相互间只是知晓对方，只有在必要时才开启链路，然后在尽可能短的时间内关闭链路(<strong>每次最多传输20字节</strong>)。低功耗蓝牙无功率级别，一般发送功率在7dBm，一般在空旷距离，达到20m应该是没有问题。</p>
<p>低功耗蓝牙中则有一个主设备（Central）和从设备（Peripheral，也叫外围设备）的概念。主设备作为发现方，调用发现设备的方法，通过<code>BluetoothAdapter#startLeScan()</code>方法实现。从设备则作为被发现方，发出广播，以供发现。同样，这个<code>startLeScan()</code>方法也仅能够发现低功耗蓝牙从设备。</p>
</li>
<li>
<p><strong>经典蓝牙与低功耗蓝牙的区别</strong><br>
低功耗蓝牙和传统蓝牙其实是有很大的区别的，<strong>低功耗蓝牙是NOKIA的Wibree标准上发展起来的。</strong><br>
在功耗上，传统蓝牙有三个级别的功耗，class1、class2、class3分别支持100m、10m、1m的传输距离，一般要求至少使用两节3A电池。而且工作几天或者几周就没电了；低功耗蓝牙却没有功耗级别，一般发送功率在7dbm左右，一个纽扣电池就可以工作一两年，3A电池的电量一般是纽扣电池的10至12倍。<br>
BLE5.0模块可支持蓝牙<strong>Mesh技术</strong>——拓展阅读<a href="https://jgduan.github.io/post/lan-ya-gan-huo-yi-wen-kan-dong-lan-ya-mesh-ji-zhu/">【蓝牙】干货！一文看懂蓝牙Mesh技术</a>。</p>
<blockquote>
<p>正所谓有得必有失，低功耗带来的低传输速率，当然BLE被设计的本来就是传输少量数据的，对于很多传感器设备，例如心跳带，血压计等设备，是非常适合的。</p>
</blockquote>
<p><strong>传输数据长度的区别</strong>经典蓝牙一次最长可传输1500个字节，而BLE默认一次最多23个字节。</p>
<blockquote>
<p>因传统蓝牙实际上是通过Socket的方式进行通信，Socket的Send,Recv的长度问题：<br>
一个包没有固定长度，以太网限制在46－1500字节，1500就是以太网的MTU，超过这个量，TCP会为IP数据报设置偏移量进行分片传输，现在一般可允许应用层设置8k（NTFS系统）的缓冲区，8k的数据由底层分片，而应用层看来只是一次发送。<br>
windows的缓冲区经验值是4k。<br>
Socket本身分为两种，流(TCP)和数据报(UDP)，你的问题针对这两种不同使用而结论不一样。甚至还和你是用阻塞、还是非阻塞Socket来编程有关。<br>
1、通信长度，这个是你自己决定的，没有系统强迫你要发多大的包，实际应该根据需求和网络状况来决定。对于TCP，这个长度可以大点，但要知道，Socket内部默认的收发缓冲区大小大概是8K，你可以用SetSockOpt来改变。但对于UDP，就不要太大，一般在1024至10K。注意一点，你无论发多大的包，IP层和链路层都会把你的包进行分片发送，一般局域网就是1500左右，广域网就只有几十字节。分片后的包将经过不同的路由到达接收方，对于UDP而言，要是其中一个分片丢失，那么接收方的IP层将把整个发送包丢弃，这就形成丢包。显然，要是一个UDP发包佷大，它被分片后，链路层丢失分片的几率就佷大，你这个UDP包，就佷容易丢失，但是太小又影响效率。最好可以配置这个值，以根据不同的环境来调整到最佳状态。<br>
send()函数返回了实际发送的长度，在网络不断的情况下，它绝不会返回(发送失败的)错误，最多就是返回0。对于TCP你可以写一个循环发送。当send函数返回SOCKET_ERROR时，才标志着有错误。但对于UDP，你不要写循环发送，否则将给你的接收带来极大的麻烦。所以UDP需要用SetSockOpt来改变Socket内部Buffer的大小，以能容纳你的发包。明确一点，TCP作为流，发包是不会整包到达的，而是源源不断的到，那接收方就必须组包。而UDP作为消息或数据报，它一定是整包到达接收方。<br>
2、关于接收，一般的发包都有包边界，首要的就是你这个包的长度要让接收方知道，于是就有个包头信息，对于TCP，接收方先收这个包头信息，然后再收包数据。一次收齐整个包也可以，可要对结果是否收齐进行验证。这也就完成了组包过程。UDP，那你只能整包接收了。要是你提供的接收Buffer过小，TCP将返回实际接收的长度，余下的还可以收，而UDP不同的是，余下的数据被丢弃并返回WSAEMSGSIZE错误。注意TCP，要是你提供的Buffer佷大，那么可能收到的就是多个发包，你必须分离它们，还有就是当Buffer太小，而一次收不完Socket内部的数据，那么Socket接收事件(OnReceive)，可能不会再触发，使用事件方式进行接收时，密切注意这点。这些特性就是体现了流和数据包的区别。<br>
补充一点，接收BuffSize &gt;= 发送BuffSize &gt;= 实际发送Size，对于内外部的Buffer都适用，上面讲的主要是Socket内部的Buffer大小关系。<br>
3、TCP是有多少就收多少，如果没有当然阻塞Socket的recv就会等，直到有数据，非阻塞Socket不好等，而是返回WSAEWOULDBLOCK。UDP，如果没有数据，阻塞Socket就会等，非阻塞Socket也返回WSAEWOULDBLOCK。如果有数据，它是会等整个发包到齐，并接收到整个发包，才返回。</p>
</blockquote>
<p>关于传统蓝牙传统数据长度问题，可以参考以下文章：<br>
<a href="https://blog.csdn.net/jenus1/article/details/1738235">TCP/UDP 发送数据的数据长度单位</a><br>
<a href="https://www.cnblogs.com/bugutian/p/13025264.html?ivk_sa=1024320u">一个TCP报文最多传输多少字节(即MSS)</a></p>
</li>
<li>
<p><strong>BLE on Android</strong><br>
Android OS从4.3(<code>Jelly Bean</code>，API 18)才开始支持低功耗蓝牙，但是仅仅是支持中心（Central）模式——所谓的主设备，可以连接其他蓝牙外设。</p>
<p>直到2014.6.26 Android 5.0(<code>Lollipop</code>，API 21)的面世，才带来了周边API的支持(<code>BluetoothLeAdvertiser</code>)——即Android 5.0版本以后的手机可以作为一个外设（从设备，Peripheral，也叫外围设备）来进行发布。</p>
<p>Android SDK中BLE相关的API都在<code>android.bluetooth.*</code>下面，同时在Android 5.0也引入了一些也需要用到<code>android.bluetooth.le*</code>下面的API。另外，要在APP中使用蓝牙功能，需要在<code>AndroidManifest.xml</code>文件中配置申请蓝牙相关的权限声明。在Android 6.0 及以上平台中，还需要申请定位权限。</p>
</li>
</ul>
<hr>
<h1 id="二-经典蓝牙-传统蓝牙的工作流程">二、经典蓝牙、传统蓝牙的工作流程</h1>
<ol>
<li>
<p><strong>发现设备</strong></p>
<ul>
<li><strong>经典蓝牙</strong><br>
经典蓝牙设备发现其它经典蓝牙设备的方式是调用<code>BluetoothAdapter#startDiscovery()</code>方法。</li>
<li><strong>BLE蓝牙</strong><br>
通过<code>BluetoothAdapter#startLeScan()</code>方法去扫描发现设备。</li>
</ul>
<blockquote>
<p><code>BluetoothAdapter.startDiscovery</code>在大多数手机上是可以同时发现经典蓝牙和BLE的，但是<code>startDiscovery</code>的回调无法返回BLE的广播，所以无法通过广播识别设备，且<code>startDiscovery</code>扫描BLE的效率比<code>startLeScan</code>低很多。所以在实际应用中，还是<code>startDiscovery</code>和<code>startLeScan</code>分开扫，前者扫传统蓝牙，后者扫低功耗蓝牙。<br>
注意：当两种蓝牙设备被某设备（包括当前的设备）配对 / 绑定后，可能不会再被扫描到。</p>
</blockquote>
</li>
<li>
<p><strong>配对 / 绑定设备</strong><br>
不管是经典蓝牙还是低功耗蓝牙，绑定方法都是通用的，可以调用相同的绑定方法。<br>
关于配对与绑定的具体介绍，可以参考<a href="http://blog.chinaunix.net/uid-21411227-id-5833051.html"><strong>BLE 配对与绑定过程详细解析、蓝牙配对与绑定的过程</strong></a>。</p>
</li>
<li>
<p><strong>建立连接</strong></p>
<ul>
<li>
<p><strong>经典蓝牙</strong><br>
经典蓝牙建立连接的方式实际上就是<code>Socket</code>的连接的建立。只不过这里不是直接用<code>Socket</code>，而是<code>BluetoothSocket</code>。获取<code>BluetoothSocket</code>的方式也很简单，利用搜索找到的<code>BluetoothDevice</code>，调用其方法<code>createRfcommSocketToServiceRecord(UUID)</code>。最后，使用获取到的<code>BluetoothDevice</code>调用其方法<code>connect()</code>就建立了经典蓝牙设备之间的连接通道。</p>
</li>
<li>
<p><strong>BLE蓝牙</strong><br>
先通过<code>BluetoothAdapter</code>的<code>getRemoteDevice(address)</code>方法获取对应BLE从设备的<code>BluetoothDevice</code>，其中的address为目标蓝牙设备MAC地址；然后通过此<code>BluetoothDevice#connectGatt(this, false, mGattCallback)</code>方法获取设备连接。<br>
此时的连接，只能够进行监听，也就是获取到当前BLE从设备广播出来的数据。</p>
</li>
</ul>
<blockquote>
<p>在蓝牙设备中，存在着物理地址，我们也叫作蓝牙的MAC地址，这个地址是唯一的，就像咱们网络上的IP地址。同时还存在着一个叫做UUID的东西，可以把它理解为是IP地址中的端口号。<br>
正如知道了IP地址和端口号，就知道了怎么链接到目标网络服务器位置，知道了蓝牙设备的MAC地址和UUID也就能够确定到具体是哪一台蓝牙设备了，这两者合起来就是蓝牙的唯一身份标识。</p>
</blockquote>
</li>
<li>
<p><strong>数据通信</strong></p>
<ul>
<li>
<p><strong>经典蓝牙</strong><br>
当建立连接后，就可以直接使用<code>BluetoothSocket#getOutputStream()</code>方法获取输出流写入需要发送的数据。读取发送回来的数据，则是调用<code>BluetoothSocket#getInputStream()</code>方法获取输入流读取。<strong>这点和Java中的Socket通信几乎是一模一样</strong>。</p>
</li>
<li>
<p><strong>BLE蓝牙</strong><br>
想要实现主设备对从设备的数据发送，则需要直接读取获取到的从设备的<code>Characteristic</code>，而<code>Characteristic</code>又是<code>Service</code>下面的一层，所以操作顺序是：</p>
<p>1.通过BLE从设备相应的<code>Service_UUID</code>获取对应的<code>BluetoothGattService</code>，获取方法是：使用<code>BluetoothDevice的connectGatt(this, false, mGattCallback)</code>方法返回的<code>BluetoothGatt</code>对象，调用<code>BluetoothGatt的方法getService(Service_UUID)</code>获取相应的<code>BluetoothGattService</code>；</p>
<p>2.调用<code>BluetoothGattService</code>和对应的<code>Characteristic</code>的写入<code>UUID</code>获取相应的<code>BluetoothGattCharacteristic</code>，获取方法是：调用<code>BluetoothGattService</code>的<code>getCharacteristic(Characteristic_UUID)</code>方法获得；</p>
<p>3.设置需要发送的命令值，调用<code>BluetoothGattCharacteristic的方法setValue(value)进行设置</code>，<strong>其中value一般为byte[]</strong>；</p>
<p>4.最后，使用<code>BluetoothGatt</code>的写入方法<code>writeCharacteristic(TxChar)</code>完成命令发送。<br>
可以看到，想要实现BLE的数据通信，步骤相当繁琐，这里只是做一个简单的概念理解，<strong>如果想要获取到BLE从设备的返回值，还需要设置Notification</strong>，然后调用<code>BluetoothGatt的readCharacteristic(characteristic)方法</code>进行数据的读取。</p>
</li>
</ul>
<blockquote>
<p>两种蓝牙的流程<br>
发现设备-&gt;配对/绑定设备-&gt;建立连接-&gt;数据通信<br>
低功耗蓝牙设备版本要求<br>
当设备是目标连接设备时，Android版本最低为Android 4.3以上系统<br>
当设备是发起连接设备时，Android版本最低为Android 5.0以上系统</p>
</blockquote>
</li>
</ol>
<hr>
<h1 id="三-蓝牙的选用">三、蓝牙的选用</h1>
<p>既然有经典蓝牙和低功耗蓝牙之分，我们在设计物联网产品和智能硬件产品的时候，如何选择呢？</p>
<ul>
<li><strong>经典蓝牙</strong><br>
蓝牙最初的设计意图，是打电话放音乐。3.0版本以下的蓝牙，都称为“经典蓝牙”。<strong>功耗高、传输数据量大、传输距离只有10米。</strong></li>
<li><strong>BLE蓝牙</strong><br>
就是BLE，通常说的蓝牙4.0（及以上版本）。<strong>低功耗，数据量小，距离50米左右。</strong></li>
</ul>
<p><strong>传声音的，用经典蓝牙</strong>：如蓝牙耳机、蓝牙音箱。蓝牙设计的时候就是为了传声音的，所以是近距离的音频传输的不二选择。</p>
<p><strong>电池供电、连手机APP的，用BLE</strong>：如共享单车锁、蓝牙智能锁、蓝牙防丢器、蓝牙室内定位，是目前手机和智能硬件通信的性价比最高的手段。直线距离约50米，一节5号电池能用一年，传输模组成本10块钱，远比WIFI、4G等大数据量的通信协议更实用。</p>
<p><strong>又要声音又要数据的，用双模蓝牙</strong>：双模蓝牙，就是同时支持经典蓝牙音频和低功耗蓝牙。如智能电视遥控器、降噪耳机等。很多智能电视配的遥控器带有语音识别，需要用经典蓝牙才能传输声音。</p>
<p><strong>传大数据量的，用经典蓝牙</strong>：如某些工控场景，使用Android或Linux主控，外挂蓝牙遥控设备的，可以使用经典蓝牙里的SPP协议，当作一个无线串口使用。速度比BLE传输快多了。</p>
<p><strong>远距离的，不用蓝牙</strong>。固定供电的、不考虑功耗的、要传超过几十米距离的、要传高速数据的，这些都不适合蓝牙。远距离的可以用2G、4G、NB-IOT，大数据量的可以用WIFI。</p>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<ul>
<li><a href="https://www.jianshu.com/p/fc46c154eb77/">Android经典蓝牙开发简介</a></li>
<li><a href="https://www.jianshu.com/p/a27f3ca027e3">安卓BLE蓝牙开发详解</a></li>
<li><a href="https://www.jianshu.com/p/f98e77c9ec65">Android-BLE蓝牙原理</a></li>
<li><a href="https://blog.csdn.net/zqf_888/article/details/80982337">Android蓝牙开发—经典蓝牙和BLE（低功耗）蓝牙的区别</a></li>
<li><a href="https://blog.csdn.net/zqf_888/article/details/81196766?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.vipsorttest">Android蓝牙开发—BLE（低功耗）蓝牙详细开发流程</a></li>
</ul>
]]></content>
    </entry>
</feed>