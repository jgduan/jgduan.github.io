<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-07-06T15:15:39.690Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【转】Android Paint 画笔的一些偏知识]]></title>
        <id>https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/</id>
        <link href="https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/">
        </link>
        <updated>2021-07-06T15:02:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转载于 抛物线http://hencoder.com/ui-1-2/</p>
</blockquote>
<hr>
<h1 id="setstrokecappaintcap-cap-设置线头的形状">setStrokeCap(Paint.Cap cap) 设置线头的形状</h1>
<p>设置线头的形状。线头形状有三种：<code>BUTT</code> 平头、<code>ROUND</code> 圆头、<code>SQUARE</code> 方头。默认为 <code>BUTT</code>。</p>
<blockquote>
<p>放出「平头」「圆头」「方头」这种翻译我始终有点纠结：既觉得自己翻译得简洁清晰尽显机智，同时又担心用词会不会有点太过通俗，让人觉得我不够高贵冷艳？</p>
</blockquote>
<p>当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：<br>
<img src="https://jgduan.github.io//post-images/1625584089491.jpg" alt="" loading="lazy"></p>
<p>虚线是额外加的，虚线左边是线的实际长度，虚线右边是线头。有了虚线作为辅助，可以清楚地看出 <code>BUTT</code> 和 <code>SQUARE</code> 的区别。</p>
<hr>
<h1 id="setstrokejoinpaintjoin-join">setStrokeJoin(Paint.Join join)</h1>
<p>设置拐角的形状。有三个值可以选择：<code>MITER</code> 尖角、 <code>BEVEL</code> 平角和 <code>ROUND</code> 圆角。默认为 <code>MITER</code>。<br>
<img src="https://jgduan.github.io//post-images/1625584131677.jpg" alt="" loading="lazy"></p>
<p>辅助理解：<br>
<code>MITER</code> 在现实中其实就是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584155362.jpg" alt="" loading="lazy"></p>
<p>而 <code>BEVEL</code> 是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584171460.jpg" alt="" loading="lazy"></p>
<hr>
<h1 id="setstrokemiterfloat-miter">setStrokeMiter(float miter)</h1>
<p>这个方法是对于 <code>setStrokeJoin()</code> 的一个补充，它用于设置 <code>MITER</code> 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：<br>
当线条拐角为 <code>MITER</code> 时，拐角处的外缘需要使用延长线来补偿：<br>
<img src="https://jgduan.github.io//post-images/1625584210033.jpg" alt="" loading="lazy"></p>
<p>而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：<br>
<img src="https://jgduan.github.io//post-images/1625584221599.jpg" alt="" loading="lazy"></p>
<p>所以为了避免意料之外的过长的尖角出现， <code>MITER</code> 型连接点有一个额外的规则：当尖角过长时，自动改用 <code>BEVEL</code> 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 <code>BEVEL</code> 型连接点：<br>
<img src="https://jgduan.github.io//post-images/1625584236255.jpg" alt="" loading="lazy"></p>
<p>至于多尖的角属于过于尖，尖到需要转为使用 <code>BEVEL</code> 来绘制，则是由一个属性控制的，而这个属性就是 <code>setStrokeMiter(miter)</code>方法中的 <code>miter</code> 参数。<code>miter</code> 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：<br>
<img src="https://jgduan.github.io//post-images/1625584259127.jpg" alt="" loading="lazy"></p>
<p>用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1 / sin ( θ / 2 ) 。<br>
这个 <code>miter limit</code> 的默认值是 4，对应的是一个大约 29° 的锐角：<br>
<img src="https://jgduan.github.io//post-images/1625584364544.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」</p>
</blockquote>
<p>所以，这个方法虽然名叫 <code>setStrokeMiter(miter)</code> ，但它其实设置的是「 线条在 <code>Join</code> 类型为 <code>MITER</code> 时对于 <code>MITER</code> 的长度限制」。它的这个名字虽然短，但却存在一定的迷惑性，如果叫 <code>setStrokeJoinMiterLimit(limit)</code> 就更准确了。 Google 的工程师没有这么给它命名，大概也是不想伤害大家的手指吧，毕竟程序员何苦为难程序员。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】各大版本新特性及行为变更]]></title>
        <id>https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/</id>
        <link href="https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/">
        </link>
        <updated>2021-07-05T15:03:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><strong>Android 12.0开发者预览版</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/12/features?hl=zh_cn">概览 API 30</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all">Android 12.0影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12?hl=zh_cn">行为变更：以 Android 12 为目标平台的应用</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/foreground-services?hl=zh_cn">前台服务启动限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/non-sdk-12?hl=zh_cn">Android 12 中有关限制非 SDK 接口的更新</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features">Android 12 功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/work?hl=zh_cn">Android 12 中的企业功能新变化</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/migration?hl=zh_cn">将应用迁移到 Android 12</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/unified-content-api?hl=zh_cn">接收内容的统一 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/compatible-media-transcoding?hl=zh_cn">兼容的媒体转码</a></li>
</ul>
</li>
<li>
<p><strong>Android 11.0</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/11?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-all">影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-11">影响以 Android 11 为目标平台的应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/privacy">Android 11 隐私权变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/features">Android 11 功能和 API 30</a></li>
</ul>
</li>
<li>
<p><strong>Android 10.0(Q)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/10?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/migration?hl=zh_cn">将应用迁移至 Android 10</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/privacy?hl=zh_cn">隐私功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/behavior-changes-all?hl=zh_cn">行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/highlights?hl=zh_cn">新功能和 API 29</a></li>
<li><a href="https://blog.csdn.net/u011216417/article/details/89189741">Android10.0(Q)新特性和行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 9.0(P)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/pie?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0?hl=zh_cn">功能和API 28</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all?hl=zh_cn">针对所有应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-28?hl=zh_cn">针对API 28+应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-migration?hl=zh_cn">迁移至Android 9.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/power?hl=zh_cn">电源管理</a></li>
</ul>
</li>
<li>
<p><strong>Android 8.0(O)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/oreo?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0?hl=zh_cn">Android 8.0 功能和 API 26</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes?hl=zh_cn">Android 8.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-migration?hl=zh_cn">迁移到Android 8.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-samples?hl=zh_cn">Android 8.0示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background?hl=zh_cn">后台执行限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits?hl=zh_cn">后台位置信息限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.1?hl=zh_cn">Android 8.1 功能和 API 27</a></li>
</ul>
</li>
<li>
<p><strong>Android 7.0(N)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/nougat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0?hl=zh_cn">Android 7.0 开发者版本 API 24</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes?hl=zh_cn">Android 7.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-samples?hl=zh_cn">Android 7.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1?hl=zh_cn">Android 7.1 开发者版本 API 25</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1-samples?hl=zh_cn">Android 7.1 示例</a></li>
</ul>
</li>
<li>
<p><strong>Android 6.0(M)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0?hl=zh_cn">Android 6.0 API 23</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes?hl=zh_cn">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-samples?hl=zh_cn">Android 6.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-testing?hl=zh_cn">Android 6.0 测试指南</a></li>
</ul>
</li>
<li>
<p><strong>Android 5.0(L)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/lollipop?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.1?hl=zh_cn">Android 5.1 API 22</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0?hl=zh_cn">Android 5.0 API 21</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0-changes?hl=zh_cn">Android 5.0 行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 4.4(KitKat)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/kitkat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4?hl=zh_cn">Android 4.4 API 19</a></li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://developer.android.google.cn/about/versions?hl=zh_cn">所有Android版本</a></p>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】使用PermissionsDispatcher进行动态权限适配]]></title>
        <id>https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/</id>
        <link href="https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/">
        </link>
        <updated>2021-07-05T12:55:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-permissionsdispatcher简介">一、PermissionsDispatcher简介</h1>
<p>PermissionsDispatcher provides a simple annotation-based API to handle runtime permissions.<br>
<code>PermissionsDispatcher</code>提供了一个简单的基于注解的 API 来处理运行时权限。</p>
<p>This library lifts the burden that comes with writing a bunch of check statements whether a permission has been granted or not from you, in order to keep your code clean and safe.<br>
该库减轻了编写一堆检查语句所带来的负担，无论是否已授予您许可，以保持您的代码清洁和安全。</p>
<ul>
<li>
<p><strong>Fully Kotlin/Java support - 完全支持Kotlin/Java</strong></p>
</li>
<li>
<p><strong><a href="https://github.com/hotchemi/PermissionsDispatcher/blob/master/doc/special_permissions.md">Special permissions support - 特殊权限支持</a></strong></p>
</li>
<li>
<p><strong>100% reflection-free - 100%无反射</strong></p>
</li>
</ul>
<p>本文基于<code>PermissionsDispatcher 4.8.0及 permissionsdispatcher-ktx 1.0.5</code>版本，我们将介绍Kotlin的ktx使用方式，如过需要使用Kotlin kapt或Java使用方式的，请移步<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">Github-PermissionsDispatcher</a></p>
<blockquote>
<p><code>permissionsdispatcher-ktx</code><br>
<code>permissionsdispatcher-ktx</code>旨在让开发人员在不使用注释处理（kapt）的情况下以声明式方式处理运行时权限。</p>
</blockquote>
<hr>
<h1 id="二-使用示例">二、使用示例</h1>
<h2 id="1准备工作添加一个示例权限">1.准备工作——添加一个示例权限</h2>
<p>我们在项目的<code>AndroidManifest.xml</code>中添加如下权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
</code></pre>
<h2 id="2引入库">2.引入库</h2>
<p>在使用该库API的Module的<code>build.gradle</code>文件中，添加如下代码引入<code>PermissionsDispatcher</code>库：</p>
<pre><code class="language-java">dependencies {
  implementation &quot;com.github.permissions-dispatcher:permissionsdispatcher:4.8.0&quot;
  implementation &quot;com.github.permissions-dispatcher:ktx:1.0.5&quot;
}
</code></pre>
<h2 id="3在需要进行权限请求的activityfragment中定义请求者constructpermissionsrequest">3.在需要进行权限请求的Activity/Fragment中，定义请求者constructPermissionsRequest</h2>
<p>该库提供了<code>constructPermissionsRequest</code>您可以使用给定的几个回调函数构造请求者对象的方法，以便在适当的情况下调用。</p>
<pre><code class="language-java">/* * 
* @param 权限 [requiresPermission] 需要的权限。
* @param onShowRationale 该方法解释了为什么需要权限。
* @param onPermissionDenied 用户未授予权限时调用的方法。
* @param onNeverAskAgain 如果用户不使用
*“不再询问”选项
拒绝权限，则调用该方法。* @param requiresPermission 该操作需要 [permissions]。
*/ fun FragmentActivity /*(or Fragment )*/.constructPermissionsRequest(
     vararg permissions : String ,
     onShowRationale : ShowRationaleFunc ? 
    = null,
     onPermissionDenied :  Func ? = null,
     onNeverAskAgain :  Func ? = null,
     requiresPermission :  Func ): PermissionsRequester
</code></pre>
<p>在这里你只需定义<code>showCamera</code>，使用该库，您无需手动覆盖<code>onRequestPermissionsResult.</code></p>
<blockquote>
<p>注意：确保每次创建活动时都构造一个请求者以适当地捕获回调。</p>
</blockquote>
<p>完整使用示例</p>
<pre><code class="language-java">class MainActivity: AppCompatActivity {
    // constructPermissionsRequest must be invoked every time an activity is created 
    private val showCamera = constructPermissionsRequest(Manifest.permission.CAMERA,
        onShowRationale = ::onCameraShowRationale,
        onPermissionDenied = ::onCameraDenied,
        onNeverAskAgain = ::onCameraNeverAskAgain) {
		    // do something here
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        findViewById(R.id.button_camera).setOnClickListener {
            // 这里发起权限请求
            showCamera.launch()
        }
    }

    // 用户未授予权限时调用
    private fun onCameraDenied() {
        Toast.makeText(requireContext(), R.string.permission_camera_denied, Toast.LENGTH_SHORT).show()
    }

    // 解释为什么需要权限
    private fun onCameraShowRationale(request: PermissionRequest) {
        // 继续请求操作
        request.proceed()
    }

    // 用户勾选“不再询问”选项时调用
    private fun onCameraNeverAskAgain() {
        Toast.makeText(requireContext(), R.string.permission_camera_never_ask_again, Toast.LENGTH_SHORT).show()
    }
}
</code></pre>
<hr>
<h1 id="三-拓展用法">三、拓展用法</h1>
<h2 id="1location-permissions位置权限">1.Location Permissions——位置权限</h2>
<blockquote>
<p>Since the location permissions have been one of the most sensitive permission group to deal with, we provide a dedicated method <code>constructLocationPermissionRequest</code>. With the method you don't have to think of which API version you can ask <code>ACCESS_BACKGROUND_LOCATION</code>(see the issue for more detail).<br>
由于位置权限一直是要处理的最敏感的权限组之一，因此我们提供了专门的方法<code>constructLocationPermissionRequest</code>。使用该方法，您不必考虑可以询问<a href="https://developer.android.com/about/versions/10/privacy/changes#app-access-device-location">ACCESS_BACKGROUND_LOCATION</a>的API 版本（有关更多详细信息，请参阅<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/646">问题</a>）。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructLocationPermissionRequest(
    vararg permissions: LocationPermission,
    onShowRationale: ShowRationaleFun? = null,
    onPermissionDenied: Fun? = null,
    onNeverAskAgain: Fun? = null,
    requiresPermission: Fun
): PermissionsRequester

</code></pre>
<p><strong>注：设备位置权限的访问控制</strong><br>
用户可以更好地控制应用何时可以访问设备位置。当在Android Q上运行的应用程序请求位置访问时，会通过对话框的形式给用户进行授权提示。此对话框允许用户授予对两个不同范围的位置访问权限：在使用中（仅限前台）或始终（前台和后台）。<br>
新增权限 <code>ACCESS_BACKGROUND_LOCATION</code><br>
如果你的应用针对 <code>Android Q</code> 并且需要在后台运行时访问用户的位置，则必须在应用的清单文件中声明新权限</p>
<pre><code class="language-java">&lt;manifest&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;
&lt;/manifest&gt;
</code></pre>
<h2 id="2special-permissions特殊权限">2.Special Permissions——特殊权限</h2>
<blockquote>
<p>The library also provides <code>constructWriteSettingsPermissionRequest</code> and <code>constructSystemAlertWindowPermissionRequest</code> to support <code>WRITE_SETTINGS</code> and <code>SYSTEM_ALERT_WINDOW</code> that requires exceptional handling.<br>
该库还提供<code>constructWriteSettingsPermissionRequest</code>和 <code>constructSystemAlertWindowPermissionRequest</code>支持<code>WRITE_SETTINGS</code>，<code>SYSTEM_ALERT_WINDOW</code>这需要特殊处理。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructWriteSettingsPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester

 /**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructSystemAlertWindowPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 实现篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/">
        </link>
        <updated>2021-07-04T15:57:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">CSDN-谷歌开发者 打造 Material 颜色主题 | 实现篇</a><br>
<em>作者 / Nick Rout, Material Developer Advocate</em></p>
</blockquote>
<p>使用 Material 主题自定义 Material 组件，目的是让组件观感与品牌保持一致。Material 主题包括颜色、字体和形状参数，您可以对这些参数进行调整来获得近乎无限的组件变体，同时保持其核心结构和易用性。</p>
<ul>
<li>
<p>Material 主题<br>
https://material.io/design/material-theming/overview.html#material-theming</p>
</li>
<li>
<p>Material 组件<br>
https://material.io/components</p>
</li>
<li>
<p>Material 颜色<br>
https://material.io/design/color/</p>
</li>
<li>
<p>Material 字体<br>
https://material.io/design/typography/</p>
</li>
<li>
<p>Material 形状<br>
https://material.io/design/shape/<br>
<img src="https://jgduan.github.io//post-images/1625414383767.gif" alt="" loading="lazy"></p>
</li>
</ul>
<p>在 Android 上可使用 1.1.0 版本及以上的 Material 组件 (Material Design Components, MDC) 库来实现 Material 主题。如果您希望从 Design Support Library 或 MDC 1.0.0 迁移到新版本的 MDC，请参阅我们的迁移指南。</p>
<ul>
<li>
<p>Material 组件<br>
https://github.com/material-components/material-components-android</p>
</li>
<li>
<p>迁移指南<br>
https://medium.com/androiddevelopers/migrating-to-material-components-for-android-ec6757795351</p>
</li>
</ul>
<p>继上次我们发布<a href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">《打造 Material 颜色主题 | 设计篇》</a>之后，本文为大家介绍如何实现颜色主题。</p>
<hr>
<h2 id="颜色属性">颜色属性</h2>
<p>Material Design 提供可供填充的 12 个颜色 &quot;槽 (slots)&quot;，这些色值构成应用的整体调色板。每个 &quot;槽&quot; 都有一个设计术语 (如 Primary)，该术语则对应一个可在应用主题中覆盖的颜色属性 (如 Primary 这个术语对应 colorPrimary 这个颜色属性)。这些是您的浅色和深色主题默认的基准色值。</p>
<p><img src="https://jgduan.github.io//post-images/1625414532132.png" alt="" loading="lazy"><br>
△ 浅色主题的基准 MDC 颜色属性</p>
<p><img src="https://jgduan.github.io//post-images/1625414555733.png" alt="" loading="lazy"><br>
△ 深色主题的基准 MDC 颜色属性</p>
<p>Material 组件使用这些颜色属性为各个 widget 着色。<br>
<img src="https://jgduan.github.io//post-images/1625414580741.png" alt="" loading="lazy"><br>
△ 一个按钮中用到的颜色属性</p>
<p>例如，将颜色属性用于布局和 widget 样式中，写法如下所示:<br>
<code>app:backgroundTint=”?attr/colorSecondary”</code><br>
您可能会认得下表中的一些颜色属性，如 colorPrimary。这些因为一些颜色属性继承自 AppCompat 和平台本身，而其余属性则来由 MDC。每个颜色属性的完整来源见下表。<br>
<img src="https://jgduan.github.io//post-images/1625414617487.png" alt="" loading="lazy"></p>
<hr>
<h2 id="挑选颜色">挑选颜色</h2>
<p>主题里每个颜色槽应该使用的具体颜色值由设计师负责给出，或是取自您的产品品牌。但是，了解每个颜色的作用、颜色之间的关系以及如何满足无障碍功能要求仍非常有用:</p>
<ul>
<li>
<p>colorPrimary 和 colorSecondary 是用于呈现品牌的颜色</p>
</li>
<li>
<p>colorPrimaryVariant 和 colorSecondaryVariant 是品牌颜色较浅或较深的阴影色</p>
</li>
<li>
<p>colorSurface 用于表单或表面 (如卡片颜色和应用的底部弹出菜单颜色)</p>
</li>
<li>
<p>android:colorBackground 是应用的窗口背景颜色</p>
</li>
<li>
<p>顾名思义，colorError 用于错误和警告</p>
</li>
<li>
<p>各种各样的 &quot;On&quot; 颜色 (colorOnPrimary、colorOnSecondary、colorOnSurface 等) 用于<br>
为显示在其他颜色上方的前景内容 (如文本和图标) 进行着色。这些颜色需要满足无障碍功能要求并与所在表面的颜色有足够的对比度。</p>
</li>
</ul>
<hr>
<h2 id="颜色工具">颜色工具</h2>
<p>Material Design 为大家提供了丰富的工具，用于预览颜色、确定合适的变体颜色以及 &quot;On&quot; 颜色:</p>
<ul>
<li>
<p>Material 颜色工具: 获得主色和辅色的浅色/深色变体以及合适的 &quot;On&quot; 颜色。并能在示例界面中预览这些颜色的效果。<br>
https://material.io/resources/color/</p>
</li>
<li>
<p>Material 调色板生成器: 生成完整的色调调色板 (即包含 Material 色值编号 50 - 900)。另外您还能获得互补色、近似色和三等分配色的建议。<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625414775321.png" alt="" loading="lazy"><br>
△ Material 颜色工具 (左) 和 Material 调色板生成器 (右)</p>
<hr>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>除非您的品牌恰巧使用和基准 Material 主题色完全相同的紫色和蓝绿色，否则请您务必覆盖 colorPrimary、colorSecondary 及其变体色。</li>
<li>您无需覆盖所有颜色。一些颜色 (如 colorSurface) 默认使用的就是中性颜色，因此使用默认值不会有什么问题。</li>
<li>如果您的品牌没有定义任何种类的辅色或强调色，那么可以将一种颜色同时用于 colorPrimary 和 colorSecondary。变体色也可以和主色相同 (即 colorPrimary 和 colorPrimaryVariant 可以相同)。</li>
<li>一个颜色和其变体颜色以及 &quot;On&quot; 颜色尽管是三个单独的颜色属性 (如 colorPrimary、colorPrimaryVariant 和 colorOnPrimary)，但它们之间依然存在紧密的联系。因此如果您覆盖了其中一个，请检查其他颜色属性，以查看是否可行且满足无障碍功能要求。</li>
</ul>
<hr>
<h2 id="其他颜色槽">其他颜色槽</h2>
<p>除 Material 主题指定的 12 个颜色槽以外，您的设计系统可能还会用到其他颜色槽。幸运的是，在 Android 上声明颜色属性的操作很简单:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;attr name=&quot;colorCustom&quot; format=&quot;color&quot; /&gt;
 
&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.MaterialComponents.*&quot;&gt;
    ...
    &lt;item name=&quot;colorCustom&quot;&gt;@color/...&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="颜色资源">颜色资源</h2>
<p>颜色值会被定义为 <code>&lt;color&gt;</code> 资源。对于自定义颜色，我们建议使用以下两种方法，以帮助区分关注点，并在应用中为颜色主题中的色值创建单一来源:</p>
<ul>
<li>将浅色和深色主题用到的全部<code>&lt;color&gt;</code>存储在一个 res/values/colors.xml 文件中</li>
<li><code>&lt;color&gt;</code>色值使用字面名称命名 (而不是基于使用方式命名):
<ul>
<li>如此一来，便可以在使用颜色时更自然地用到 ?attr/ 语法。支持深色主题时也推荐采用此种方法</li>
<li>使用 green_500 或 brand_name_yellow 等名称</li>
<li>避免使用语义名称，如 color_primary<pre><code class="language-java">&lt;!-- In res/values/colors.xml --&gt;
&lt;color name=&quot;navy_500&quot;&gt;#64869B&lt;/color&gt;
&lt;color name=&quot;navy_700&quot;&gt;#37596D&lt;/color&gt;
&lt;color name=&quot;navy_900&quot;&gt;#073042&lt;/color&gt;
&lt;color name=&quot;green_300&quot;&gt;#3DDC84&lt;/color&gt;
&lt;color name=&quot;green_500&quot;&gt;#00A956&lt;/color&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="覆盖应用主题中的颜色">覆盖应用主题中的颜色</h2>
<p>让我们了解一下如何通过覆盖相关属性将您自己的调色板应用到主题中。</p>
<p>首先，您的主题需要在妥善处理浅色和深色调色板的同时减少与基础主题的重复。有关这方面的更多信息，请参阅 Chris Banes 关于深色主题的文章以及 Chris Banes 和 Nick Butcher 的 &quot;如何正确开发外观样式&quot; 演讲。</p>
<p>设置好主题后，覆盖您希望在浅色和深色主题中更改的颜色属性即可:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_700&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_900&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
 
 
&lt;!-- In res/values-night/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_500&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
</code></pre>
<p>Material 组件将根据主题全局应用您覆盖好的颜色:<br>
<img src="https://jgduan.github.io//post-images/1625415001473.gif" alt="" loading="lazy"></p>
<hr>
<h2 id="颜色复用性和最佳实践">颜色复用性和最佳实践</h2>
<p>在许多情况下，都要在布局、可绘制对象、样式和其他位置使用颜色。我们将介绍一些可尽量复用代码的方法，而且不会影响您在应用主题中指定的色值。</p>
<hr>
<h2 id="首选属性">首选属性</h2>
<p>我们强烈建议使用 ?attr/ 语法来设置颜色。在创建可复用的布局和支持多个模式 (如浅色/深色) 的默认样式时，尤其推荐使用这种语法。</p>
<pre><code class="language-java">&lt;Button
    ...
-    app:backgroundTint=&quot;@color/green_300&quot;
+    app:backgroundTint=&quot;?attr/colorPrimary&quot;
-    android:textColor=&quot;@color/black&quot;
+    android:textColor=&quot;?attr/colorOnPrimary&quot;
/&gt;
</code></pre>
<p>请参阅 Nick Butcher 的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce90bb7fb601dd9e144ae796eb466a2ed805bf14dbc0906543509d95c24733b05bd7fc12c&amp;idx=2&amp;mid=2652064078&amp;scene=21&amp;sn=884a85bfa4f9e19ec531b8245dca6314#wechat_redirect">《Android 样式系统 | 主题背景属性》</a>，以了解更多说明和此规则的一些例外情况。</p>
<hr>
<h2 id="带有-alpha-的颜色">带有 alpha 的颜色</h2>
<p>有时，您可能希望使用 MDC 主题中的一种颜色，但带上 alpha 值 (例如 60% 的 colorPrimary)。例如，触发点击时的波纹动画和项目被选中的状态。</p>
<p>Android<code>&lt;color&gt;</code>资源支持 alpha 通道:</p>
<pre><code class="language-java">&lt;!-- 60% alpha = 99 --&gt;
 
 
&lt;color name=”navy_700_alpha_60”&gt;#9937596D&lt;/color&gt;
</code></pre>
<p>但是，在使用此方法时，我们需要将每个带 alpha 的色值视作颜色资源。这也意味着我们不能用 ?attr/ 来使用这些颜色资源，因为这种做法违背了上文提及的唯一来源准则。</p>
<p>因此，我们建议使用 res/color 目录中存储的 ColorStateList (CSL)。CSL 里的项目可以包含一个颜色引用和 alpha 值，这非常适合我们的用例:</p>
<pre><code class="language-java">&lt;!-- In res/color/primary_60.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:alpha=&quot;0.6&quot; android:color=&quot;?attr/colorPrimary&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<p>使用这些 CSL (通过 @color/primary_60 语法进行引用) 可能会让您感到惊讶，但考虑到 CSL 本身也使用 ?attr/ 来引用底层的主题颜色，因此这样做不会有什么问题。</p>
<hr>
<h2 id="每种状态的颜色和主题叠加">每种状态的颜色和主题叠加</h2>
<p>更为常见的情况是根据视图状态使用 ColorStateList 切换颜色 (和 alpha 值)。MDC widget 大量将其用于禁用状态、悬停状态和按压状态等。比如下面是一个 MDC 按钮的背景色源代码:</p>
<pre><code class="language-java">&lt;!-- In button/res/color/mtrl_btn_bg_color_selector.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:color=&quot;?attr/colorPrimary&quot; android:state_enabled=&quot;true&quot; /&gt;
    &lt;item android:alpha=&quot;0.12&quot; android:color=&quot;?attr/colorOnSurface&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<ul>
<li>完整源代码<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/color/mtrl_btn_bg_color_selector.xml</li>
</ul>
<p>和上面这个按钮的示例类似，假设您希望将主背景色从主色改为辅色:<br>
<img src="https://jgduan.github.io//post-images/1625415175159.png" alt="" loading="lazy"><br>
△ 主色按钮 (左) 和辅色按钮 (右)</p>
<p>您当然可以将以上源文件复制一份，然后将 colorPrimary 改为 colorSecondary，但如果源代码恰巧发生更改，那么此操作会很繁琐且会出现问题。</p>
<p>一种更好的方式是使用主题叠加。Nick Butcher 在他的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf83fb7fb71294558ac5b10882278fb1f53ed3fd7038013c19d2554ff85e20b014fe9ac4b&amp;idx=1&amp;mid=2652067962&amp;scene=21&amp;sn=71a1bc1726c40ccda245f366ae4a51bb#wechat_redirect">《Android 样式系统 | 主题背景覆盖》</a>一文中对此有详细的介绍。基本上，我们可以替换 View 或 ViewGroup 的主题属性值 (在我们例子中为 colorPrimary) 以及所有依赖它的项目 (在我们的例子中为按钮)。</p>
<p>下面是一个主题叠加的简单例子。请注意 parent 为空，其作用是确保我们仅覆盖希望更改的属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;ThemeOverlay.App.PrimarySecondary&quot; parent=&quot;&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;?attr/colorSecondary&lt;/item&gt;
    &lt;item name=&quot;colorOnPrimary&quot;&gt;?attr/colorOnSecondary&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在 XML 中应用主题叠加时，应考虑两个选项:</p>
<ul>
<li>android:theme - 用于所有 widget，不会以默认样式工作</li>
<li>app:materialThemeOverlay - 仅用于 MDC widget，以默认样式工作</li>
</ul>
<pre><code class="language-java">&lt;Button
    ...
    &lt;!-- Alternatively apply with android:theme --&gt;
+    app:materialThemeOverlay=&quot;@style/ThemeOverlay.App.PrimarySecondary&quot;
/&gt;
</code></pre>
<hr>
<h2 id="api-兼容性">API 兼容性</h2>
<p>平台是在 API 23 才开始在 CSL 等处增加对 ?attr/ 语法的支持。如果您的 minSdk 是更早的版本，也不要担心: 有兼容性类！事实上，MDC 和 AppCompat widget 都有在底层使用这些兼容性类，因此在使用时无需其他操作。</p>
<p>对于需要以编程方式使用 CSL 的场景，请使用 AppCompatResources:</p>
<pre><code class="language-java">val primary60 = AppCompatResources#getColorStateList(
    context, R.color.primary60
)
</code></pre>
<ul>
<li>AppCompatResources<br>
https://developer.android.google.cn/reference/androidx/appcompat/content/res/AppCompatResources</li>
</ul>
<hr>
<h2 id="mdc-widget-中的颜色">MDC widget 中的颜色</h2>
<p>之前我们曾说过，MDC widget 会响应主题级别的颜色属性覆盖。但是，您是如何知道按钮会将 colorPrimary 用作其背景着色并将 colorOnPrimary 用于其图标和文本呢？让我们来看一下几个选项。</p>
<hr>
<h2 id="构建-material-主题">构建 Material 主题</h2>
<p>构建 Material 主题是一个交互式 Android 项目，支持您通过自定义颜色、字体和形状来创建自己的 Material 主题。项目还包含所有主题中用到的参数和组件的目录。可通过执行以下操作确定哪些 widget 会对主题颜色属性的更改作出响应:</p>
<ul>
<li>
<p>复制这个项目并在 Android Studio 中运行应用</p>
</li>
<li>
<p>调整 res/values/color.xml 以及 res/values/themes.xml 和 res/values-night/themes.xml 中的色值</p>
</li>
<li>
<p>重新运行应用，观察视觉变化</p>
</li>
<li>
<p>构建 Material 主题<br>
https://material.io/resources/build-a-material-theme</p>
</li>
<li>
<p>项目源代码<br>
https://github.com/material-components/material-components-android-examples/tree/develop/MaterialThemeBuilder</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415351635.png" alt="" loading="lazy"><br>
△ 构建 Material 主题中的色值变化</p>
<hr>
<h2 id="mdc-开发者文档">MDC 开发者文档</h2>
<p>最近我们更新了 MDC 开发者文档。在本次更新中，我们加入了属性表，涵盖了开发库中所使用的设计术语和默认值。例如下面是更新的按钮文档的 &quot;Anatomy and key properties&quot; (详解和关键属性) 部分。<br>
<img src="https://jgduan.github.io//post-images/1625415378990.png" alt="" loading="lazy"><br>
△ MDC 按钮开发文档的属性表中提供了默认色值</p>
<ul>
<li>按钮文档<br>
https://github.com/material-components/material-components-android/blob/master/docs/components/Button.md</li>
</ul>
<hr>
<h2 id="源代码">源代码</h2>
<ul>
<li>
<p>MaterialButton 样式<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/styles.xml</p>
</li>
<li>
<p>MaterialButton 属性<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/attrs.xml</p>
</li>
<li>
<p>MaterialButton 源文件<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/MaterialButton.java</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415449219.png" alt="" loading="lazy"><br>
△ MDC 按钮的默认样式和色值</p>
<hr>
<h2 id="自定义视图中的颜色">自定义视图中的颜色</h2>
<p>您的应用可能包含您自己构建或从现有库中获得的自定义 widget。在和 MDC 一起使用时，使这些视图对 Material 主题作出响应非常必要。让我们看一看在将颜色主题用于自定义 widget 时需要牢记的事项。</p>
<p>在<code>&lt;declare-styleable&gt;</code>和默认样式中使用 MDC 属性</p>
<p>为自定义视图设置样式需要使用<code>&lt;declare-styleable&gt;</code>。在保持一致性方面，复用 MDC 中的属性名称非常有用。使用<code>&lt;declare-styleable&gt;</code>的默认样式还可以使用 MDC 主题颜色属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;declare-styleable name=&quot;AppCustomView&quot;&gt;
    &lt;attr name=&quot;backgroundTint&quot; /&gt;
    &lt;attr name=&quot;titleTextColor&quot; /&gt;
    ...
&lt;/declare-styleable&gt;
 
 
&lt;!-- In res/values/styles.xml --&gt;
&lt;style name=&quot;Widget.App.CustomView&quot; parent=&quot;android:Widget&quot;&gt;
    &lt;item name=&quot;backgroundTint&quot;&gt;?attr/colorSurface&lt;/item&gt;
    &lt;item name=&quot;titleTextColor&quot;&gt;
        @color/material_on_surface_emphasis_high_type
    &lt;/item&gt;
    ...
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="materialcolors-实用程序类">MaterialColors 实用程序类</h2>
<p>可以通过便利的新 MDC 类 (MaterialColors) 以编程方式处理主题的颜色属性，这对于自定义视图也非常有用:</p>
<pre><code class="language-java">// Resolve color from theme attr
val primaryColor = MaterialColors.getColor(
    view, R.attr.colorPrimary
)
 
 
// Layer background color with overlay color + alpha
val overlayedColor = MaterialColors.layer(
    view, R.attr.colorSurface, R.attr.colorPrimary, 0.38f
)
</code></pre>
<hr>
<h2 id="下一步">下一步</h2>
<p>现在，我们已经在 Android 应用中使用 MDC 实现了颜色主题。有关 Material 主题的其他课题，请阅读我们相关的介绍文章。</p>
<ul>
<li>
<p>为什么推荐使用 MDC<br>
https://medium.com/androiddevelopers/we-recommend-material-design-components-81e6d165c2dd</p>
</li>
<li>
<p>字体主题<br>
https://material.io/blog/android-material-theme-type</p>
</li>
<li>
<p>形状主题<br>
https://material.io/blog/android-material-theme-shape</p>
</li>
<li>
<p>深色主题<br>
https://medium.com/androiddevelopers/dark-theme-with-mdc-4c6fc357d956</p>
</li>
<li>
<p>动效系统<br>
https://material.io/blog/android-material-motion</p>
</li>
</ul>
<p>我们一如既往地期待您在 GitHub 上提交错误报告和功能需求。另外，请务必查看 Android 组件示例应用。</p>
<ul>
<li>
<p>提交错误报告<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md&amp;title=%5BComponent+name%5D+Short+description+of+issue</p>
</li>
<li>
<p>提交功能需求<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=feature+request&amp;template=feature_request.md&amp;title=%5BComponent+name%5D+Short+description+of+request</p>
</li>
<li>
<p>Android 组件示例应用<br>
https://github.com/material-components/material-components-android-examples</p>
</li>
</ul>
<p>如果您已成功实现颜色主题或您在实现期间遇到问题，欢迎在下方评论区和我们分享。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 设计篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">
        </link>
        <updated>2021-07-01T15:02:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109475532">CSDN-谷歌开发者 打造 Material 颜色主题 | 设计篇</a><br>
<em>作者 / Liam Spradlin, Material Design Advocate</em></p>
</blockquote>
<p>颜色是设计中最清晰的表现形式之一，尤其是当您需要在人们的各种活动场合中传播您的品牌或产品形象时。应用的界面可容纳丰富的颜色，不仅可以用于打造产品形象，而且由于用户可以直接触摸和操作界面，因此在传播产品形象的同时又能与用户的生活和体验紧密联系，并增强产品的功能、实用性和个性。</p>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwODY4OTk2Mg%3D%3D&amp;action=getalbum&amp;album_id=1340817101657014273#wechat_redirect">Material Design</a> 包含全面的颜色系统，可以让设计师和开发者制定全局颜色决策，并能够有效管理界面状态、强调重点和对比度等问题，使这些颜色决策贯穿于产品的各个层级。</p>
<hr>
<h1 id="material-中的颜色">Material 中的颜色</h1>
<p>为了实现上述目标，Material 使用一组定义好的颜色取值，构成 &quot;颜色主题&quot;。颜色主题包含主要 (Primary) 颜色和次要 (Secondary) 颜色，它们可用于关键组件，另外还包含用于自定义背景 (Background) 色、表面 (Surface) 颜色 (用于呈现抬升的表面或 &quot;纸张&quot;) 和错误 (Error) 颜色的色值。<br>
<img src="https://jgduan.github.io//post-images/1625152307401.png" alt="基准 Material 颜色主题" loading="lazy"><br>
△ 基准 Material 颜色主题</p>
<p>还有一些色值用于 &quot;On&quot; 颜色，顾名思义，它们是出现在其他元素上方的颜色。例如，On Primary 可用于呈现在应用的主要颜色上方显示的文本、图标或其他元素。比如下图展示了带有菜单图标和标题的应用栏，其中的图表和文字都使用 &quot;On&quot; 颜色来确保内容具备适当的对比度和可读性。<br>
<img src="https://jgduan.github.io//post-images/1625152360593.png" alt="" loading="lazy"></p>
<p>对于诸如状态等更加细微的颜色使用场景，Material 使用 &quot;色调调色板&quot;。色调调色板会基于您所选择的颜色提供一组十个值，提供了减淡和加深的选项，可使您的颜色主题更加灵活。<br>
<img src="https://jgduan.github.io//post-images/1625152382453.png" alt="" loading="lazy"></p>
<p>△ 上图中的界面使用主要颜色以及两个主要颜色变体，并应用到所有组件中</p>
<hr>
<h1 id="选择品牌颜色">选择品牌颜色</h1>
<h2 id="从头开始">从头开始</h2>
<p>如果您要从头开始构建颜色主题，也就是说如果您没有现成的品牌调色板，那么最好先充分思考您应用的特质。在我们的 Material Studies 专栏 (基于现实用例和产品约束设计的示例应用) 中，您可以看到根据各种应用的功能和个性所采用的多种基于颜色的品牌化方案。</p>
<ul>
<li>
<p>Material Studies<br>
https://material.io/design/material-studies/about-our-material-studies.html</p>
<p>您的应用是否像暗色调的个人理财应用 Rally 一样，是一款可以帮助人们高效解析信息的实用工具？是否像现代而精致的购物应用 Shrine 一样，能够以精致的美学和粉红色调激发用户的兴趣？或者，也许像教育应用 Owl 一样，能够通过生动的配色来提供更加有趣的教学体验。在每个用例中，颜色在打造和增强应用的个性方面都起着重要作用。<br>
<img src="https://jgduan.github.io//post-images/1625152528876.png" alt="" loading="lazy"><br>
△ Rally 的每个信息图表都使用了两种取自其颜色主题的颜色</p>
<p>对于像 Rally 这样的应用而言，其功能旨在查看和管理个人财务数据，因此必须选用一种深沉的配色方案。该应用的主要颜色为绿色，On 颜色为白色，背景色则为深灰色调。其他颜色均极为深沉，用于在各种信息展示界面中以实用的方式呈现数据。</p>
</li>
<li>
<p>Rally<br>
https://material.io/design/material-studies/rally.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152585442.png" alt="" loading="lazy"><br>
△ Owl 使用三种颜色主题来区分应用中的不同部分</p>
<p>与 Rally 截然相反，Owl 通过在其颜色主题中使用三种不同的主要颜色，打造出鲜活有趣的使用氛围。尽管 Owl 事实上可以被视为在同一个应用中采用了三种不同的颜色主题，但这些颜色却因生动鲜明的共同特征而紧密关联 (它们各自趋近色轮中的三原色: 红、黄、蓝)。</p>
</li>
<li>
<p>Owl<br>
https://material.io/design/material-studies/owl.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152619523.png" alt="" loading="lazy"><br>
△ Shrine 在关健组件和版面设计中采用了简单的颜色主题</p>
<p>Shrine 则介于以上两款应用之间。这款应用具有个性鲜明的色彩表现，使用奶油粉色调作为主要颜色和次要颜色，并使用深棕色作为 On 颜色。虽然 Shrine 的调色板十分独特，但在应用中以专注而精致的方式应用这种色调，能够体现出 Shrine 想要展现的个性形象，打造出一个现代而优雅的时尚和生活购物助手。</p>
</li>
<li>
<p>Shrine<br>
https://material.io/design/material-studies/shrine.html</p>
<p>从头开始制作自己的主题时，请考虑您的应用在上述示例所覆盖的范围中所处的位置。首先，请选择一种能够最贴切地表达应用个性和用途的主要颜色。然后，根据您对应用观感的设想，选择可以增强或调节这些特质的次要颜色。请考虑如何使用 On 颜色，或对表面或背景应用新的颜色以增强表现力。</p>
</li>
</ul>
<h2 id="如果您已有品牌调色板">如果您已有品牌调色板</h2>
<p>在为您的应用构建颜色主题时，您可能已经具有可以轻松转换为 Material 颜色主题的品牌调色板。这种情况下，您可能已经拥有品牌指南，其中涵盖了应优先考虑的颜色以及如何概念化品牌个性或色调方面的内容。您可以将指南内容与前文提到的信息相结合，确定要在颜色主题中包含哪些颜色。</p>
<p>如果您已有品牌调色板但没有指南，请浏览现有的品牌物料或界面设计，然后与调色板进行对比，确定应优先考虑采用哪些颜色作为主要颜色和次要颜色。测试这些颜色以确定它们是否能带来方便阅读的对比度。如果效果不佳，您可以从色调调色板中选择效果理想的颜色变体。</p>
<ul>
<li>测试颜色<br>
https://material.io/tools/color</li>
</ul>
<h2 id="使用调色板生成器扩展调色板">使用调色板生成器扩展调色板</h2>
<p>基于确定下来的几种颜色，可以使用调色板生成器对颜色取值进行扩展，从而满足更多场合的需求。只需在生成器右侧添加所选颜色，然后点击每个生成的色样即可复制其十六进制色值。</p>
<ul>
<li>
<p>调色板生成器<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625152728551.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="呈现主题">呈现主题</h2>
<p>选择一些颜色并将其扩展为色调调色板后，您就可以通过将颜色代入到 Material Design 提供的色谱中来实际创建颜色主题了。</p>
<ul>
<li>
<p>色调调色板<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<p>要在设计工具中进行此操作 (并在 Material Components 上获得主题的即时预览)，请下载我们的 Figma 基准设计工具包。在工具包内的 Material Theme 页面中，您将看到一个名为 Color 的框架，该框架全面展示了您的颜色主题，包括了色调调色板。</p>
</li>
<li>
<p>Figma 基准设计工具包<br>
https://www.figma.com/@materialdesign</p>
<figure data-type="image" tabindex="2"><img src="https://jgduan.github.io//post-images/1625152787143.png" alt="" loading="lazy"></figure>
<p>在上图右侧，您会看到一个面板，在 Color Styles 下方包含了与主题中的颜色相符的全局样式。要开始将颜色插入到主题中，请点击每种颜色样式旁边的编辑图标。返回到生成器中的色调调色板，然后点击工具中的每个色样以复制其十六进制色值，然后将其输入到 Figma 中您选择的样式中。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://jgduan.github.io//post-images/1625152807417.png" alt="" loading="lazy"></figure>
<p>当主要颜色和次要颜色的色样处理完成后，请查看 Figma 界面左边的 Stickersheet 页面以查看主题在每个组件上的显示效果。</p>
<hr>
<h1 id="下一步-实现">下一步: 实现</h1>
<p>完成了上述操作后，您还可以尝试调整表面、背景和错误颜色来优化这个全新的颜色主题。您也可以尝试通过创建多个主题 (例如上文中的 Owl 示例) 来利用颜色系统实现更多创意。</p>
<p>在创建出完美的颜色主题后，您就可以准备实现它了。请大家关注我们接下来会发布的文章<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">《打造 Material 颜色主题 | 实现篇》</a>。</p>
<hr>
<h1 id="推荐阅读">推荐阅读</h1>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf031b7fb79276e6792f13b342073c99a0b8118a9bb2b6b995a5cad6fa57dc58b55993e07&amp;idx=1&amp;mid=2652065908&amp;scene=21&amp;sn=8af70145ec89870c138818a38f005ed0#wechat_redirect">跨设备设计基础 | 如何确定任意屏幕的分辨率指标</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cec31b7fb65275fa39b276c69cf670cfcd8f2395b532953c27bb48d368fe40638a225d4f1&amp;idx=1&amp;mid=2652064884&amp;scene=21&amp;sn=e407e1d047f415309b7b120e1265ce9c#wechat_redirect">使用 Material Design 组件实现深色主题</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce8fbb7fb61ede45fa93a0d8d5464935f48f28601f2db5d5ea8d60863fe2392f2361cffae&amp;idx=1&amp;mid=2652063934&amp;scene=21&amp;sn=caeaec14e70b7569c06503b1bb04138b#wechat_redirect">Android Material 组件 1.2.0 现已发布</a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Jetpack之Room]]></title>
        <id>https://jgduan.github.io/post/android-jetpack-zhi-room/</id>
        <link href="https://jgduan.github.io/post/android-jetpack-zhi-room/">
        </link>
        <updated>2021-06-29T14:50:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。</p>
<hr>
<h1 id="声明依赖-引入room到项目中">声明依赖--引入Room到项目中</h1>
<p>在添加Room依赖前，我们需要在Project的<code>build.gradle</code>中，添加Google Maven代码库到项目中，示例如下：</p>
<pre><code class="language-java">allprojects {
    repositories {
        google()

        // 如果您使用的Gradle版本低于4.1，则必须使用：
        // maven {
        //     url 'https://maven.google.com'
        // }
        // 另一个URL是 'https://dl.google.com/dl/android/maven2/'
    }
}
</code></pre>
<p>在app或者使用Room的Module的<code>build.gradle</code>文件中，我这里添加了以下以代码来使用Room：</p>
<pre><code class="language-java">dependencies {
    def room_version = &quot;2.3.0&quot;

    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)
    annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;

    // To use Kotlin annotation processing tool (kapt) --使用Kotlin注释处理工具
    kapt(&quot;androidx.room:room-compiler:$room_version&quot;)

    // optional - Kotlin Extensions and Coroutines support for Room--可选项，在Room上Kotlin扩展和协程
    implementation(&quot;androidx.room:room-ktx:$room_version&quot;)

    // optional - RxJava3 support for Room--可选项，Room RxJava3支持
    implementation &quot;androidx.room:room-rxjava3:$room_version&quot;
}
</code></pre>
<hr>
<h1 id="room库分析">Room库分析</h1>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li>
<p><strong>数据库：</strong> 包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。<br>
使用<code>@Database</code>注释的类应满足以下条件：</p>
<ul>
<li>
<p>是扩展<code>RoomDatabase</code>的抽象类。</p>
</li>
<li>
<p>在注释中添加与数据库关联的实体列表。</p>
</li>
<li>
<p>包含具有 0 个参数且返回使用<code>@Dao</code>注释的类的抽象方法。</p>
</li>
</ul>
<p>在运行时，您可以通过调用<code>Room.databaseBuilder()</code>或<code>Room.inMemoryDatabaseBuilder()</code>获取 Database 的实例。</p>
</li>
<li>
<p><strong>Entity：</strong> 表示数据库中的表。</p>
</li>
<li>
<p><strong>DAO：</strong> 包含用于访问数据库的方法。</p>
</li>
</ul>
<p>应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。</p>
<p>Room 不同组件之间的关系如图 1 所示：<br>
<img src="https://developer.android.google.cn/images/training/data-storage/room_architecture.png" alt="" loading="lazy"></p>
<hr>
<h1 id="room使用示例">Room使用示例</h1>
<h2 id="新建一个实体类user">新建一个实体类User</h2>
<pre><code class="language-java">@Entity
data class User(
    @PrimaryKey val uid: Int,
    @ColumnInfo(name = &quot;first_name&quot;) val firstName: String?,
    @ColumnInfo(name = &quot;last_name&quot;) val lastName: String?
)
</code></pre>
<h2 id="新建一个dao类">新建一个DAO类</h2>
<pre><code class="language-java">@Dao
interface UserDao {
    @Query(&quot;SELECT * FROM user&quot;)
    fun getAll(): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)
    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; +
            &quot;last_name LIKE :last LIMIT 1&quot;)
    fun findByName(first: String, last: String): User

    @Insert
    fun insertAll(vararg users: User)

    @Delete
    fun delete(user: User)
}
</code></pre>
<h2 id="新建一个appdatabase类继承roomdatabase">新建一个AppDatabase类继承RoomDatabase</h2>
<pre><code class="language-java">@Database(entities = arrayOf(User::class), version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
</code></pre>
<h2 id="数据库的使用">数据库的使用</h2>
<blockquote>
<p>创建完上述文件后，您可以使用以下代码获取已创建的数据库的实例了：</p>
</blockquote>
<pre><code class="language-java">val db = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java, &quot;database-name&quot;
        ).build()
</code></pre>
<blockquote>
<p>注意：如果您的应用在单个进程中运行，在实例化 AppDatabase 对象时应遵循单例设计模式。每个 RoomDatabase 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。</p>
</blockquote>
<blockquote>
<p>如果您的应用在多个进程中运行，请在数据库构建器调用中包含 <code>enableMultiInstanceInvalidation()</code>。这样，如果您在每个进程中都有一个 AppDatabase 实例，可以在一个进程中使共享数据库文件失效，并且这种失效会自动传播到其他进程中 AppDatabase 的实例。</p>
</blockquote>
<hr>
<blockquote>
<p>主要内容源自<a href="https://developer.android.google.cn/training/data-storage/room">官方开发者文档Room操作指南</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】应用加固、混淆分析解读]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/">
        </link>
        <updated>2021-06-29T14:30:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>当我们准备发布一个App版本时，出于对App安全性的考虑，我们一般会选择对代码进行混淆、对打包后的apk文件进行加固操作，其目的就是为了防止app被恶意破解，增加破解难度来提高应用安全性。</p>
<h2 id="代码混淆">代码混淆</h2>
<p>代码混淆是一种常用的加密方式，它通过开启代码混淆开关、配置本地文件，对项目打包后的代码进行加密混淆（混淆的原理实际上就是对原来有具体含义的包名,类名,变量名,方法名等名称全部替换成按顺序排列的无意义的英文字母，如：a,b,c等）。</p>
<blockquote>
<p>proguard-rules.pro文件是给Library模块自己使用的混淆规则；<br>
consumer-rules.pro文件则是会合并到app的混淆规则中，是给包括app在内的其他模块调用时使用的混淆规则；<br>
而这两个文件，完全可以使用同一个文件进行配置；当需要进行区分时，可以使用两个不同的文件进行配置；根据项目需求选择所需即可。</p>
</blockquote>
<h2 id="应用加固">应用加固</h2>
<blockquote>
<p>一个apk文件，当我们把它后缀名修改为.zip时（后续我会追加一篇应用打包过程的文章，来描述apk到底是如何生成的，它包含哪些元素），可以找到classes.dex文件，这个文件包含了我们项目的<strong>主要源代码</strong>，通过反编译工具（如dex2jar等），我们可以轻松的拿到对应的源文件jar包并查看源代码。</p>
</blockquote>
<p>应用加固是指，通过对dex文件的的加密、拼接加壳操作，来有效的对项目代码进行保护，防止通过上述方法来拿到dex文件进行反编译。</p>
<p>当apk被安装后，app启动时会有dex的解密过程，然后系统会重新加载解密后的dex文件。</p>
<hr>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<p><a href="https://blog.csdn.net/weixin_45443931/article/details/98869613">浅谈安卓apk加固原理和实现</a><br>
<a href="https://blog.csdn.net/qq_33232521/article/details/114919455">android 混淆 minifyEnabled proguard-rules.pro consumer-rules.pro</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1忽略build文件夹后找不到BuildConfig]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/">
        </link>
        <updated>2021-06-28T15:14:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在Android Studio版本升级到4.1+后，新建了一个项目并在<code>build.gradle</code>文件中配置了<code>buildConfigField-http/log</code>等相关公共字段的配置并同步，然后因要关联至SVN，便修改了项目中的忽略配置以避免上传部分不需要提交的文件内容，具体配置如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628170410668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="忽略配置" loading="lazy"><br>
配置完毕后，当打开使用到<code>BuildConfig</code>文件的类时，发现编辑器报错并提示找不到该文件，具体如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628171128972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="buildConfig" loading="lazy"></p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>刚碰到该问题，第一时间怀疑是<strong>相关文件未构建成功</strong>，多次<code>Build-&gt;ReBuild Project</code>都毫无作用。</p>
<p>后来想到对应Module的<code>build</code>目录下去查看是否已生成文件（BuildConfig默认的生成在<code>xx/ProjectName/ModuleName/build/generated/source/buildConfig/buildTypes(debug/release/xxx/包名、)</code>目录下），发现在Project预览模式下，无法找到build文件。</p>
<p>最后各种尝试后，定位到可能是因为忽略文件配置导致Project无法预览build文件目录下的内容，导致编辑器报错找不到文件，<strong>直接取消setting-&gt;Editor-&gt;File Types-&gt;.gitignore中的build文件夹的忽略配置即可</strong>。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava3实现倒计时功能]]></title>
        <id>https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/</id>
        <link href="https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/">
        </link>
        <updated>2021-06-28T14:52:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-导入rxjava3">一、导入RxJava3</h1>
<p>在需要使用RxJava的Module中，打开<code>build.gradle</code>文件在<code>dependencies</code>标签内添加如下代码引入RxJava：</p>
<pre><code class="language-java">implementation &quot;io.reactivex.rxjava3:rxjava:3.0.6&quot;
implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
</code></pre>
<hr>
<h1 id="二-倒计时实现">二、倒计时实现</h1>
<ul>
<li><strong>使用<code>intervalRange</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">/**
 * start：开始的数值
 * count：输出值的个数（执行几次）
 * initialDelay：延迟多久执行
 * period：间隔多久执行一次
 * TimeUnit：延迟/间隔数值单位，NANOSECONDS（纳秒），MICROSECONDS（微秒），MILLISECONDS（毫秒），
 * SECONDS（秒），MINUTES（分钟），HOURS（小时），DAYS（天）
 */
Observable.intervalRange(0, 1, 5, 0, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnComplete {
        LogUtil.e(TAG,&quot;start to MainActivity...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }.subscribe()
</code></pre>
<ul>
<li><strong>使用<code>timer</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">// 延时1s进入MainActivity
Observable.timer(1, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe {
        LogUtil.e(TAG,&quot;start to MainActivity2...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】创建签名提示“迁移到行业标准格式PKCS12”问题]]></title>
        <id>https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/">
        </link>
        <updated>2021-06-28T14:21:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>Android Studio新建项目签名时创建签名文件时，提示“迁移到行业标准格式PKCS12”。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>在Android Studio上，通过命令行创建签名文件。</p>
<ol>
<li>输入以下命令：</li>
</ol>
<pre><code class="language-java">keytool -genkey -alias 这里替换成你的应用别名 -keypass 这里填写你的别名密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore 签名文件的存储路径\你得项目名称\app\xxx.jks -storepass 你的签名密码
</code></pre>
<p>你需要修改以下四处：</p>
<ul>
<li>应用别名（alias）</li>
<li>别名密码（alias password）</li>
<li>签名文件保存的路径（全路径，如：D:/TestProject/app/test.jks）</li>
<li>签名密码</li>
</ul>
<ol start="2">
<li>第1步完成后，回车，然后填写签名作者相关信息</li>
</ol>
<pre><code class="language-java">您的名字与姓氏是什么?
  [Unknown]:  zihao
您的组织单位名称是什么?
  [Unknown]:  xxxx
您的组织名称是什么?
  [Unknown]:  xxxx
您所在的城市或区域名称是什么?
  [Unknown]:  HeFei
您所在的省/市/自治区名称是什么?
  [Unknown]:  AnHui
该单位的双字母国家/地区代码是什么?
  [Unknown]:  0086
CN=zihao, OU=xxxx, O=xxxx L=HeFei, ST=AnHui, C=0086是否正确?
  [否]:  y
</code></pre>
]]></content>
    </entry>
</feed>