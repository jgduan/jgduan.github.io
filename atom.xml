<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-08-02T15:44:32.779Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【InterView】Android基础知识回顾]]></title>
        <id>https://jgduan.github.io/post/interview-android-ji-chu-zhi-shi-hui-gu/</id>
        <link href="https://jgduan.github.io/post/interview-android-ji-chu-zhi-shi-hui-gu/">
        </link>
        <updated>2021-08-02T14:44:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-android基础架构">一、Android基础架构</h1>
<ul>
<li>
<p><strong>Android 系统架构</strong><br>
<img src="https://jgduan.github.io//post-images/1627916220584.jpg" alt="" loading="lazy"><br>
Android的系统架构采用分层架构的思想，架构清晰，层次分明，协同工作且各模块之间进行了高度解耦。</p>
<ul>
<li>
<p>Linux Kernel<br>
Linux内核层：Android最底层最核心的部分，为Android提供了核心的系统服务，如：安全系统、内存管理、进程管理、硬件驱动等。</p>
</li>
<li>
<p>Libraries、Android Runtime<br>
系统运行库层：当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其更好的为我们服务，比如其中的SQLite（关系数据库），Webkit（Web浏览器引擎）。</p>
</li>
<li>
<p>Application Framework<br>
应用框架层：这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架来开发自己的应用，这样便简化了程序开发的结构设计，但是必须要遵守其框架的开发原则。</p>
</li>
<li>
<p>Applications<br>
应用层：应用是用java语言编写的运行在虚拟机上的程序，比如Email客户端，SMS短消息程序，日历等。</p>
</li>
</ul>
</li>
<li>
<p><strong>Android 架构总览</strong><br>
<img src="https://jgduan.github.io//post-images/1627916089526.png" alt="" loading="lazy"><br>
详细解析请移步：<a href="https://source.android.google.cn/devices/architecture">Google官方文档</a></p>
</li>
</ul>
<hr>
<h1 id="二-android四大组件">二、Android四大组件</h1>
<ul>
<li>
<p><strong>Activity</strong><br>
活动，作为Android系统中的人机交互的第一界面，负责向用户展示信息和处理结果。<br>
一个App中，至少要有一个Activity。</p>
</li>
<li>
<p><strong>ContentProvider</strong><br>
内容提供者，为不同的应用之间的数据共享提供统一的接口。</p>
<blockquote>
<p>Android系统中，处于安全性的考虑，应用内的数据是对外隔离的，要想让其它应用能够使用自己的数据（如：通讯录等），这个时候就需要使用ContentProvider来进行应用间数据的共享。</p>
</blockquote>
</li>
<li>
<p><strong>Service</strong><br>
服务，可以在后台长时间的运行，不提供用户界面。一个应用程序组件可以启动一个服务，它可以在后台/前台运行。此外，一个组件可以绑定到一个服务与它交互，甚至执行进程间通信(IPC)。例如，一个服务可能处理网络通信、播放音乐、计时操作或与一个内容提供者交互，都在后台执行。</p>
<p>服务从大方向可分为系统服务与应用本地服务（LocalService）。</p>
</li>
<li>
<p><strong>BroadCastReceiver</strong><br>
广播接收器，用于接收应用内、外发出的广播消息。<br>
广播同样可以分为系统广播与应用内广播。</p>
</li>
</ul>
<hr>
<h1 id="三-contenxt">三、Contenxt</h1>
<p><img src="https://jgduan.github.io//post-images/1627917516063.webp" alt="" loading="lazy"><br>
Android上下文对象，用于联系Android应用内的上下沟通，通过它，我们可以获取到应用程序的资源（字符串、图片等），也可以进行广播的收发、服务的启动、接受Intent等。</p>
<p>Application、Activity、Service都继承自Context，在其onCreate时，都会创建对应的Context对象，它们所创建的Context对象的生命周期与其本身相关联。</p>
<hr>
<h1 id="四-android视图架构">四、Android视图架构</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1627917650204.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>一个Activity对应一个Window（一般为PhoneWindow，这个时候，Activity还没有任何东西展示给用户看）；</p>
</li>
<li>
<p>DecorView实际上才是我们真正看得见摸得着的视图范围，一个Decor View一般包括一个TitleView与一个ContentView，DecorView的所有点击时间，都是通过WMS进行接收，并通过Activity对象来响应对应的OnClickListener；</p>
</li>
<li>
<p>ContentView是一个id为content的FragmentLayout，只有我们在Activity的onCreate中调用setContentView方法设置要显示的View后，ContentView才有内容展示给用户。</p>
</li>
</ul>
<hr>
<h1 id="五-android控件树">五、Android控件树</h1>
<p><img src="https://jgduan.github.io//post-images/1627917712990.png" alt="" loading="lazy"><br>
当Activity在onCreate中调用setContentView后，AMS会调用Activity的onResume方法，这是系统会把DecorView添加到PhoneWindow中，这时界面内容才会展示给用户看到。</p>
<hr>
<h1 id="六-view相关">六、View相关</h1>
<ul>
<li>
<p><strong>View的测量</strong><br>
View的测量，一般在onMeasure中进行，自定义View如果想要适配warp_content的话，一定要重写onMeasure方法对View大小进行测量；</p>
<p>View测量的关键是MeasureSpec，它是一个32位的数据，高两位表示对应的测量模式，总共有以下三种测量模式：</p>
<ul>
<li>EXACFLY<br>
精确模式：只有在指定View宽高数值或match_parent的情况下，才会使用。<br>
它也是默认的测量模式，不重写onMeasure方法，是不能使用其它测量模式的。</li>
<li>AL_MOST<br>
最大值模式：只有设置warp_content的情况下，才会使用这种测量模式。</li>
<li>UNSPECIFIED<br>
不指定大小的测量模式，这个模式比较奇怪，View想多大就可以多大，通常只有在绘制自定义View的时候才有可能会用到。</li>
</ul>
</li>
<li>
<p><strong>View的绘制</strong><br>
View的绘制在onDraw(Canvas canvas)方法中进行，绘制View必须在画布（Canvas）上进行。</p>
</li>
</ul>
<hr>
<h1 id="七-viewgroup相关">七、ViewGroup相关</h1>
<ul>
<li>
<p><strong>ViewGroup测量</strong><br>
当ViewGroup的大小为warp_content时，ViewGroup就需要对其子View进行遍历，以便获得所有子View的大小，通过计算从而决定自己的大小。而在其它情况下，会通过具体的指定值来设置自身的大小。</p>
<p>ViewGroup在测量时通过遍历所有的子View，从而调用子View的Measure方法来获得每一个子View的测量结果。</p>
<p>当子View完成测量后，ViewGroup在执行Layout的过程时，同样会通过遍历子View的Layout方法，来指定其具体的显示位置，从而决定其布局位置。</p>
<p>在自定义ViewGroup时，通常会重写onLayout方法来控制子View的显示逻辑，如果需要支持warp_content的话，还需要重写onMeasure方法。</p>
</li>
<li>
<p><strong>ViewGroup的绘制</strong><br>
ViewGroup通常情况下不需要绘制，因为它本身没有需要绘制的东西。</p>
<p>ViewGroup会通过dispatchDraw方法来绘制其子View，其过程同样是遍历子View，并调用子View的绘制方法来完成绘制工作。</p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【InterView】Android知识回顾]]></title>
        <id>https://jgduan.github.io/post/interview-android-zhi-shi-hui-gu/</id>
        <link href="https://jgduan.github.io/post/interview-android-zhi-shi-hui-gu/">
        </link>
        <updated>2021-08-02T14:44:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-android基础架构">一、Android基础架构</h1>
<ul>
<li>
<p><strong>Android 系统架构</strong><br>
<img src="https://jgduan.github.io//post-images/1627916220584.jpg" alt="" loading="lazy"><br>
Android的系统架构采用分层架构的思想，架构清晰，层次分明，协同工作且各模块之间进行了高度解耦。</p>
<ul>
<li>
<p>Linux Kernel<br>
Linux内核层：Android最底层最核心的部分，为Android提供了核心的系统服务，如：安全系统、内存管理、进程管理、硬件驱动等。</p>
</li>
<li>
<p>Libraries、Android Runtime<br>
系统运行库层：当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其更好的为我们服务，比如其中的SQLite（关系数据库），Webkit（Web浏览器引擎）。</p>
</li>
<li>
<p>Application Framework<br>
应用框架层：这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架来开发自己的应用，这样便简化了程序开发的结构设计，但是必须要遵守其框架的开发原则。</p>
</li>
<li>
<p>Applications<br>
应用层：应用是用java语言编写的运行在虚拟机上的程序，比如Email客户端，SMS短消息程序，日历等。</p>
</li>
</ul>
</li>
<li>
<p><strong>Android 架构总览</strong><br>
<img src="https://jgduan.github.io//post-images/1627916089526.png" alt="" loading="lazy"><br>
详细解析请移步：<a href="https://source.android.google.cn/devices/architecture">Google官方文档</a></p>
</li>
</ul>
<hr>
<h1 id="二-android四大组件">二、Android四大组件</h1>
<ul>
<li>
<p><strong>Activity</strong><br>
活动，作为Android系统中的人机交互的第一界面，负责向用户展示信息和处理结果。<br>
一个App中，至少要有一个Activity。</p>
</li>
<li>
<p><strong>ContentProvider</strong><br>
内容提供者，为不同的应用之间的数据共享提供统一的接口。</p>
<blockquote>
<p>Android系统中，处于安全性的考虑，应用内的数据是对外隔离的，要想让其它应用能够使用自己的数据（如：通讯录等），这个时候就需要使用ContentProvider来进行应用间数据的共享。</p>
</blockquote>
</li>
<li>
<p><strong>Service</strong><br>
服务，可以在后台长时间的运行，不提供用户界面。一个应用程序组件可以启动一个服务，它可以在后台/前台运行。此外，一个组件可以绑定到一个服务与它交互，甚至执行进程间通信(IPC)。例如，一个服务可能处理网络通信、播放音乐、计时操作或与一个内容提供者交互，都在后台执行。</p>
<p>服务从大方向可分为系统服务与应用本地服务（LocalService）。</p>
</li>
<li>
<p><strong>BroadCastReceiver</strong><br>
广播接收器，用于接收应用内、外发出的广播消息。<br>
广播同样可以分为系统广播与应用内广播。</p>
</li>
</ul>
<hr>
<h1 id="三-contenxt">三、Contenxt</h1>
<p><img src="https://jgduan.github.io//post-images/1627917516063.webp" alt="" loading="lazy"><br>
Android上下文对象，用于联系Android应用内的上下沟通，通过它，我们可以获取到应用程序的资源（字符串、图片等），也可以进行广播的收发、服务的启动、接受Intent等。</p>
<p>Application、Activity、Service都继承自Context，在其onCreate时，都会创建对应的Context对象，它们所创建的Context对象的生命周期与其本身相关联。</p>
<hr>
<h1 id="四-android视图架构">四、Android视图架构</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1627917650204.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>一个Activity对应一个Window（一般为PhoneWindow，这个时候，Activity还没有任何东西展示给用户看）；</p>
</li>
<li>
<p>DecorView实际上才是我们真正看得见摸得着的视图范围，一个Decor View一般包括一个TitleView与一个ContentView，DecorView的所有点击时间，都是通过WMS进行接收，并通过Activity对象来响应对应的OnClickListener；</p>
</li>
<li>
<p>ContentView是一个id为content的FragmentLayout，只有我们在Activity的onCreate中调用setContentView方法设置要显示的View后，ContentView才有内容展示给用户。</p>
</li>
</ul>
<hr>
<h1 id="五-android控件树">五、Android控件树</h1>
<p><img src="https://jgduan.github.io//post-images/1627917712990.png" alt="" loading="lazy"><br>
当Activity在onCreate中调用setContentView后，AMS会调用Activity的onResume方法，这是系统会把DecorView添加到PhoneWindow中，这时界面内容才会展示给用户看到。</p>
<hr>
<h1 id="六-view相关">六、View相关</h1>
<ul>
<li>
<p><strong>View的测量</strong><br>
View的测量，一般在onMeasure中进行，自定义View如果想要适配warp_content的话，一定要重写onMeasure方法对View大小进行测量；</p>
<p>View测量的关键是MeasureSpec，它是一个32位的数据，高两位表示对应的测量模式，总共有以下三种测量模式：</p>
<ul>
<li>EXACFLY<br>
精确模式：只有在指定View宽高数值或match_parent的情况下，才会使用。<br>
它也是默认的测量模式，不重写onMeasure方法，是不能使用其它测量模式的。</li>
<li>AL_MOST<br>
最大值模式：只有设置warp_content的情况下，才会使用这种测量模式。</li>
<li>UNSPECIFIED<br>
不指定大小的测量模式，这个模式比较奇怪，View想多大就可以多大，通常只有在绘制自定义View的时候才有可能会用到。</li>
</ul>
</li>
<li>
<p><strong>View的绘制</strong><br>
View的绘制在onDraw(Canvas canvas)方法中进行，绘制View必须在画布（Canvas）上进行。</p>
</li>
</ul>
<hr>
<h1 id="七-viewgroup相关">七、ViewGroup相关</h1>
<ul>
<li>
<p><strong>ViewGroup测量</strong><br>
当ViewGroup的大小为warp_content时，ViewGroup就需要对其子View进行遍历，以便获得所有子View的大小，通过计算从而决定自己的大小。而在其它情况下，会通过具体的指定值来设置自身的大小。</p>
<p>ViewGroup在测量时通过遍历所有的子View，从而调用子View的Measure方法来获得每一个子View的测量结果。</p>
<p>当子View完成测量后，ViewGroup在执行Layout的过程时，同样会通过遍历子View的Layout方法，来指定其具体的显示位置，从而决定其布局位置。</p>
<p>在自定义ViewGroup时，通常会重写onLayout方法来控制子View的显示逻辑，如果需要支持warp_content的话，还需要重写onMeasure方法。</p>
</li>
<li>
<p><strong>ViewGroup的绘制</strong><br>
ViewGroup通常情况下不需要绘制，因为它本身没有需要绘制的东西。</p>
<p>ViewGroup会通过dispatchDraw方法来绘制其子View，其过程同样是遍历子View，并调用子View的绘制方法来完成绘制工作。</p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】常见语法解惑]]></title>
        <id>https://jgduan.github.io/post/kotlin-chang-jian-yu-fa-jie-huo/</id>
        <link href="https://jgduan.github.io/post/kotlin-chang-jian-yu-fa-jie-huo/">
        </link>
        <updated>2021-07-24T14:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-kotlin中的与比较符号">一、Kotlin中的'=='与'==='比较符号</h1>
<h2 id="1基础知识">1.基础知识</h2>
<ul>
<li><strong>Kotlin中的三等号 '===' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间);</strong></li>
<li><strong>Kotlin中的双等号 '=='  比较的是i盎格对象的值。</strong></li>
</ul>
<h2 id="2示例">2.示例</h2>
<blockquote>
<p>代码源自<a href="https://kotlinlang.org/docs/basic-types.html">Kotlin官方-Basic types</a></p>
</blockquote>
<ul>
<li>
<p><strong>三等号 '===' 的示例</strong></p>
<pre><code class="language-java">  val a: Int = 100
  val boxedA: Int? = a
  val anotherBoxedA: Int? = a

  val b: Int = 10000
  val boxedB: Int? = b
  val anotherBoxedB: Int? = b

  println(boxedA === anotherBoxedA) // true
  println(boxedB === anotherBoxedB) // false
</code></pre>
</li>
<li>
<p><strong>双等号 '=='  的示例</strong></p>
<pre><code class="language-java">  val b: Int = 10000
  println(b == b) // Prints 'true'
  val boxedB: Int? = b
  val anotherBoxedB: Int? = b
  println(boxedB == anotherBoxedB) // Prints 'true'
</code></pre>
</li>
</ul>
<p>在以上两个示例中，第二段代码可能比较好理解一点，它主要是表现比较两个对象的值是否相等；<br>
对于第一段的代码，可能有人不太理解，同样是使用三等号去比较，为什么第一次比较的值是true，第二次比较的值是false呢？其实Kotlin官方就对此做出了如下解释：</p>
<blockquote>
<p>Numbers representation on the JVM<br>
On the JVM platform, numbers are stored as primitive types: int, double, and so on. Exceptions are cases when you create a nullable number reference such as Int? or use generics. In these cases numbers are boxed in Java classes Integer, Double, and so on.<br>
中文译：在 JVM 平台上，数字存储为原始类型：int、double等。创建可为空的数字引用（例如Int?或使用泛型）时的情况除外。在这些情况下，数字在 Java 类Integer、Double 等中被装箱。<br>
All nullable references to a are actually the same object because of the memory optimization that JVM applies to Integer s between -128 and 127. It doesn't apply to the b references, so they are different objects.<br>
中文译：由于VM对-128到127之间的整数应用了内存优化，因此对a的所有可为null的引用实际上都是同一个对象。而它并不适用于b，b的值已经超出了-128~127的范围，因此它们是不同的对象。</p>
</blockquote>
<p>JDK 从 1.5 版本开始，把 -128~127（high的默认值） 的数字缓存起来了，用于提升性能和节省内存，通过<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>来控制high的取值。所以，当数字在缓存范围内时，通过valueOf()方式拿到的对象引用全部来自于缓存列表，<strong>所以对于相同的值，对象引用相同；若是超过缓存范围，则是重新生成的对象，自然也就不相等了。</strong></p>
<h2 id="3知识汇总">3.知识汇总</h2>
<ul>
<li><strong>Kotlin中的三等号 '===' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间);</strong></li>
<li><strong>Kotlin中的双等号 '=='  比较的是i盎格对象的值；</strong></li>
<li><strong>Kotlin中的非空数字类型对应到JVM平台是基本类型：int,double等等；</strong></li>
<li><strong>Kotlin中的可空数字类型对应到JVM平台是封装类型：Integer，Double等等；</strong></li>
<li><strong>Java中双等号 '==' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间)，与Kotlin中的三等号 '===' 等价。</strong></li>
</ul>
<hr>
<h1 id="二-kotlin中-let-运算符的区别">二、Kotlin中 ?. !!. ?.let ?: 运算符的区别</h1>
<h2 id="1基础知识-2">1.基础知识</h2>
<blockquote>
<p>推荐访问<a href="https://kotlinlang.org/docs/null-safety.html">Kotlin官方-空安全</a><br>
<img src="https://jgduan.github.io//post-images/1627312046689.png" alt="" loading="lazy"></p>
</blockquote>
<p>Kotin支持非空类型与可空类型，同时为了消除空引用的危险，在IDE如果我们是同可空类型命名变量后，访问该变量的其它属性或者方法时，IDE会检测并提出警示，让用户通过<code>?./?.let</code>或者<code>!!./?:</code>运算符来进行安全访问。</p>
<ul>
<li>
<p><strong>对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过;</strong></p>
</li>
<li>
<p><strong>对于一个可空类型：通过<code>？</code>声明，在访问该类型的时候直接访问不能编译通过，需要通过<code>?.</code>或者<code>!!.</code></strong></p>
<ul>
<li><code>?.</code>代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性；<br>
<img src="https://jgduan.github.io//post-images/1627312078667.png" alt="" loading="lazy"></li>
<li><code>!!.</code>代表着如果该类型为空的话就抛出<code>NullPointerException</code>，如果不为空就去访问对应的方法或者属性， 所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出<code>NullPointerException</code>。 而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了。<br>
<img src="https://jgduan.github.io//post-images/1627312112958.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p><strong>let<code>语句简化对可空对象对访问：</code>let`函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。</strong></p>
</li>
<li>
<p><strong><code>?:</code>简化对空值的处理：<code>?:</code>符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。跟<code>?.let</code>正好相反，例如我们可以用两行代码来简化上面从操作：</strong><br>
<img src="https://jgduan.github.io//post-images/1627312147195.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="2示例-2">2.示例</h2>
<ul>
<li>
<p><strong>不可为空类型</strong></p>
<pre><code class="language-java">var a: String = &quot;123&quot; // Regular initialization means non-null by default
a = null // compilation error-编译错误
</code></pre>
</li>
<li>
<p><strong>可为空类型</strong></p>
<pre><code class="language-java">var b: String? = &quot;123&quot; // can be set to null
b = null // ok
println(b) // print null
println(b.length // print null
</code></pre>
<p>这个时候，如果你使用b的属性，那么会提示你使用<code>?.</code>或者<code>!!.</code>，<strong>只有在你需要NPE异常时，才推荐用!!.，否则，请使用?.来进行访问。</strong></p>
</li>
<li>
<p><strong>?.let (安全调用操作符)</strong><br>
通过let语句，在<code>?.let</code>之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</p>
<pre><code class="language-java">    val person:Person? = getPerson()
    person?.let {
        it.name
        it.age
    }
</code></pre>
</li>
<li>
<p><strong>?: ( Elvis 运算符)</strong><br>
如果<code>?:</code>左侧表达式非空，Elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。</p>
<pre><code class="language-java">    val b:Int? = 0
    val l = b?.length ?: -1
</code></pre>
</li>
</ul>
<hr>
<h1 id="三-kotlin中is-is-as-as">三、Kotlin中is !is as as?</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1627312290169.png" alt="" loading="lazy"></figure>
<h2 id="1基础知识-3">1.基础知识</h2>
<ul>
<li>
<p><strong>is与!is</strong><br>
<code>kotlin</code>中<code>API</code>提供的<code>is</code>运算符类似于<code>Java</code>中的<code>instanceof</code>关键字的用法。<br>
<code>is</code>运算符可以检查对象是否与特定的类型兼容(兼容：此对象是该类型，或者派生类)，同时也用来检查对象（变量）是否属于某数据类型（如<code>Int、String、Boolean</code>等）。<br>
<code>!is</code>运算符是它的否定形式。</p>
</li>
<li>
<p><strong>as与as?</strong><br>
<code>as</code>运算符用于执行引用类型的显式类型转换。如果要转换的类型与指定的类型兼容，转换就会成功进行；如果要转换的类型与指定的类型不兼容，就会抛出<code>ClassCastException</code>异常；<br>
<code>as?</code>与<code>as</code>运算符的不同是，如果类型不兼容，使用<code>as?</code>运算符就会返回值<code>null</code>。<br>
在<code>Kotlin</code>中，父类是禁止转换为子类型的。</p>
</li>
</ul>
<h2 id="2示例-3">2.示例</h2>
<ul>
<li>
<p><strong>is与!is</strong></p>
<pre><code class="language-java">  val name = &quot;张三&quot;
  println(name is String)// print true

  val name2 = &quot;张三2&quot;
  println(name !is String)// print false
</code></pre>
</li>
<li>
<p><strong>as与as?</strong></p>
<pre><code class="language-java">  open class Person
  open class Children : Person()

  println(Children as Person)// print Person@xxxxx
  println(Children as Student) 或者 println(Person as Children)// ClassCastException
  println(Children as? Student) 或者 println(Person as? Children)// print null
</code></pre>
</li>
</ul>
<hr>
<h1 id="四-kotlin中的until和">四、Kotlin中的until和..</h1>
<ul>
<li>
<p><strong>until</strong><br>
当我们遍历内容可能并不需要包括结束区间时，使用<code>until</code>来进行内容的遍历；</p>
<pre><code class="language-java">for (i in 1..5) {   // 等价于 for (int i = 1 ; i &lt;= 5 ; i++) { print(i) }
  print(i)  // 12345
}
</code></pre>
<blockquote>
<p>半开半闭区间（<code>Semi open closed interval</code>）是高中数学中函数的一种定义域，常简称为“半开区间”或“半闭区间”。半开半闭区间用“（ ]或[ )”表示，这里的until是指<code>[ )</code>区间，即不包含结束区间。</p>
</blockquote>
</li>
<li>
<p><strong>..</strong><br>
当我们遍历内容需要左右都是闭区间时，使用<code>..</code>来进行内容的遍历；</p>
<pre><code class="language-java">for (i in 1 until 5) {  // 等价于 for (int i = 1 ; i &lt; 5 ; i++) { print(i) }
  print(i) // 1234
}
</code></pre>
<blockquote>
<p>闭区间是直线上的连通的闭集，是直线上介于固定两点间的所有点的集合（包括给定的两点），用[a，b]来表示(包含两个端点a和b）（且<code>a&lt;b</code>）。由于它是有界闭集，所以它是紧致的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>设<code>a</code>和<code>b</code>是两个不同的实数，且<code>a&lt;b</code>，<br>
满足不等式<code>a&lt;X&lt;b</code>的所有实数<code>X</code>所组成的集合叫开区间，用记号<code>（a，b）</code>表示；<br>
满足不等式<code>a≤X≤b</code>的所有实数<code>X</code>所组成的集合叫闭区间，用记号<code>[a,b]</code>表示；<br>
满足不等式<code>a≤X&lt;b</code>或<code>a&lt;X≤b</code>的所有实数<code>X</code>所组成的集合叫半开半闭区间，分别表示为<code>[a,b),(a,b]</code>。</p>
</blockquote>
<hr>
<h1 id="其它">其它</h1>
<ul>
<li><strong>图片内容引用<a href="https://blog.csdn.net/lckj686/article/details/80448471">Kotlin (一) 复合符号( '?.' '?:' '!!' 'as?' '?' )</a>，侵删</strong></li>
<li><strong><a href="https://kotlinlang.org/docs/null-safety.html">Kotlin官方-空安全</a></strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【团队管理】KPI与OKR]]></title>
        <id>https://jgduan.github.io/post/tuan-dui-guan-li-kpi-yu-okr/</id>
        <link href="https://jgduan.github.io/post/tuan-dui-guan-li-kpi-yu-okr/">
        </link>
        <updated>2021-07-20T15:19:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-kpi-关键绩效指标">一、KPI-关键绩效指标</h1>
<h2 id="1kpi概述">1.KPI概述</h2>
<blockquote>
<p>KPI(<code>Key Performance Indicator</code>)，中文意为关键绩效指标。</p>
</blockquote>
<p><strong>KPI是一种自上而下，首先确定组织目标的管理考核机制</strong>，是通过对组织内部流程的输入端、输出端的关键参数进行设置、取样、计算、分析，衡量流程绩效的一种目标式量化管理指标，是把企业的战略目标分解为可操作 / 执行的工作目标的工具，是企业绩效管理的基础。</p>
<p>KPI可以是部门主管明确部门的主要责任，并以此为基础，明确部门人员的业绩衡量指标。建立明确的切实可行的KPI体系，是做好绩效管理的关键。关键绩效指标是用于衡量工作人员工作绩效表现的量化指标，是绩效计划的重要组成部分。</p>
<p>KPI法符合一个重要的管理原理：<strong>“二八原理”</strong>——在一个企业的价值创造过程中，存在着“80/20”的规律，即20%的骨干人员创造企业80%的价值；而且在每一位员工身上“二八原理”同样适用，即80%的工作任务是由20%的关键行为完成的。因此，必须抓住20%的关键行为，对之进行分析和衡量，这样就能抓住业绩评价的重心。</p>
<blockquote>
<p>二八原理，是由意大利经济学家帕累托提出的一个经济学原理，即一个企业在价值创造过程中，每个部门和每一位员工的80%的工作任务是由20%的关键行为完成的，抓住20%的关键，就抓住了主体。<br>
二八原理为绩效考核指明了方向，即考核工作的主要精力要放在关键的结果和关键的过程上。于是，所谓的绩效考核，一定放在关键绩效指标上，考核工作一定要围绕关键绩效指标展开。</p>
</blockquote>
<h2 id="2kpi绩效考核的目的">2.KPI绩效考核的目的</h2>
<p>以战略为中心，指标体系的设计与运用都为组织战略目标的达成服务。<br>
以控制为中心，指标体系的设计与运用来源于控制的意图，也是为更有效的控制个人的行为服务。</p>
<hr>
<h1 id="二-okr-目标与关键成果法">二、OKR-目标与关键成果法</h1>
<h2 id="1okr概述">1.OKR概述</h2>
<p>OKR（<code>Objectives and Key Results</code>）即目标与关键成果法，是一套明确和跟踪目标及其完成情况的管理工具和方法，由英特尔公司创始人安迪·葛洛夫（AndyGrove）发明，并由约翰·道尔（JohnDoerr）引入到谷歌使用，1999年OKR在谷歌发扬光大，在Facebook、Linked in等企业广泛使用。</p>
<p><strong>OKR的思路是一定程度上的自下而上的、由个人提出，然后由组织确定的管理考核方式。</strong></p>
<p>2014年，OKR传入中国。2015年后，百度、华为、字节跳动等企业都逐渐使用和推广OKR。</p>
<p><strong>OKR的主要目标是明确公司和团队的“目标”以及明确每个目标达成的可衡量的“关键结果”。</strong></p>
<p>一本关于OKR的书将OKR定义为“一个重要的思考框架与不断发展的学科，旨在确保员工共同工作，并集中精力做出可衡量的贡献。”</p>
<p><strong>OKR可以在整个组织中共享，这样团队就可以在整个组织中明确目标，帮助协调和集中精力。</strong></p>
<hr>
<h1 id="kpi与okr">KPI与OKR</h1>
<h2 id="1两者之间的区别">1.两者之间的区别</h2>
<h2 id="2kpi的缺陷">2.KPI的缺陷</h2>
<ol>
<li><strong>没有人对最终结果负责，每个人只对自己的过程负责。</strong></li>
<li><strong>人的主观能动性被压抑。</strong></li>
<li><strong>结果高度依赖机器和管理者的指令。</strong></li>
</ol>
<p>有些事情值得去做，但在做出来一部分之前无法测量因此无法制订目标。为了完成可测量的目标，有可能实际执行手段与该目标要达到的愿景正好相反。</p>
<p>举例来说，我们希望用户更喜欢使用我们的产品，因为喜欢无法测量，所以把PV写进了 KPI 里面。但在实际执行过程中，我们可以把用户原本在一个页面上就能完成的事情分到几个页面上来完成，结果 PV 达到了 KPI 指定的目标，但用户可能更讨厌我们的产品了。</p>
<h2 id="3okr解决了什么">3.OKR解决了什么</h2>
<p>OKR 解决了 KPI 的这些缺陷。首先它和绩效考核分离，把绩效考核交给 peer review来做。然后它强调 Key Result 必须服从 Objective，所以如果你在 Objective上写了要让用户喜欢我们的产品，但你实际执行 Key Result 的手段违反了这一点的话，谁都能看得出来。既然 Key Result 只是用来服务于 Objective 的，那就没必要像 KPI 那样一早制订好然后强制执行了。你可以在做的过程中随意更改 Key Result，只要它们还是服务于原本的 Objective 就行。</p>
<hr>
<h1 id="三-拓展阅读">三、拓展阅读</h1>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E7%BB%A9%E6%95%88%E6%8C%87%E6%A0%87%E6%B3%95/4723067?fr=aladdin"><strong>关键绩效指标法</strong></a></li>
<li><a href="https://baike.baidu.com/item/OKR"><strong>OKR-目标与关键成果法</strong></a></li>
<li><a href="https://www.zhihu.com/question/22471467/answer/220121306"><strong>谷歌内部考核制度 OKR 是怎样的？ - 李会军的回答 - 知乎</strong></a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android应用优化】解决应用启动时黑屏/白屏问题]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-you-hua-jie-jue-ying-yong-qi-dong-shi-hei-ping-bai-ping-wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-you-hua-jie-jue-ying-yong-qi-dong-shi-hei-ping-bai-ping-wen-ti/">
        </link>
        <updated>2021-07-19T16:11:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-app的载入页">Android App的载入页</h1>
<h2 id="什么是载入页">什么是载入页？</h2>
<p>当前主流应用流行在启动时打开一个类似欢迎页的过度页面，我们一般称之为<code>SplashActivity</code>，中文一般用载入页来表示。</p>
<blockquote>
<p>一般来说，载入页都是以全屏的方式展示给用户的。</p>
</blockquote>
<h2 id="载入页能做些什么">载入页能做些什么？</h2>
<ol>
<li><strong>加深用户对产品的印象</strong>：通过在载入页进行应用 / 企业信息的展示来加深用户对产品的印象；</li>
<li><strong>启动过渡</strong>：避免主页初始化过慢给用户不友好的交互体验；</li>
<li><strong>开屏推荐信息 / 广告展示</strong>：简短的信息 / 广告展示，灵活利用<code>App</code>内容初始化的时间进行相关转化；</li>
<li><strong>临时预加载</strong>：提前为主页做一些不耗时的预加载工作。</li>
</ol>
<h2 id="载入页一般存在多久">载入页一般存在多久？</h2>
<p>通常情况下，在用户点击桌面应用的icon后，会进入到<code>SplashActivity</code>载入页，然后一般是在<strong>3s内</strong>进入到应用的主页面（考虑到交互的友好性，载入页不应该存在太久，也不应该存在太多的耗时操作，否则会给用户<strong>很卡</strong>的感觉，它的存在，更多的是起到一些基础信息的展示、初始化及过度作用）。</p>
<hr>
<h1 id="载入页的黑屏-白屏问题">载入页的黑屏 / 白屏问题</h1>
<p>在我们没有对应用进行特殊处理时，我们会发现在一些机型上（尤其是配置相对较差的机器），在桌面点击应用图标首次启动应用时，载入页出现前会出现黑屏 / 白屏的问题。</p>
<h2 id="为什么会出现黑屏-白屏呢">为什么会出现黑屏 / 白屏呢？</h2>
<p>因为在用户点击应用图标后，系统会进行一系列的<code>Framework</code>操作，其中就包括<code>Application</code>的初始化，如果我们在<code>Application</code>初始化的过程中做了过多的操作，就会导致应用明明已经启动了，却迟迟没有界面展示出来，这个时候，就会出现应用黑屏 / 白屏的情况。</p>
<blockquote>
<p><code>Application</code>初始化时注意：</p>
<ol>
<li>尽量不将一些业务逻辑放于<code>Application</code>中；</li>
<li>不以静态变量的方式在<code>Application</code>中保存应用数据；</li>
<li>不要把文件、数据库的操作放在<code>Application</code>中；</li>
<li>不要再<code>Application</code>封装与初始化无关的其它事务。</li>
</ol>
</blockquote>
<h2 id="什么时候出现黑屏什么时候出现白屏">什么时候出现黑屏？什么时候出现白屏？</h2>
<p>App黑屏/白屏，实际上跟设置的主题（<code>Theme</code>）有关，设置<code>Light</code>系列的，会显示白屏，设置<code>Dark</code>系列的，会显示黑屏。</p>
<hr>
<h1 id="解决方法">解决方法</h1>
<h2 id="设置透明的splashactivity">设置透明的SplashActivity</h2>
<p>在应用<code>styles</code>文件内，为载入页（SplashActivity）新增自定义样式，设置Activity的主题样式背景为透明色、全屏、无标题栏、无ActionBar，具体代码如下：</p>
<pre><code class="language-java">&lt;style name=&quot;AppTheme.Splash&quot; parent=&quot;AppTheme.xxx&quot;&gt;
    &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
    &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在<code>AndroidManifest.xml</code>中为SplashActivity设置<code>Theme</code>样式：</p>
<pre><code class="language-java">&lt;activity
    android:name=&quot;.SplashActivity&quot;
    android:theme=&quot;@style/AppTheme.Splash&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1+版本在Module-BuildConfig中找不到VERSION_CODE、VERSION_NAME字段]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41ban-ben-zai-module-buildconfig-zhong-zhao-bu-dao-version_codeversion_name-zi-duan/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41ban-ben-zai-module-buildconfig-zhong-zhao-bu-dao-version_codeversion_name-zi-duan/">
        </link>
        <updated>2021-07-18T16:38:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>最近升级<code>Android Studio</code>到4.2版本后，在项目的其它<code>Module</code>中添加了检查更新功能，本想通过统一配置<code>VersionCode、VersionName</code>然后在<code>Module</code>中直接获取本地的<code>VersionCode</code>来与服务器对比做更新判断的，结果发现<code>BuildConfig</code>文件中，没有这两个字段。最后通过<code>StackOverflow</code>查询后发现<a href="https://issuetracker.google.com/issues/154275579?pli=1#comment3"><strong>Google Issue Tracker</strong></a>文中对问题的原因进行了解释：<code>Google</code>认为<code>VersionCode、VersionName</code>字段在其它<code>Module</code>中不代表任何意义，还容易与<code>app</code>模块中的字段混淆概念，所以认定它不应该再出现在其它模块中。</p>
<p><img src="https://jgduan.github.io//post-images/1626627606725.png" alt="" loading="lazy"><br>
<img src="https://jgduan.github.io//post-images/1626627613034.png" alt="" loading="lazy"><br>
<img src="https://jgduan.github.io//post-images/1626627621216.png" alt="" loading="lazy"></p>
<hr>
<h1 id="解决方法">解决方法</h1>
<ul>
<li><strong>使用App模块中的字段进行判断</strong></li>
<li><strong>在Module中添加VersionCode的配置</strong><br>
我们可以在<code>Module-build.gradle</code>文件中添加对应<code>VersionCode、VersionName</code>的配置，通过该方式，也可以达到目的，不过<em>个人不推荐这样做</em>，按照官方的做法即可。</li>
</ul>
<pre><code class="language-java">debug {
    buildConfigField &quot;String&quot;, &quot;VERSION_NAME&quot;, &quot;1.0.1&quot;
    buildConfigField &quot;int&quot;, &quot;VERSION_CODE&quot;, &quot;1&quot;
}
release {
    buildConfigField &quot;String&quot;, &quot;VERSION_NAME&quot;, &quot;1.0.1&quot;
    buildConfigField &quot;int&quot;, &quot;VERSION_CODE&quot;, &quot;1&quot;
}
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】自定义绘制一个圆环形进度条]]></title>
        <id>https://jgduan.github.io/post/android-zi-ding-yi-hui-zhi-yi-ge-yuan-huan-xing-jin-du-tiao/</id>
        <link href="https://jgduan.github.io/post/android-zi-ding-yi-hui-zhi-yi-ge-yuan-huan-xing-jin-du-tiao/">
        </link>
        <updated>2021-07-07T14:46:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-预期效果">一、预期效果</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625669223339.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="二-绘制分析">二、绘制分析</h1>
<p>根据预期图片可以看出：</p>
<ul>
<li>
<p><strong>需要绘制一个带有文本的圆环形进度条</strong></p>
<ul>
<li>绘制圆环（进度条背景色）</li>
<li>绘制圆环上的进度（进度条前景色）</li>
</ul>
</li>
<li>
<p><strong>它的最大值、进度可自由设置</strong></p>
<ul>
<li>自定义属性：maxValue</li>
<li>自定义属性：progress</li>
</ul>
</li>
<li>
<p><strong>进度线条的形状为圆头</strong></p>
</li>
<li>
<p><strong>进度条中心位置显示标题及任务描述</strong></p>
<ul>
<li>标题文本绘制-drawText</li>
<li>任务描述文本绘制-drawText</li>
<li>文字居中显示</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三-开始绘制">三、开始绘制</h1>
<ul>
<li>
<p><strong>新建一个<code>CircleProgressBar</code>类，继承<code>View</code></strong></p>
</li>
<li>
<p><strong>相关自定义属性的设置</strong></p>
</li>
<li>
<p><strong>控件获取宽高、中心点、初始化画笔</strong></p>
</li>
<li>
<p><strong>绘制圆环及进度</strong></p>
<ul>
<li>绘制圆环（背景色）</li>
<li>绘制进度（前景色）</li>
</ul>
</li>
<li>
<p><strong>绘制显示的文本</strong></p>
<ul>
<li>绘制标题文本</li>
<li>绘制描述文本</li>
</ul>
</li>
<li>
<p><strong>进度条展示动画效果设置</strong></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】Android Paint 画笔的一些偏知识]]></title>
        <id>https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/</id>
        <link href="https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/">
        </link>
        <updated>2021-07-06T15:02:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转载于 抛物线http://hencoder.com/ui-1-2/</p>
</blockquote>
<hr>
<h1 id="setstrokecappaintcap-cap-设置线头的形状">setStrokeCap(Paint.Cap cap) 设置线头的形状</h1>
<p>设置线头的形状。线头形状有三种：<code>BUTT</code> 平头、<code>ROUND</code> 圆头、<code>SQUARE</code> 方头。默认为 <code>BUTT</code>。</p>
<blockquote>
<p>放出「平头」「圆头」「方头」这种翻译我始终有点纠结：既觉得自己翻译得简洁清晰尽显机智，同时又担心用词会不会有点太过通俗，让人觉得我不够高贵冷艳？</p>
</blockquote>
<p>当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：<br>
<img src="https://jgduan.github.io//post-images/1625584089491.jpg" alt="" loading="lazy"></p>
<p>虚线是额外加的，虚线左边是线的实际长度，虚线右边是线头。有了虚线作为辅助，可以清楚地看出 <code>BUTT</code> 和 <code>SQUARE</code> 的区别。</p>
<hr>
<h1 id="setstrokejoinpaintjoin-join">setStrokeJoin(Paint.Join join)</h1>
<p>设置拐角的形状。有三个值可以选择：<code>MITER</code> 尖角、 <code>BEVEL</code> 平角和 <code>ROUND</code> 圆角。默认为 <code>MITER</code>。<br>
<img src="https://jgduan.github.io//post-images/1625584131677.jpg" alt="" loading="lazy"></p>
<p>辅助理解：<br>
<code>MITER</code> 在现实中其实就是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584155362.jpg" alt="" loading="lazy"></p>
<p>而 <code>BEVEL</code> 是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584171460.jpg" alt="" loading="lazy"></p>
<hr>
<h1 id="setstrokemiterfloat-miter">setStrokeMiter(float miter)</h1>
<p>这个方法是对于 <code>setStrokeJoin()</code> 的一个补充，它用于设置 <code>MITER</code> 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：<br>
当线条拐角为 <code>MITER</code> 时，拐角处的外缘需要使用延长线来补偿：<br>
<img src="https://jgduan.github.io//post-images/1625584210033.jpg" alt="" loading="lazy"></p>
<p>而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：<br>
<img src="https://jgduan.github.io//post-images/1625584221599.jpg" alt="" loading="lazy"></p>
<p>所以为了避免意料之外的过长的尖角出现， <code>MITER</code> 型连接点有一个额外的规则：当尖角过长时，自动改用 <code>BEVEL</code> 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 <code>BEVEL</code> 型连接点：<br>
<img src="https://jgduan.github.io//post-images/1625584236255.jpg" alt="" loading="lazy"></p>
<p>至于多尖的角属于过于尖，尖到需要转为使用 <code>BEVEL</code> 来绘制，则是由一个属性控制的，而这个属性就是 <code>setStrokeMiter(miter)</code>方法中的 <code>miter</code> 参数。<code>miter</code> 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：<br>
<img src="https://jgduan.github.io//post-images/1625584259127.jpg" alt="" loading="lazy"></p>
<p>用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1 / sin ( θ / 2 ) 。<br>
这个 <code>miter limit</code> 的默认值是 4，对应的是一个大约 29° 的锐角：<br>
<img src="https://jgduan.github.io//post-images/1625584364544.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」</p>
</blockquote>
<p>所以，这个方法虽然名叫 <code>setStrokeMiter(miter)</code> ，但它其实设置的是「 线条在 <code>Join</code> 类型为 <code>MITER</code> 时对于 <code>MITER</code> 的长度限制」。它的这个名字虽然短，但却存在一定的迷惑性，如果叫 <code>setStrokeJoinMiterLimit(limit)</code> 就更准确了。 Google 的工程师没有这么给它命名，大概也是不想伤害大家的手指吧，毕竟程序员何苦为难程序员。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】各大版本新特性及行为变更]]></title>
        <id>https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/</id>
        <link href="https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/">
        </link>
        <updated>2021-07-05T15:03:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><strong>Android 12.0开发者预览版</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/12/features?hl=zh_cn">概览 API 30</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all">Android 12.0影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12?hl=zh_cn">行为变更：以 Android 12 为目标平台的应用</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/foreground-services?hl=zh_cn">前台服务启动限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/non-sdk-12?hl=zh_cn">Android 12 中有关限制非 SDK 接口的更新</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features">Android 12 功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/work?hl=zh_cn">Android 12 中的企业功能新变化</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/migration?hl=zh_cn">将应用迁移到 Android 12</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/unified-content-api?hl=zh_cn">接收内容的统一 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/compatible-media-transcoding?hl=zh_cn">兼容的媒体转码</a></li>
</ul>
</li>
<li>
<p><strong>Android 11.0</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/11?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-all">影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-11">影响以 Android 11 为目标平台的应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/privacy">Android 11 隐私权变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/features">Android 11 功能和 API 30</a></li>
</ul>
</li>
<li>
<p><strong>Android 10.0(Q)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/10?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/migration?hl=zh_cn">将应用迁移至 Android 10</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/privacy?hl=zh_cn">隐私功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/behavior-changes-all?hl=zh_cn">行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/highlights?hl=zh_cn">新功能和 API 29</a></li>
<li><a href="https://blog.csdn.net/u011216417/article/details/89189741">Android10.0(Q)新特性和行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 9.0(P)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/pie?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0?hl=zh_cn">功能和API 28</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all?hl=zh_cn">针对所有应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-28?hl=zh_cn">针对API 28+应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-migration?hl=zh_cn">迁移至Android 9.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/power?hl=zh_cn">电源管理</a></li>
</ul>
</li>
<li>
<p><strong>Android 8.0(O)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/oreo?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0?hl=zh_cn">Android 8.0 功能和 API 26</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes?hl=zh_cn">Android 8.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-migration?hl=zh_cn">迁移到Android 8.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-samples?hl=zh_cn">Android 8.0示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background?hl=zh_cn">后台执行限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits?hl=zh_cn">后台位置信息限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.1?hl=zh_cn">Android 8.1 功能和 API 27</a></li>
</ul>
</li>
<li>
<p><strong>Android 7.0(N)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/nougat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0?hl=zh_cn">Android 7.0 开发者版本 API 24</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes?hl=zh_cn">Android 7.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-samples?hl=zh_cn">Android 7.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1?hl=zh_cn">Android 7.1 开发者版本 API 25</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1-samples?hl=zh_cn">Android 7.1 示例</a></li>
</ul>
</li>
<li>
<p><strong>Android 6.0(M)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0?hl=zh_cn">Android 6.0 API 23</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes?hl=zh_cn">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-samples?hl=zh_cn">Android 6.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-testing?hl=zh_cn">Android 6.0 测试指南</a></li>
</ul>
</li>
<li>
<p><strong>Android 5.0(L)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/lollipop?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.1?hl=zh_cn">Android 5.1 API 22</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0?hl=zh_cn">Android 5.0 API 21</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0-changes?hl=zh_cn">Android 5.0 行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 4.4(KitKat)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/kitkat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4?hl=zh_cn">Android 4.4 API 19</a></li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://developer.android.google.cn/about/versions?hl=zh_cn">所有Android版本</a></p>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】使用PermissionsDispatcher进行动态权限适配]]></title>
        <id>https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/</id>
        <link href="https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/">
        </link>
        <updated>2021-07-05T12:55:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-permissionsdispatcher简介">一、PermissionsDispatcher简介</h1>
<p>PermissionsDispatcher provides a simple annotation-based API to handle runtime permissions.<br>
<code>PermissionsDispatcher</code>提供了一个简单的基于注解的 API 来处理运行时权限。</p>
<p>This library lifts the burden that comes with writing a bunch of check statements whether a permission has been granted or not from you, in order to keep your code clean and safe.<br>
该库减轻了编写一堆检查语句所带来的负担，无论是否已授予您许可，以保持您的代码清洁和安全。</p>
<ul>
<li>
<p><strong>Fully Kotlin/Java support - 完全支持Kotlin/Java</strong></p>
</li>
<li>
<p><strong><a href="https://github.com/hotchemi/PermissionsDispatcher/blob/master/doc/special_permissions.md">Special permissions support - 特殊权限支持</a></strong></p>
</li>
<li>
<p><strong>100% reflection-free - 100%无反射</strong></p>
</li>
</ul>
<p>本文基于<code>PermissionsDispatcher 4.8.0及 permissionsdispatcher-ktx 1.0.5</code>版本，我们将介绍Kotlin的ktx使用方式，如过需要使用Kotlin kapt或Java使用方式的，请移步<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">Github-PermissionsDispatcher</a></p>
<blockquote>
<p><code>permissionsdispatcher-ktx</code><br>
<code>permissionsdispatcher-ktx</code>旨在让开发人员在不使用注释处理（kapt）的情况下以声明式方式处理运行时权限。</p>
</blockquote>
<hr>
<h1 id="二-使用示例">二、使用示例</h1>
<h2 id="1准备工作添加一个示例权限">1.准备工作——添加一个示例权限</h2>
<p>我们在项目的<code>AndroidManifest.xml</code>中添加如下权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
</code></pre>
<h2 id="2引入库">2.引入库</h2>
<p>在使用该库API的Module的<code>build.gradle</code>文件中，添加如下代码引入<code>PermissionsDispatcher</code>库：</p>
<pre><code class="language-java">dependencies {
  implementation &quot;com.github.permissions-dispatcher:permissionsdispatcher:4.8.0&quot;
  implementation &quot;com.github.permissions-dispatcher:ktx:1.0.5&quot;
}
</code></pre>
<h2 id="3在需要进行权限请求的activityfragment中定义请求者constructpermissionsrequest">3.在需要进行权限请求的Activity/Fragment中，定义请求者constructPermissionsRequest</h2>
<p>该库提供了<code>constructPermissionsRequest</code>您可以使用给定的几个回调函数构造请求者对象的方法，以便在适当的情况下调用。</p>
<pre><code class="language-java">/* * 
* @param 权限 [requiresPermission] 需要的权限。
* @param onShowRationale 该方法解释了为什么需要权限。
* @param onPermissionDenied 用户未授予权限时调用的方法。
* @param onNeverAskAgain 如果用户不使用
*“不再询问”选项
拒绝权限，则调用该方法。* @param requiresPermission 该操作需要 [permissions]。
*/ fun FragmentActivity /*(or Fragment )*/.constructPermissionsRequest(
     vararg permissions : String ,
     onShowRationale : ShowRationaleFunc ? 
    = null,
     onPermissionDenied :  Func ? = null,
     onNeverAskAgain :  Func ? = null,
     requiresPermission :  Func ): PermissionsRequester
</code></pre>
<p>在这里你只需定义<code>showCamera</code>，使用该库，您无需手动覆盖<code>onRequestPermissionsResult.</code></p>
<blockquote>
<p>注意：确保每次创建活动时都构造一个请求者以适当地捕获回调。</p>
</blockquote>
<p>完整使用示例</p>
<pre><code class="language-java">class MainActivity: AppCompatActivity {
    // constructPermissionsRequest must be invoked every time an activity is created 
    private val showCamera = constructPermissionsRequest(Manifest.permission.CAMERA,
        onShowRationale = ::onCameraShowRationale,
        onPermissionDenied = ::onCameraDenied,
        onNeverAskAgain = ::onCameraNeverAskAgain) {
		    // do something here
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        findViewById(R.id.button_camera).setOnClickListener {
            // 这里发起权限请求
            showCamera.launch()
        }
    }

    // 用户未授予权限时调用
    private fun onCameraDenied() {
        Toast.makeText(requireContext(), R.string.permission_camera_denied, Toast.LENGTH_SHORT).show()
    }

    // 解释为什么需要权限
    private fun onCameraShowRationale(request: PermissionRequest) {
        // 继续请求操作
        request.proceed()
    }

    // 用户勾选“不再询问”选项时调用
    private fun onCameraNeverAskAgain() {
        Toast.makeText(requireContext(), R.string.permission_camera_never_ask_again, Toast.LENGTH_SHORT).show()
    }
}
</code></pre>
<hr>
<h1 id="三-拓展用法">三、拓展用法</h1>
<h2 id="1location-permissions位置权限">1.Location Permissions——位置权限</h2>
<blockquote>
<p>Since the location permissions have been one of the most sensitive permission group to deal with, we provide a dedicated method <code>constructLocationPermissionRequest</code>. With the method you don't have to think of which API version you can ask <code>ACCESS_BACKGROUND_LOCATION</code>(see the issue for more detail).<br>
由于位置权限一直是要处理的最敏感的权限组之一，因此我们提供了专门的方法<code>constructLocationPermissionRequest</code>。使用该方法，您不必考虑可以询问<a href="https://developer.android.com/about/versions/10/privacy/changes#app-access-device-location">ACCESS_BACKGROUND_LOCATION</a>的API 版本（有关更多详细信息，请参阅<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/646">问题</a>）。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructLocationPermissionRequest(
    vararg permissions: LocationPermission,
    onShowRationale: ShowRationaleFun? = null,
    onPermissionDenied: Fun? = null,
    onNeverAskAgain: Fun? = null,
    requiresPermission: Fun
): PermissionsRequester

</code></pre>
<p><strong>注：设备位置权限的访问控制</strong><br>
用户可以更好地控制应用何时可以访问设备位置。当在Android Q上运行的应用程序请求位置访问时，会通过对话框的形式给用户进行授权提示。此对话框允许用户授予对两个不同范围的位置访问权限：在使用中（仅限前台）或始终（前台和后台）。<br>
新增权限 <code>ACCESS_BACKGROUND_LOCATION</code><br>
如果你的应用针对 <code>Android Q</code> 并且需要在后台运行时访问用户的位置，则必须在应用的清单文件中声明新权限</p>
<pre><code class="language-java">&lt;manifest&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;
&lt;/manifest&gt;
</code></pre>
<h2 id="2special-permissions特殊权限">2.Special Permissions——特殊权限</h2>
<blockquote>
<p>The library also provides <code>constructWriteSettingsPermissionRequest</code> and <code>constructSystemAlertWindowPermissionRequest</code> to support <code>WRITE_SETTINGS</code> and <code>SYSTEM_ALERT_WINDOW</code> that requires exceptional handling.<br>
该库还提供<code>constructWriteSettingsPermissionRequest</code>和 <code>constructSystemAlertWindowPermissionRequest</code>支持<code>WRITE_SETTINGS</code>，<code>SYSTEM_ALERT_WINDOW</code>这需要特殊处理。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructWriteSettingsPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester

 /**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructSystemAlertWindowPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester
</code></pre>
<hr>
]]></content>
    </entry>
</feed>