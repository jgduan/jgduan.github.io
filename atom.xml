<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-07-04T16:48:31.152Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 实现篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/">
        </link>
        <updated>2021-07-04T15:57:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">CSDN-谷歌开发者 打造 Material 颜色主题 | 实现篇</a><br>
<em>作者 / Nick Rout, Material Developer Advocate</em></p>
</blockquote>
<p>使用 Material 主题自定义 Material 组件，目的是让组件观感与品牌保持一致。Material 主题包括颜色、字体和形状参数，您可以对这些参数进行调整来获得近乎无限的组件变体，同时保持其核心结构和易用性。</p>
<ul>
<li>
<p>Material 主题<br>
https://material.io/design/material-theming/overview.html#material-theming</p>
</li>
<li>
<p>Material 组件<br>
https://material.io/components</p>
</li>
<li>
<p>Material 颜色<br>
https://material.io/design/color/</p>
</li>
<li>
<p>Material 字体<br>
https://material.io/design/typography/</p>
</li>
<li>
<p>Material 形状<br>
https://material.io/design/shape/<br>
<img src="https://jgduan.github.io//post-images/1625414383767.gif" alt="" loading="lazy"></p>
</li>
</ul>
<p>在 Android 上可使用 1.1.0 版本及以上的 Material 组件 (Material Design Components, MDC) 库来实现 Material 主题。如果您希望从 Design Support Library 或 MDC 1.0.0 迁移到新版本的 MDC，请参阅我们的迁移指南。</p>
<ul>
<li>
<p>Material 组件<br>
https://github.com/material-components/material-components-android</p>
</li>
<li>
<p>迁移指南<br>
https://medium.com/androiddevelopers/migrating-to-material-components-for-android-ec6757795351</p>
</li>
</ul>
<p>继上次我们发布<a href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">《打造 Material 颜色主题 | 设计篇》</a>之后，本文为大家介绍如何实现颜色主题。</p>
<hr>
<h2 id="颜色属性">颜色属性</h2>
<p>Material Design 提供可供填充的 12 个颜色 &quot;槽 (slots)&quot;，这些色值构成应用的整体调色板。每个 &quot;槽&quot; 都有一个设计术语 (如 Primary)，该术语则对应一个可在应用主题中覆盖的颜色属性 (如 Primary 这个术语对应 colorPrimary 这个颜色属性)。这些是您的浅色和深色主题默认的基准色值。</p>
<p><img src="https://jgduan.github.io//post-images/1625414532132.png" alt="" loading="lazy"><br>
△ 浅色主题的基准 MDC 颜色属性</p>
<p><img src="https://jgduan.github.io//post-images/1625414555733.png" alt="" loading="lazy"><br>
△ 深色主题的基准 MDC 颜色属性</p>
<p>Material 组件使用这些颜色属性为各个 widget 着色。<br>
<img src="https://jgduan.github.io//post-images/1625414580741.png" alt="" loading="lazy"><br>
△ 一个按钮中用到的颜色属性</p>
<p>例如，将颜色属性用于布局和 widget 样式中，写法如下所示:<br>
<code>app:backgroundTint=”?attr/colorSecondary”</code><br>
您可能会认得下表中的一些颜色属性，如 colorPrimary。这些因为一些颜色属性继承自 AppCompat 和平台本身，而其余属性则来由 MDC。每个颜色属性的完整来源见下表。<br>
<img src="https://jgduan.github.io//post-images/1625414617487.png" alt="" loading="lazy"></p>
<hr>
<h2 id="挑选颜色">挑选颜色</h2>
<p>主题里每个颜色槽应该使用的具体颜色值由设计师负责给出，或是取自您的产品品牌。但是，了解每个颜色的作用、颜色之间的关系以及如何满足无障碍功能要求仍非常有用:</p>
<ul>
<li>
<p>colorPrimary 和 colorSecondary 是用于呈现品牌的颜色</p>
</li>
<li>
<p>colorPrimaryVariant 和 colorSecondaryVariant 是品牌颜色较浅或较深的阴影色</p>
</li>
<li>
<p>colorSurface 用于表单或表面 (如卡片颜色和应用的底部弹出菜单颜色)</p>
</li>
<li>
<p>android:colorBackground 是应用的窗口背景颜色</p>
</li>
<li>
<p>顾名思义，colorError 用于错误和警告</p>
</li>
<li>
<p>各种各样的 &quot;On&quot; 颜色 (colorOnPrimary、colorOnSecondary、colorOnSurface 等) 用于<br>
为显示在其他颜色上方的前景内容 (如文本和图标) 进行着色。这些颜色需要满足无障碍功能要求并与所在表面的颜色有足够的对比度。</p>
</li>
</ul>
<hr>
<h2 id="颜色工具">颜色工具</h2>
<p>Material Design 为大家提供了丰富的工具，用于预览颜色、确定合适的变体颜色以及 &quot;On&quot; 颜色:</p>
<ul>
<li>
<p>Material 颜色工具: 获得主色和辅色的浅色/深色变体以及合适的 &quot;On&quot; 颜色。并能在示例界面中预览这些颜色的效果。<br>
https://material.io/resources/color/</p>
</li>
<li>
<p>Material 调色板生成器: 生成完整的色调调色板 (即包含 Material 色值编号 50 - 900)。另外您还能获得互补色、近似色和三等分配色的建议。<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625414775321.png" alt="" loading="lazy"><br>
△ Material 颜色工具 (左) 和 Material 调色板生成器 (右)</p>
<hr>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>除非您的品牌恰巧使用和基准 Material 主题色完全相同的紫色和蓝绿色，否则请您务必覆盖 colorPrimary、colorSecondary 及其变体色。</li>
<li>您无需覆盖所有颜色。一些颜色 (如 colorSurface) 默认使用的就是中性颜色，因此使用默认值不会有什么问题。</li>
<li>如果您的品牌没有定义任何种类的辅色或强调色，那么可以将一种颜色同时用于 colorPrimary 和 colorSecondary。变体色也可以和主色相同 (即 colorPrimary 和 colorPrimaryVariant 可以相同)。</li>
<li>一个颜色和其变体颜色以及 &quot;On&quot; 颜色尽管是三个单独的颜色属性 (如 colorPrimary、colorPrimaryVariant 和 colorOnPrimary)，但它们之间依然存在紧密的联系。因此如果您覆盖了其中一个，请检查其他颜色属性，以查看是否可行且满足无障碍功能要求。</li>
</ul>
<hr>
<h2 id="其他颜色槽">其他颜色槽</h2>
<p>除 Material 主题指定的 12 个颜色槽以外，您的设计系统可能还会用到其他颜色槽。幸运的是，在 Android 上声明颜色属性的操作很简单:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;attr name=&quot;colorCustom&quot; format=&quot;color&quot; /&gt;
 
&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.MaterialComponents.*&quot;&gt;
    ...
    &lt;item name=&quot;colorCustom&quot;&gt;@color/...&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="颜色资源">颜色资源</h2>
<p>颜色值会被定义为 <code>&lt;color&gt;</code> 资源。对于自定义颜色，我们建议使用以下两种方法，以帮助区分关注点，并在应用中为颜色主题中的色值创建单一来源:</p>
<ul>
<li>将浅色和深色主题用到的全部<code>&lt;color&gt;</code>存储在一个 res/values/colors.xml 文件中</li>
<li><code>&lt;color&gt;</code>色值使用字面名称命名 (而不是基于使用方式命名):
<ul>
<li>如此一来，便可以在使用颜色时更自然地用到 ?attr/ 语法。支持深色主题时也推荐采用此种方法</li>
<li>使用 green_500 或 brand_name_yellow 等名称</li>
<li>避免使用语义名称，如 color_primary<pre><code class="language-java">&lt;!-- In res/values/colors.xml --&gt;
&lt;color name=&quot;navy_500&quot;&gt;#64869B&lt;/color&gt;
&lt;color name=&quot;navy_700&quot;&gt;#37596D&lt;/color&gt;
&lt;color name=&quot;navy_900&quot;&gt;#073042&lt;/color&gt;
&lt;color name=&quot;green_300&quot;&gt;#3DDC84&lt;/color&gt;
&lt;color name=&quot;green_500&quot;&gt;#00A956&lt;/color&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="覆盖应用主题中的颜色">覆盖应用主题中的颜色</h2>
<p>让我们了解一下如何通过覆盖相关属性将您自己的调色板应用到主题中。</p>
<p>首先，您的主题需要在妥善处理浅色和深色调色板的同时减少与基础主题的重复。有关这方面的更多信息，请参阅 Chris Banes 关于深色主题的文章以及 Chris Banes 和 Nick Butcher 的 &quot;如何正确开发外观样式&quot; 演讲。</p>
<p>设置好主题后，覆盖您希望在浅色和深色主题中更改的颜色属性即可:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_700&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_900&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
 
 
&lt;!-- In res/values-night/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_500&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
</code></pre>
<p>Material 组件将根据主题全局应用您覆盖好的颜色:<br>
<img src="https://jgduan.github.io//post-images/1625415001473.gif" alt="" loading="lazy"></p>
<hr>
<h2 id="颜色复用性和最佳实践">颜色复用性和最佳实践</h2>
<p>在许多情况下，都要在布局、可绘制对象、样式和其他位置使用颜色。我们将介绍一些可尽量复用代码的方法，而且不会影响您在应用主题中指定的色值。</p>
<hr>
<h2 id="首选属性">首选属性</h2>
<p>我们强烈建议使用 ?attr/ 语法来设置颜色。在创建可复用的布局和支持多个模式 (如浅色/深色) 的默认样式时，尤其推荐使用这种语法。</p>
<pre><code class="language-java">&lt;Button
    ...
-    app:backgroundTint=&quot;@color/green_300&quot;
+    app:backgroundTint=&quot;?attr/colorPrimary&quot;
-    android:textColor=&quot;@color/black&quot;
+    android:textColor=&quot;?attr/colorOnPrimary&quot;
/&gt;
</code></pre>
<p>请参阅 Nick Butcher 的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce90bb7fb601dd9e144ae796eb466a2ed805bf14dbc0906543509d95c24733b05bd7fc12c&amp;idx=2&amp;mid=2652064078&amp;scene=21&amp;sn=884a85bfa4f9e19ec531b8245dca6314#wechat_redirect">《Android 样式系统 | 主题背景属性》</a>，以了解更多说明和此规则的一些例外情况。</p>
<hr>
<h2 id="带有-alpha-的颜色">带有 alpha 的颜色</h2>
<p>有时，您可能希望使用 MDC 主题中的一种颜色，但带上 alpha 值 (例如 60% 的 colorPrimary)。例如，触发点击时的波纹动画和项目被选中的状态。</p>
<p>Android<code>&lt;color&gt;</code>资源支持 alpha 通道:</p>
<pre><code class="language-java">&lt;!-- 60% alpha = 99 --&gt;
 
 
&lt;color name=”navy_700_alpha_60”&gt;#9937596D&lt;/color&gt;
</code></pre>
<p>但是，在使用此方法时，我们需要将每个带 alpha 的色值视作颜色资源。这也意味着我们不能用 ?attr/ 来使用这些颜色资源，因为这种做法违背了上文提及的唯一来源准则。</p>
<p>因此，我们建议使用 res/color 目录中存储的 ColorStateList (CSL)。CSL 里的项目可以包含一个颜色引用和 alpha 值，这非常适合我们的用例:</p>
<pre><code class="language-java">&lt;!-- In res/color/primary_60.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:alpha=&quot;0.6&quot; android:color=&quot;?attr/colorPrimary&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<p>使用这些 CSL (通过 @color/primary_60 语法进行引用) 可能会让您感到惊讶，但考虑到 CSL 本身也使用 ?attr/ 来引用底层的主题颜色，因此这样做不会有什么问题。</p>
<hr>
<h2 id="每种状态的颜色和主题叠加">每种状态的颜色和主题叠加</h2>
<p>更为常见的情况是根据视图状态使用 ColorStateList 切换颜色 (和 alpha 值)。MDC widget 大量将其用于禁用状态、悬停状态和按压状态等。比如下面是一个 MDC 按钮的背景色源代码:</p>
<pre><code class="language-java">&lt;!-- In button/res/color/mtrl_btn_bg_color_selector.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:color=&quot;?attr/colorPrimary&quot; android:state_enabled=&quot;true&quot; /&gt;
    &lt;item android:alpha=&quot;0.12&quot; android:color=&quot;?attr/colorOnSurface&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<ul>
<li>完整源代码<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/color/mtrl_btn_bg_color_selector.xml</li>
</ul>
<p>和上面这个按钮的示例类似，假设您希望将主背景色从主色改为辅色:<br>
<img src="https://jgduan.github.io//post-images/1625415175159.png" alt="" loading="lazy"><br>
△ 主色按钮 (左) 和辅色按钮 (右)</p>
<p>您当然可以将以上源文件复制一份，然后将 colorPrimary 改为 colorSecondary，但如果源代码恰巧发生更改，那么此操作会很繁琐且会出现问题。</p>
<p>一种更好的方式是使用主题叠加。Nick Butcher 在他的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf83fb7fb71294558ac5b10882278fb1f53ed3fd7038013c19d2554ff85e20b014fe9ac4b&amp;idx=1&amp;mid=2652067962&amp;scene=21&amp;sn=71a1bc1726c40ccda245f366ae4a51bb#wechat_redirect">《Android 样式系统 | 主题背景覆盖》</a>一文中对此有详细的介绍。基本上，我们可以替换 View 或 ViewGroup 的主题属性值 (在我们例子中为 colorPrimary) 以及所有依赖它的项目 (在我们的例子中为按钮)。</p>
<p>下面是一个主题叠加的简单例子。请注意 parent 为空，其作用是确保我们仅覆盖希望更改的属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;ThemeOverlay.App.PrimarySecondary&quot; parent=&quot;&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;?attr/colorSecondary&lt;/item&gt;
    &lt;item name=&quot;colorOnPrimary&quot;&gt;?attr/colorOnSecondary&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在 XML 中应用主题叠加时，应考虑两个选项:</p>
<ul>
<li>android:theme - 用于所有 widget，不会以默认样式工作</li>
<li>app:materialThemeOverlay - 仅用于 MDC widget，以默认样式工作</li>
</ul>
<pre><code class="language-java">&lt;Button
    ...
    &lt;!-- Alternatively apply with android:theme --&gt;
+    app:materialThemeOverlay=&quot;@style/ThemeOverlay.App.PrimarySecondary&quot;
/&gt;
</code></pre>
<hr>
<h2 id="api-兼容性">API 兼容性</h2>
<p>平台是在 API 23 才开始在 CSL 等处增加对 ?attr/ 语法的支持。如果您的 minSdk 是更早的版本，也不要担心: 有兼容性类！事实上，MDC 和 AppCompat widget 都有在底层使用这些兼容性类，因此在使用时无需其他操作。</p>
<p>对于需要以编程方式使用 CSL 的场景，请使用 AppCompatResources:</p>
<pre><code class="language-java">val primary60 = AppCompatResources#getColorStateList(
    context, R.color.primary60
)
</code></pre>
<ul>
<li>AppCompatResources<br>
https://developer.android.google.cn/reference/androidx/appcompat/content/res/AppCompatResources</li>
</ul>
<hr>
<h2 id="mdc-widget-中的颜色">MDC widget 中的颜色</h2>
<p>之前我们曾说过，MDC widget 会响应主题级别的颜色属性覆盖。但是，您是如何知道按钮会将 colorPrimary 用作其背景着色并将 colorOnPrimary 用于其图标和文本呢？让我们来看一下几个选项。</p>
<hr>
<h2 id="构建-material-主题">构建 Material 主题</h2>
<p>构建 Material 主题是一个交互式 Android 项目，支持您通过自定义颜色、字体和形状来创建自己的 Material 主题。项目还包含所有主题中用到的参数和组件的目录。可通过执行以下操作确定哪些 widget 会对主题颜色属性的更改作出响应:</p>
<ul>
<li>
<p>复制这个项目并在 Android Studio 中运行应用</p>
</li>
<li>
<p>调整 res/values/color.xml 以及 res/values/themes.xml 和 res/values-night/themes.xml 中的色值</p>
</li>
<li>
<p>重新运行应用，观察视觉变化</p>
</li>
<li>
<p>构建 Material 主题<br>
https://material.io/resources/build-a-material-theme</p>
</li>
<li>
<p>项目源代码<br>
https://github.com/material-components/material-components-android-examples/tree/develop/MaterialThemeBuilder</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415351635.png" alt="" loading="lazy"><br>
△ 构建 Material 主题中的色值变化</p>
<hr>
<h2 id="mdc-开发者文档">MDC 开发者文档</h2>
<p>最近我们更新了 MDC 开发者文档。在本次更新中，我们加入了属性表，涵盖了开发库中所使用的设计术语和默认值。例如下面是更新的按钮文档的 &quot;Anatomy and key properties&quot; (详解和关键属性) 部分。<br>
<img src="https://jgduan.github.io//post-images/1625415378990.png" alt="" loading="lazy"><br>
△ MDC 按钮开发文档的属性表中提供了默认色值</p>
<ul>
<li>按钮文档<br>
https://github.com/material-components/material-components-android/blob/master/docs/components/Button.md</li>
</ul>
<hr>
<h2 id="源代码">源代码</h2>
<ul>
<li>
<p>MaterialButton 样式<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/styles.xml</p>
</li>
<li>
<p>MaterialButton 属性<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/attrs.xml</p>
</li>
<li>
<p>MaterialButton 源文件<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/MaterialButton.java</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415449219.png" alt="" loading="lazy"><br>
△ MDC 按钮的默认样式和色值</p>
<hr>
<h2 id="自定义视图中的颜色">自定义视图中的颜色</h2>
<p>您的应用可能包含您自己构建或从现有库中获得的自定义 widget。在和 MDC 一起使用时，使这些视图对 Material 主题作出响应非常必要。让我们看一看在将颜色主题用于自定义 widget 时需要牢记的事项。</p>
<p>在<code>&lt;declare-styleable&gt;</code>和默认样式中使用 MDC 属性</p>
<p>为自定义视图设置样式需要使用<code>&lt;declare-styleable&gt;</code>。在保持一致性方面，复用 MDC 中的属性名称非常有用。使用<code>&lt;declare-styleable&gt;</code>的默认样式还可以使用 MDC 主题颜色属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;declare-styleable name=&quot;AppCustomView&quot;&gt;
    &lt;attr name=&quot;backgroundTint&quot; /&gt;
    &lt;attr name=&quot;titleTextColor&quot; /&gt;
    ...
&lt;/declare-styleable&gt;
 
 
&lt;!-- In res/values/styles.xml --&gt;
&lt;style name=&quot;Widget.App.CustomView&quot; parent=&quot;android:Widget&quot;&gt;
    &lt;item name=&quot;backgroundTint&quot;&gt;?attr/colorSurface&lt;/item&gt;
    &lt;item name=&quot;titleTextColor&quot;&gt;
        @color/material_on_surface_emphasis_high_type
    &lt;/item&gt;
    ...
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="materialcolors-实用程序类">MaterialColors 实用程序类</h2>
<p>可以通过便利的新 MDC 类 (MaterialColors) 以编程方式处理主题的颜色属性，这对于自定义视图也非常有用:</p>
<pre><code class="language-java">// Resolve color from theme attr
val primaryColor = MaterialColors.getColor(
    view, R.attr.colorPrimary
)
 
 
// Layer background color with overlay color + alpha
val overlayedColor = MaterialColors.layer(
    view, R.attr.colorSurface, R.attr.colorPrimary, 0.38f
)
</code></pre>
<hr>
<h2 id="下一步">下一步</h2>
<p>现在，我们已经在 Android 应用中使用 MDC 实现了颜色主题。有关 Material 主题的其他课题，请阅读我们相关的介绍文章。</p>
<ul>
<li>
<p>为什么推荐使用 MDC<br>
https://medium.com/androiddevelopers/we-recommend-material-design-components-81e6d165c2dd</p>
</li>
<li>
<p>字体主题<br>
https://material.io/blog/android-material-theme-type</p>
</li>
<li>
<p>形状主题<br>
https://material.io/blog/android-material-theme-shape</p>
</li>
<li>
<p>深色主题<br>
https://medium.com/androiddevelopers/dark-theme-with-mdc-4c6fc357d956</p>
</li>
<li>
<p>动效系统<br>
https://material.io/blog/android-material-motion</p>
</li>
</ul>
<p>我们一如既往地期待您在 GitHub 上提交错误报告和功能需求。另外，请务必查看 Android 组件示例应用。</p>
<ul>
<li>
<p>提交错误报告<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md&amp;title=%5BComponent+name%5D+Short+description+of+issue</p>
</li>
<li>
<p>提交功能需求<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=feature+request&amp;template=feature_request.md&amp;title=%5BComponent+name%5D+Short+description+of+request</p>
</li>
<li>
<p>Android 组件示例应用<br>
https://github.com/material-components/material-components-android-examples</p>
</li>
</ul>
<p>如果您已成功实现颜色主题或您在实现期间遇到问题，欢迎在下方评论区和我们分享。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 设计篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">
        </link>
        <updated>2021-07-01T15:02:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109475532">CSDN-谷歌开发者 打造 Material 颜色主题 | 设计篇</a><br>
<em>作者 / Liam Spradlin, Material Design Advocate</em></p>
</blockquote>
<p>颜色是设计中最清晰的表现形式之一，尤其是当您需要在人们的各种活动场合中传播您的品牌或产品形象时。应用的界面可容纳丰富的颜色，不仅可以用于打造产品形象，而且由于用户可以直接触摸和操作界面，因此在传播产品形象的同时又能与用户的生活和体验紧密联系，并增强产品的功能、实用性和个性。</p>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwODY4OTk2Mg%3D%3D&amp;action=getalbum&amp;album_id=1340817101657014273#wechat_redirect">Material Design</a> 包含全面的颜色系统，可以让设计师和开发者制定全局颜色决策，并能够有效管理界面状态、强调重点和对比度等问题，使这些颜色决策贯穿于产品的各个层级。</p>
<hr>
<h1 id="material-中的颜色">Material 中的颜色</h1>
<p>为了实现上述目标，Material 使用一组定义好的颜色取值，构成 &quot;颜色主题&quot;。颜色主题包含主要 (Primary) 颜色和次要 (Secondary) 颜色，它们可用于关键组件，另外还包含用于自定义背景 (Background) 色、表面 (Surface) 颜色 (用于呈现抬升的表面或 &quot;纸张&quot;) 和错误 (Error) 颜色的色值。<br>
<img src="https://jgduan.github.io//post-images/1625152307401.png" alt="基准 Material 颜色主题" loading="lazy"><br>
△ 基准 Material 颜色主题</p>
<p>还有一些色值用于 &quot;On&quot; 颜色，顾名思义，它们是出现在其他元素上方的颜色。例如，On Primary 可用于呈现在应用的主要颜色上方显示的文本、图标或其他元素。比如下图展示了带有菜单图标和标题的应用栏，其中的图表和文字都使用 &quot;On&quot; 颜色来确保内容具备适当的对比度和可读性。<br>
<img src="https://jgduan.github.io//post-images/1625152360593.png" alt="" loading="lazy"></p>
<p>对于诸如状态等更加细微的颜色使用场景，Material 使用 &quot;色调调色板&quot;。色调调色板会基于您所选择的颜色提供一组十个值，提供了减淡和加深的选项，可使您的颜色主题更加灵活。<br>
<img src="https://jgduan.github.io//post-images/1625152382453.png" alt="" loading="lazy"></p>
<p>△ 上图中的界面使用主要颜色以及两个主要颜色变体，并应用到所有组件中</p>
<hr>
<h1 id="选择品牌颜色">选择品牌颜色</h1>
<h2 id="从头开始">从头开始</h2>
<p>如果您要从头开始构建颜色主题，也就是说如果您没有现成的品牌调色板，那么最好先充分思考您应用的特质。在我们的 Material Studies 专栏 (基于现实用例和产品约束设计的示例应用) 中，您可以看到根据各种应用的功能和个性所采用的多种基于颜色的品牌化方案。</p>
<ul>
<li>
<p>Material Studies<br>
https://material.io/design/material-studies/about-our-material-studies.html</p>
<p>您的应用是否像暗色调的个人理财应用 Rally 一样，是一款可以帮助人们高效解析信息的实用工具？是否像现代而精致的购物应用 Shrine 一样，能够以精致的美学和粉红色调激发用户的兴趣？或者，也许像教育应用 Owl 一样，能够通过生动的配色来提供更加有趣的教学体验。在每个用例中，颜色在打造和增强应用的个性方面都起着重要作用。<br>
<img src="https://jgduan.github.io//post-images/1625152528876.png" alt="" loading="lazy"><br>
△ Rally 的每个信息图表都使用了两种取自其颜色主题的颜色</p>
<p>对于像 Rally 这样的应用而言，其功能旨在查看和管理个人财务数据，因此必须选用一种深沉的配色方案。该应用的主要颜色为绿色，On 颜色为白色，背景色则为深灰色调。其他颜色均极为深沉，用于在各种信息展示界面中以实用的方式呈现数据。</p>
</li>
<li>
<p>Rally<br>
https://material.io/design/material-studies/rally.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152585442.png" alt="" loading="lazy"><br>
△ Owl 使用三种颜色主题来区分应用中的不同部分</p>
<p>与 Rally 截然相反，Owl 通过在其颜色主题中使用三种不同的主要颜色，打造出鲜活有趣的使用氛围。尽管 Owl 事实上可以被视为在同一个应用中采用了三种不同的颜色主题，但这些颜色却因生动鲜明的共同特征而紧密关联 (它们各自趋近色轮中的三原色: 红、黄、蓝)。</p>
</li>
<li>
<p>Owl<br>
https://material.io/design/material-studies/owl.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152619523.png" alt="" loading="lazy"><br>
△ Shrine 在关健组件和版面设计中采用了简单的颜色主题</p>
<p>Shrine 则介于以上两款应用之间。这款应用具有个性鲜明的色彩表现，使用奶油粉色调作为主要颜色和次要颜色，并使用深棕色作为 On 颜色。虽然 Shrine 的调色板十分独特，但在应用中以专注而精致的方式应用这种色调，能够体现出 Shrine 想要展现的个性形象，打造出一个现代而优雅的时尚和生活购物助手。</p>
</li>
<li>
<p>Shrine<br>
https://material.io/design/material-studies/shrine.html</p>
<p>从头开始制作自己的主题时，请考虑您的应用在上述示例所覆盖的范围中所处的位置。首先，请选择一种能够最贴切地表达应用个性和用途的主要颜色。然后，根据您对应用观感的设想，选择可以增强或调节这些特质的次要颜色。请考虑如何使用 On 颜色，或对表面或背景应用新的颜色以增强表现力。</p>
</li>
</ul>
<h2 id="如果您已有品牌调色板">如果您已有品牌调色板</h2>
<p>在为您的应用构建颜色主题时，您可能已经具有可以轻松转换为 Material 颜色主题的品牌调色板。这种情况下，您可能已经拥有品牌指南，其中涵盖了应优先考虑的颜色以及如何概念化品牌个性或色调方面的内容。您可以将指南内容与前文提到的信息相结合，确定要在颜色主题中包含哪些颜色。</p>
<p>如果您已有品牌调色板但没有指南，请浏览现有的品牌物料或界面设计，然后与调色板进行对比，确定应优先考虑采用哪些颜色作为主要颜色和次要颜色。测试这些颜色以确定它们是否能带来方便阅读的对比度。如果效果不佳，您可以从色调调色板中选择效果理想的颜色变体。</p>
<ul>
<li>测试颜色<br>
https://material.io/tools/color</li>
</ul>
<h2 id="使用调色板生成器扩展调色板">使用调色板生成器扩展调色板</h2>
<p>基于确定下来的几种颜色，可以使用调色板生成器对颜色取值进行扩展，从而满足更多场合的需求。只需在生成器右侧添加所选颜色，然后点击每个生成的色样即可复制其十六进制色值。</p>
<ul>
<li>
<p>调色板生成器<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625152728551.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="呈现主题">呈现主题</h2>
<p>选择一些颜色并将其扩展为色调调色板后，您就可以通过将颜色代入到 Material Design 提供的色谱中来实际创建颜色主题了。</p>
<ul>
<li>
<p>色调调色板<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<p>要在设计工具中进行此操作 (并在 Material Components 上获得主题的即时预览)，请下载我们的 Figma 基准设计工具包。在工具包内的 Material Theme 页面中，您将看到一个名为 Color 的框架，该框架全面展示了您的颜色主题，包括了色调调色板。</p>
</li>
<li>
<p>Figma 基准设计工具包<br>
https://www.figma.com/@materialdesign</p>
<figure data-type="image" tabindex="2"><img src="https://jgduan.github.io//post-images/1625152787143.png" alt="" loading="lazy"></figure>
<p>在上图右侧，您会看到一个面板，在 Color Styles 下方包含了与主题中的颜色相符的全局样式。要开始将颜色插入到主题中，请点击每种颜色样式旁边的编辑图标。返回到生成器中的色调调色板，然后点击工具中的每个色样以复制其十六进制色值，然后将其输入到 Figma 中您选择的样式中。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://jgduan.github.io//post-images/1625152807417.png" alt="" loading="lazy"></figure>
<p>当主要颜色和次要颜色的色样处理完成后，请查看 Figma 界面左边的 Stickersheet 页面以查看主题在每个组件上的显示效果。</p>
<hr>
<h1 id="下一步-实现">下一步: 实现</h1>
<p>完成了上述操作后，您还可以尝试调整表面、背景和错误颜色来优化这个全新的颜色主题。您也可以尝试通过创建多个主题 (例如上文中的 Owl 示例) 来利用颜色系统实现更多创意。</p>
<p>在创建出完美的颜色主题后，您就可以准备实现它了。请大家关注我们接下来会发布的文章<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">《打造 Material 颜色主题 | 实现篇》</a>。</p>
<hr>
<h1 id="推荐阅读">推荐阅读</h1>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf031b7fb79276e6792f13b342073c99a0b8118a9bb2b6b995a5cad6fa57dc58b55993e07&amp;idx=1&amp;mid=2652065908&amp;scene=21&amp;sn=8af70145ec89870c138818a38f005ed0#wechat_redirect">跨设备设计基础 | 如何确定任意屏幕的分辨率指标</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cec31b7fb65275fa39b276c69cf670cfcd8f2395b532953c27bb48d368fe40638a225d4f1&amp;idx=1&amp;mid=2652064884&amp;scene=21&amp;sn=e407e1d047f415309b7b120e1265ce9c#wechat_redirect">使用 Material Design 组件实现深色主题</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce8fbb7fb61ede45fa93a0d8d5464935f48f28601f2db5d5ea8d60863fe2392f2361cffae&amp;idx=1&amp;mid=2652063934&amp;scene=21&amp;sn=caeaec14e70b7569c06503b1bb04138b#wechat_redirect">Android Material 组件 1.2.0 现已发布</a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Jetpack之Room]]></title>
        <id>https://jgduan.github.io/post/android-jetpack-zhi-room/</id>
        <link href="https://jgduan.github.io/post/android-jetpack-zhi-room/">
        </link>
        <updated>2021-06-29T14:50:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。</p>
<hr>
<h1 id="声明依赖-引入room到项目中">声明依赖--引入Room到项目中</h1>
<p>在添加Room依赖前，我们需要在Project的<code>build.gradle</code>中，添加Google Maven代码库到项目中，示例如下：</p>
<pre><code class="language-java">allprojects {
    repositories {
        google()

        // 如果您使用的Gradle版本低于4.1，则必须使用：
        // maven {
        //     url 'https://maven.google.com'
        // }
        // 另一个URL是 'https://dl.google.com/dl/android/maven2/'
    }
}
</code></pre>
<p>在app或者使用Room的Module的<code>build.gradle</code>文件中，我这里添加了以下以代码来使用Room：</p>
<pre><code class="language-java">dependencies {
    def room_version = &quot;2.3.0&quot;

    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)
    annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;

    // To use Kotlin annotation processing tool (kapt) --使用Kotlin注释处理工具
    kapt(&quot;androidx.room:room-compiler:$room_version&quot;)

    // optional - Kotlin Extensions and Coroutines support for Room--可选项，在Room上Kotlin扩展和协程
    implementation(&quot;androidx.room:room-ktx:$room_version&quot;)

    // optional - RxJava3 support for Room--可选项，Room RxJava3支持
    implementation &quot;androidx.room:room-rxjava3:$room_version&quot;
}
</code></pre>
<hr>
<h1 id="room库分析">Room库分析</h1>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li>
<p><strong>数据库：</strong> 包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。<br>
使用<code>@Database</code>注释的类应满足以下条件：</p>
<ul>
<li>
<p>是扩展<code>RoomDatabase</code>的抽象类。</p>
</li>
<li>
<p>在注释中添加与数据库关联的实体列表。</p>
</li>
<li>
<p>包含具有 0 个参数且返回使用<code>@Dao</code>注释的类的抽象方法。</p>
</li>
</ul>
<p>在运行时，您可以通过调用<code>Room.databaseBuilder()</code>或<code>Room.inMemoryDatabaseBuilder()</code>获取 Database 的实例。</p>
</li>
<li>
<p><strong>Entity：</strong> 表示数据库中的表。</p>
</li>
<li>
<p><strong>DAO：</strong> 包含用于访问数据库的方法。</p>
</li>
</ul>
<p>应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。</p>
<p>Room 不同组件之间的关系如图 1 所示：<br>
<img src="https://developer.android.google.cn/images/training/data-storage/room_architecture.png" alt="" loading="lazy"></p>
<hr>
<h1 id="room使用示例">Room使用示例</h1>
<h2 id="新建一个实体类user">新建一个实体类User</h2>
<pre><code class="language-java">@Entity
data class User(
    @PrimaryKey val uid: Int,
    @ColumnInfo(name = &quot;first_name&quot;) val firstName: String?,
    @ColumnInfo(name = &quot;last_name&quot;) val lastName: String?
)
</code></pre>
<h2 id="新建一个dao类">新建一个DAO类</h2>
<pre><code class="language-java">@Dao
interface UserDao {
    @Query(&quot;SELECT * FROM user&quot;)
    fun getAll(): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)
    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; +
            &quot;last_name LIKE :last LIMIT 1&quot;)
    fun findByName(first: String, last: String): User

    @Insert
    fun insertAll(vararg users: User)

    @Delete
    fun delete(user: User)
}
</code></pre>
<h2 id="新建一个appdatabase类继承roomdatabase">新建一个AppDatabase类继承RoomDatabase</h2>
<pre><code class="language-java">@Database(entities = arrayOf(User::class), version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
</code></pre>
<h2 id="数据库的使用">数据库的使用</h2>
<blockquote>
<p>创建完上述文件后，您可以使用以下代码获取已创建的数据库的实例了：</p>
</blockquote>
<pre><code class="language-java">val db = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java, &quot;database-name&quot;
        ).build()
</code></pre>
<blockquote>
<p>注意：如果您的应用在单个进程中运行，在实例化 AppDatabase 对象时应遵循单例设计模式。每个 RoomDatabase 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。</p>
</blockquote>
<blockquote>
<p>如果您的应用在多个进程中运行，请在数据库构建器调用中包含 <code>enableMultiInstanceInvalidation()</code>。这样，如果您在每个进程中都有一个 AppDatabase 实例，可以在一个进程中使共享数据库文件失效，并且这种失效会自动传播到其他进程中 AppDatabase 的实例。</p>
</blockquote>
<hr>
<blockquote>
<p>主要内容源自<a href="https://developer.android.google.cn/training/data-storage/room">官方开发者文档Room操作指南</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】应用加固、混淆分析解读]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/">
        </link>
        <updated>2021-06-29T14:30:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>当我们准备发布一个App版本时，出于对App安全性的考虑，我们一般会选择对代码进行混淆、对打包后的apk文件进行加固操作，其目的就是为了防止app被恶意破解，增加破解难度来提高应用安全性。</p>
<h2 id="代码混淆">代码混淆</h2>
<p>代码混淆是一种常用的加密方式，它通过开启代码混淆开关、配置本地文件，对项目打包后的代码进行加密混淆（混淆的原理实际上就是对原来有具体含义的包名,类名,变量名,方法名等名称全部替换成按顺序排列的无意义的英文字母，如：a,b,c等）。</p>
<blockquote>
<p>proguard-rules.pro文件是给Library模块自己使用的混淆规则；<br>
consumer-rules.pro文件则是会合并到app的混淆规则中，是给包括app在内的其他模块调用时使用的混淆规则；<br>
而这两个文件，完全可以使用同一个文件进行配置；当需要进行区分时，可以使用两个不同的文件进行配置；根据项目需求选择所需即可。</p>
</blockquote>
<h2 id="应用加固">应用加固</h2>
<blockquote>
<p>一个apk文件，当我们把它后缀名修改为.zip时（后续我会追加一篇应用打包过程的文章，来描述apk到底是如何生成的，它包含哪些元素），可以找到classes.dex文件，这个文件包含了我们项目的<strong>主要源代码</strong>，通过反编译工具（如dex2jar等），我们可以轻松的拿到对应的源文件jar包并查看源代码。</p>
</blockquote>
<p>应用加固是指，通过对dex文件的的加密、拼接加壳操作，来有效的对项目代码进行保护，防止通过上述方法来拿到dex文件进行反编译。</p>
<p>当apk被安装后，app启动时会有dex的解密过程，然后系统会重新加载解密后的dex文件。</p>
<hr>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<p><a href="https://blog.csdn.net/weixin_45443931/article/details/98869613">浅谈安卓apk加固原理和实现</a><br>
<a href="https://blog.csdn.net/qq_33232521/article/details/114919455">android 混淆 minifyEnabled proguard-rules.pro consumer-rules.pro</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1忽略build文件夹后找不到BuildConfig]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/">
        </link>
        <updated>2021-06-28T15:14:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在Android Studio版本升级到4.1+后，新建了一个项目并在<code>build.gradle</code>文件中配置了<code>buildConfigField-http/log</code>等相关公共字段的配置并同步，然后因要关联至SVN，便修改了项目中的忽略配置以避免上传部分不需要提交的文件内容，具体配置如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628170410668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="忽略配置" loading="lazy"><br>
配置完毕后，当打开使用到<code>BuildConfig</code>文件的类时，发现编辑器报错并提示找不到该文件，具体如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628171128972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="buildConfig" loading="lazy"></p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>刚碰到该问题，第一时间怀疑是<strong>相关文件未构建成功</strong>，多次<code>Build-&gt;ReBuild Project</code>都毫无作用。</p>
<p>后来想到对应Module的<code>build</code>目录下去查看是否已生成文件（BuildConfig默认的生成在<code>xx/ProjectName/ModuleName/build/generated/source/buildConfig/buildTypes(debug/release/xxx/包名、)</code>目录下），发现在Project预览模式下，无法找到build文件。</p>
<p>最后各种尝试后，定位到可能是因为忽略文件配置导致Project无法预览build文件目录下的内容，导致编辑器报错找不到文件，<strong>直接取消setting-&gt;Editor-&gt;File Types-&gt;.gitignore中的build文件夹的忽略配置即可</strong>。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava3实现倒计时功能]]></title>
        <id>https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/</id>
        <link href="https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/">
        </link>
        <updated>2021-06-28T14:52:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-导入rxjava3">一、导入RxJava3</h1>
<p>在需要使用RxJava的Module中，打开<code>build.gradle</code>文件在<code>dependencies</code>标签内添加如下代码引入RxJava：</p>
<pre><code class="language-java">implementation &quot;io.reactivex.rxjava3:rxjava:3.0.6&quot;
implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
</code></pre>
<hr>
<h1 id="二-倒计时实现">二、倒计时实现</h1>
<ul>
<li><strong>使用<code>intervalRange</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">/**
 * start：开始的数值
 * count：输出值的个数（执行几次）
 * initialDelay：延迟多久执行
 * period：间隔多久执行一次
 * TimeUnit：延迟/间隔数值单位，NANOSECONDS（纳秒），MICROSECONDS（微秒），MILLISECONDS（毫秒），
 * SECONDS（秒），MINUTES（分钟），HOURS（小时），DAYS（天）
 */
Observable.intervalRange(0, 1, 5, 0, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnComplete {
        LogUtil.e(TAG,&quot;start to MainActivity...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }.subscribe()
</code></pre>
<ul>
<li><strong>使用<code>timer</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">// 延时1s进入MainActivity
Observable.timer(1, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe {
        LogUtil.e(TAG,&quot;start to MainActivity2...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】创建签名提示“迁移到行业标准格式PKCS12”问题]]></title>
        <id>https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/">
        </link>
        <updated>2021-06-28T14:21:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>Android Studio新建项目签名时创建签名文件时，提示“迁移到行业标准格式PKCS12”。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>在Android Studio上，通过命令行创建签名文件。</p>
<ol>
<li>输入以下命令：</li>
</ol>
<pre><code class="language-java">keytool -genkey -alias 这里替换成你的应用别名 -keypass 这里填写你的别名密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore 签名文件的存储路径\你得项目名称\app\xxx.jks -storepass 你的签名密码
</code></pre>
<p>你需要修改以下四处：</p>
<ul>
<li>应用别名（alias）</li>
<li>别名密码（alias password）</li>
<li>签名文件保存的路径（全路径，如：D:/TestProject/app/test.jks）</li>
<li>签名密码</li>
</ul>
<ol start="2">
<li>第1步完成后，回车，然后填写签名作者相关信息</li>
</ol>
<pre><code class="language-java">您的名字与姓氏是什么?
  [Unknown]:  zihao
您的组织单位名称是什么?
  [Unknown]:  xxxx
您的组织名称是什么?
  [Unknown]:  xxxx
您所在的城市或区域名称是什么?
  [Unknown]:  HeFei
您所在的省/市/自治区名称是什么?
  [Unknown]:  AnHui
该单位的双字母国家/地区代码是什么?
  [Unknown]:  0086
CN=zihao, OU=xxxx, O=xxxx L=HeFei, ST=AnHui, C=0086是否正确?
  [否]:  y
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【DOHENES】基于Kotlin的v3.0架构规范]]></title>
        <id>https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/</id>
        <link href="https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/">
        </link>
        <updated>2021-06-25T14:17:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>项目采用了<code>MVVM</code>架构方式+组件化方案+<code>Jetpack</code>常用库，基于<code>Kotlin 1.4.32</code>编译版本，在个别<code>Module</code>的部分区域混合使用了<code>Java（Java 8版本）</code>来进行开发工作，具体使用的三方库及其使用方法、示例将在文末进行讲解。</p>
<hr>
<h1 id="一-架构模式-mvvm">一、架构模式-MVVM</h1>
<p>项目采用<code>MVVM</code>架构模式，这里通过<code>Jetpack</code>的<code>ViewModel</code>组件来更换传统的<code>ViewModel</code>。</p>
<p><a href="https://www.jianshu.com/p/449136bddff6">Android MVVM 模式</a></p>
<hr>
<h1 id="二-project-组件化">二、Project-组件化</h1>
<p>为了各个功能模块之间解耦、<code>Module</code>灵活组合编译运行，便于团队协作开发及后期维护，3.0版本架构在多<code>Module</code>的基础上，采用了组件化方案来进一步优化项目架构。</p>
<ul>
<li>
<p><strong>模块解耦</strong><br>
项目采用组件化方案进行模块的<strong>解耦</strong>处理。</p>
</li>
<li>
<p><strong>组件分类及命名规范</strong><br>
整体架构分层与v2.0版本类似，除了最上层的<code>base、common</code>两大Library基础库，功能成分库继续采用<code>component-xxx</code>来进行命名，包含界面、具体业务逻辑的Library继续用<code>module-xxx</code>进行命名。</p>
</li>
</ul>
<blockquote>
<p>具体可参考<a href="https://jgduan.github.io/post/dohenes-tb-gai-ban-v20-zheng-ti-jia-gou-gui-fan/">【DOHENES】TB改版v2.0整体架构规范</a></p>
</blockquote>
<ul>
<li>
<p><strong>统一的引用配置</strong><br>
为保持引用库版本一致，规避开发过程中不必要的冲突。项目中通过Project根目录下的<code>config.gradle</code>文件，定义通用的构建元素字段，供各个模块进行引用。</p>
</li>
<li>
<p><strong>独立编译运行</strong><br>
发挥组件化方案的优势，通过在<code>config.gradle</code>中配置对应控制变量对各<code>moudle</code>进行<code>library-&gt;application</code>的灵活控制，让<code>module</code>既可以独立编译运行，又可以集成编译，按需灵活配置，方便开发人员协作。</p>
</li>
</ul>
<hr>
<h1 id="三-屏幕分辨率适配">三、屏幕（分辨率适配）</h1>
<p>依据实际的<code>UI</code>设计图，我们以<code>sw-375dp</code>为基准进行屏幕的适配工作，相应适配文件存放于<code>base-&gt;res/values、values-swxxxdp/measure.xml</code>内。<br>
在实际开发中根据UI设计图尺寸直接设置对应控件的尺寸即可（<code>@dimen/common_measure_xxxdp</code>），具体使用示例如下：</p>
<pre><code class="language-java">// 在需要使用地方添加对应的尺寸
android:layout_height=&quot;@dimen/common_measure_xxxdp&quot;
</code></pre>
<hr>
<h1 id="四-数据存储">四、数据存储</h1>
<ul>
<li>
<p><strong>ROOM</strong><br>
<a href="https://blog.csdn.net/yu540135101/article/details/110670477">Android kotlin+协程+Room数据库的简单使用</a><br>
<a href="https://www.jianshu.com/p/0dde643ac045">Android Room的简单使用</a></p>
</li>
<li>
<p><strong>DataStore</strong></p>
</li>
<li>
<p><strong>Native Files</strong><br>
当我们在开发过程涉及到一些需要缓存的文件时，很多应用采取的策略是到<code>SD卡</code>的根目录上创建自己的文件夹然后保存到对应的文件路径下（之前的泰邦设计也是这样做的），虽然达到了缓存文件的目的，但它并不被Android所推荐——当应用卸载后，这些被创建的文件夹仍然存在，造成手机内多出了不少的垃圾文件，这样是极不友好的。<br>
Android建议我们在缓存文件时使用应用专属（这里又分内部存储与外部存储，建议是尽可能使用外部存储进行缓存）的缓存路径进行文件的缓存，当应用被卸载后，这些数据也会随之而消失，从而规避了上述问题。<br>
关于应用专属内、外部存储的更多了解，建议阅读以下文章或自行了解后再进行相关的操作：<br>
<a href="https://blog.csdn.net/s13383754499/article/details/82910704">彻底搞懂Android文件存储---内部存储，外部存储以及各种存储路径解惑</a><br>
<a href="https://www.jianshu.com/p/b752b2e70b8c">Android文件缓存目录</a><br>
重点关注：getExternalCacheDir、getExternalFilesDir。</p>
</li>
</ul>
<hr>
<h1 id="五-kotlin">五、Kotlin</h1>
<ul>
<li>
<p><strong>协程</strong><br>
<a href="https://www.jianshu.com/p/6e6835573a9c">Kotlin协程</a></p>
</li>
<li>
<p><strong>不再使用findViewById</strong><br>
在Module的build.gradle中加上：<code>apply plugin: 'kotlin-android-extensions'</code>，然后就可以直接使用布局中定义的id去访问对应的控件了。</p>
</li>
</ul>
<blockquote>
<p>在使用的时候，你会发现导入的包是<code>import kotlinx.android.synthetic.main.activity_main.*</code>(如layout名称为activity_main.xml)</p>
</blockquote>
<hr>
<h1 id="六-项目中三方库使用规范及示例">六、项目中三方库使用规范及示例</h1>
<ul>
<li>
<p><strong>ARouter——路由</strong></p>
<ul>
<li>概述<br>
一款阿里开源的路由框架，是一个帮助Android进行模块化、组件化开发的开源库。它支持模块间的路由、通信、解耦。</li>
<li>引入
<ul>
<li>添加依赖和配置<pre><code class="language-java">android {
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile 'com.alibaba:arouter-api:x.x.x'
    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'
    ...
}
// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'
// Kotlin配置参考文末'其他#5'

</code></pre>
<blockquote>
<p>所有使用ARouter的Module都必须在<code>build.gradle</code>中<code>dependencies</code>标签内添加<code>annotationProcessor 'com.alibaba:arouter-compiler:x.x.x</code>注释处理器。</p>
</blockquote>
</li>
<li>添加注解<pre><code class="language-java">// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = &quot;/test/activity&quot;)
public class YourActivity extend Activity {
    ...
}
</code></pre>
</li>
<li>初始化SDK<pre><code class="language-java">if (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
}
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化

</code></pre>
</li>
<li>发起路由操作<pre><code class="language-java">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build(&quot;/test/1&quot;)
            .withLong(&quot;key1&quot;, 666L)
            .withString(&quot;key3&quot;, &quot;888&quot;)
            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))
            .navigation();

</code></pre>
</li>
<li>使用 Gradle 插件实现路由表的自动加载 (可选)<pre><code class="language-java">apply plugin: 'com.alibaba.arouter'

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath &quot;com.alibaba:arouter-register:?&quot;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>使用规范<br>
在开发过程中，当我们对要进行跳转的页面上添加支持路由的注解时，我们需要遵循以下规则：<br>
<strong>路径需要注意的是至少需要有两级，/xx/xx，我们以/moduleName/className为基准进行对应的命名。</strong></li>
<li>使用示例<pre><code class="language-java">    @Route(path = &quot;/mine/mineActivity&quot;)
    class MineActivity {
    ...
    }
</code></pre>
</li>
<li>注意事项<br>
<strong>在使用该库的每个类的build.gradle文件中要添加如下配置：</strong><pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        // ARouter--每个使用到路由的Module必须加
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
        ...
    }
    ...
}
dependencies {
    // ARouter--每个使用到路由的Module必须加
    annotationProcessor rootProject.ext.dependencies['arouter-compiler']
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>DataBinding——数据绑定</strong></p>
<ul>
<li>
<p>概述<br>
数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</li>
<li>
<p>引入<br>
在使用DataBinding的Module中的build.gradle文件中进行如下操作：</p>
<ul>
<li>
<p>在文件最顶端(android标签外部)添加如下插件声明</p>
<pre><code class="language-java">plugins {
    ...
    id 'kotlin-kapt'
}
</code></pre>
</li>
<li>
<p>在android标签内部添加databinding引用（AndroidStudio 4.0+与之前写法不同）</p>
<pre><code class="language-java">buildFeatures {
    dataBinding = true
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用</p>
<ul>
<li>修改对应的布局<br>
使用Databinding的布局，最外层必须套一层layout标签，我们要修改对应的布局如下：<pre><code class="language-java">&lt;layout&gt;
    &lt;data&gt;
        ...
    &lt;/data&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        ...
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;/layout&gt;
</code></pre>
</li>
<li>给对应的控件绑定数据（这里以TextView为例）<br>
首先，在布局中添加一个TextView控件，然后在<code>&lt;data&gt;</code>标签内添加一个属性标签<code>&lt;variable&gt;</code>，其中name属性是指变量名称，type属性是指变量类型<pre><code class="language-java">&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    
    &lt;data&gt;

        &lt;variable
            name=&quot;titleStr&quot;
            type=&quot;String&quot; /&gt;
    &lt;/data&gt;
    
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        &lt;TextView
            android:id=&quot;@+id/tv_title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{titleStr}&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;layou/&gt;
</code></pre>
在页面中进行赋值操作：<pre><code class="language-java">DataBindingUtil.setContentView&lt;ActivitySimpleBindingImpl&gt;(this, R.layout.activity_simple)
    .apply {
        titleStr = &quot;DataBinding test&quot;
    }
</code></pre>
<blockquote>
<p>注：使用DataBinding的Activity会自动生成<code>ActivityXXXBindingImpl</code>，如SimpleActivity会生成ActivitySimpleBindingImpl类。</p>
</blockquote>
</li>
<li>点击事件的使用</li>
<li>RecyclerView的使用</li>
<li>ImageView加载一张网络图片</li>
</ul>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/e8cf690ee8cc">DataBinding + Kotlin</a></p>
</blockquote>
<ul>
<li>
<p><strong>Paging——分页</strong></p>
<ul>
<li>
<p>概述<br>
Paging 库可帮助您加载和显示来自本地存储或网络中更大的数据集中的数据页面。此方法可让您的应用更高效地利用网络带宽和系统资源。Paging 库的组件旨在契合推荐的 Android 应用架构，流畅集成其他 Jetpack 组件，并提供一流的 Kotlin 支持。</p>
<p>使用 Paging 库，您可以更加轻松地在应用的 RecyclerView 中逐步、流畅地加载数据。</p>
</li>
<li>
<p>引入</p>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
<li>
<p><strong>BottomNavigation——底部导航栏</strong><br>
<a href="https://www.jianshu.com/p/f0021265845f">Kotlin-BottomNavigationView</a><br>
<a href="https://blog.csdn.net/afei__/article/details/80950288">Android底部导航栏，三种风格和实现</a><br>
<a href="https://www.jianshu.com/p/1cebf8cd1a86">Android 底部导航之BottomNavigationBar</a><br>
<a href="https://blog.csdn.net/abs1004/article/details/77330726">安卓 BottomNavigationBar 底部导航栏 最简单用法详解</a></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】git命令行登陆github进行操作]]></title>
        <id>https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/</id>
        <link href="https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/">
        </link>
        <updated>2021-06-24T16:32:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>转载自<a href="https://www.jianshu.com/p/6e3f9e4e8e69">git命令行登陆github进行操作</a>，侵删。</strong></p>
</blockquote>
<p>登陆github必须先创建SSH key<br>
因为本地Git仓库和GitHub仓库之间的传输是通过SSH加密传输的，GitHub需要识别是否是你推送，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送，所以需要配置ssh key。</p>
<hr>
<h2 id="1创建ssh-key">1.创建SSH Key。</h2>
<p>在用户主目录（C:\Users\Administrator）下，看看有没有.ssh文件，如果有，再看文件下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接到下一步。如果没有，打开Git Bash，输入命令，创建SSH Key</p>
<p><code>$ ssh-keygen -t rsa -C &quot;你自己注册GitHub的邮箱&quot;</code></p>
<hr>
<h2 id="2接下来到github上打开account-settings-ssh-keys页面然后点击add-ssh-key填上title随意写在key文本框里粘贴-id_rsapub文件里的全部内容">2.接下来到GitHub上，打开“Account settings”--“SSH Keys”页面，然后点击“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容。</h2>
<p>id_rsa.pub 默认在C:\Users\Administrator.ssh</p>
<p>每台想要登陆某个github账号的主机都需要有一个对应的key，例如你有一个github账号，你在你的笔记本和台式上都要创建key</p>
<hr>
<h2 id="3git-bash里输入下面的命令登陆">3.git bash里输入下面的命令登陆</h2>
<p><code>$ ssh -T git@github.com</code></p>
<p>如果看到 hi + 你的用户名说明密钥验证通过了，你已经可以上传下载了<br>
<img src="https://jgduan.github.io//post-images/1624552568098.png" alt="" loading="lazy"></p>
<hr>
<h2 id="4设置username和email因为github每次commit都会记录他们">4.设置username和email，因为github每次commit都会记录他们</h2>
<p>git commit 命令会记录提交者的信息，所以使用git前必须先添加两条信息</p>
<p><code>$ git config --global user.name &quot;你的GitHub登陆名&quot;</code><br>
<code>$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
<blockquote>
<p>（其实可以不和github上面的用户名邮箱一致，只是为了避免混淆）</p>
</blockquote>
<hr>
<h2 id="5接下来就是把本地仓库传到github上去">5.接下来就是把本地仓库传到github上去</h2>
<p><code>$ git remote add origin git@github.com:userName/yourProject.git</code></p>
<p>//关联一个远程库命令，git@后面填写你的github repository（仓库），在github里面创建仓库后有http和ssh的链接，origin是你给这个仓库起的名字，可以自定义，下面命令中的origin也要相应改变</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1624552692583.webp" alt="" loading="lazy"></figure>
<p>git push -u origin master //把本地已经commit 的结果push到github的origin 仓库的master分支中</p>
<hr>
<p>##【拓展阅读】<br>
<a href="https://www.cnblogs.com/luhuan/p/9072820.html">Windows下配置Git多账号github码云</a></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Plugin version (1.4.32) is not the same as library version (1.4.10) 警告的解决办法]]></title>
        <id>https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/</id>
        <link href="https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/">
        </link>
        <updated>2021-06-24T15:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在开发<code>Kotlin</code>项目的过程中，使用<code>kotlin-stdlib</code>标准库时，遇到了如下警告提示：</p>
<pre><code class="language-java">Plugin version(1.4.32) is not the same as library version(1.4.10)
</code></pre>
<p>提示的大致意思是说我们的插件版本和依赖库的版本不一致，原因是因为一些第三方的Library库所依赖的版本比较低，而我们在项目中所指定的依赖版本比较高，从而导致AndroidStudio给我们提出了警示。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p><strong>直接在module的build.gradle中删除依赖即可解决问题</strong></p>
<pre><code class="language-java">// 删除moudle-build.gralde文件中的该段
implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
</code></pre>
<p>详情请移步官网查看官方声明的这篇文章：<a href="https://kotlinlang.org/docs/whatsnew14.html#dependency-on-the-standard-library-added-by-default">What's new in Kotlin 1.4</a><br>
<img src="https://jgduan.github.io//post-images/1624550094222.png" alt="" loading="lazy"></p>
<p>图中的意思是：</p>
<blockquote>
<p>Kotlin默认添加了stdlib的依赖，您不再需要stdlib在任何 Kotlin Gradle 项目（包括多平台项目）中声明对库的依赖。默认情况下添加依赖项。</p>
</blockquote>
<blockquote>
<p>自动添加的标准库将是 Kotlin Gradle 插件的相同版本，因为它们具有相同的版本。</p>
</blockquote>
<blockquote>
<p>对于特定于平台的源集，使用库的相应特定于平台的变体，同时将公共标准库添加到其余部分。Kotlin Gradle 插件将根据您的 Gradle 构建脚本的kotlinOptions.jvmTarget 编译器选项选择合适的 JVM 标准库。</p>
</blockquote>
<p>上面所说的Kotlin插件，是指Project根目录下的build.gradle文件中的Kotlin插件，具体如下图所示：<br>
<img src="https://jgduan.github.io//post-images/1624550446644.png" alt="" loading="lazy"></p>
<p>这样一来，让人糟心的警告就不见了。</p>
<hr>
]]></content>
    </entry>
</feed>