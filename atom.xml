<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-07-24T15:21:36.025Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【Kotlin】常见语法解惑]]></title>
        <id>https://jgduan.github.io/post/kotlin-chang-jian-yu-fa-jie-huo/</id>
        <link href="https://jgduan.github.io/post/kotlin-chang-jian-yu-fa-jie-huo/">
        </link>
        <updated>2021-07-24T14:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-kotlin中的与比较符号">一、Kotlin中的'=='与'==='比较符号</h1>
<h2 id="1基础知识">1.基础知识</h2>
<ul>
<li>Kotlin中的三等号 '===' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间);</li>
<li>Kotlin中的双等号 '=='  比较的是i盎格对象的值。</li>
</ul>
<h2 id="2示例">2.示例</h2>
<blockquote>
<p>代码源自<a href="https://kotlinlang.org/docs/basic-types.html">Kotlin官方-Basic types</a></p>
</blockquote>
<ul>
<li>
<p>三等号 '===' 的示例</p>
<pre><code class="language-java">  val a: Int = 100
  val boxedA: Int? = a
  val anotherBoxedA: Int? = a

  val b: Int = 10000
  val boxedB: Int? = b
  val anotherBoxedB: Int? = b

  println(boxedA === anotherBoxedA) // true
  println(boxedB === anotherBoxedB) // false
</code></pre>
</li>
<li>
<p>双等号 '=='  的示例</p>
<pre><code class="language-java">  val b: Int = 10000
  println(b == b) // Prints 'true'
  val boxedB: Int? = b
  val anotherBoxedB: Int? = b
  println(boxedB == anotherBoxedB) // Prints 'true'
</code></pre>
</li>
</ul>
<p>在以上两个示例中，第二段代码可能比较好理解一点，它主要是表现比较两个对象的值是否相等；<br>
对于第一段的代码，可能有人不太理解，同样是使用三等号去比较，为什么第一次比较的值是true，第二次比较的值是false呢？其实Kotlin官方就对此做出了如下解释：</p>
<blockquote>
<p>Numbers representation on the JVM<br>
On the JVM platform, numbers are stored as primitive types: int, double, and so on. Exceptions are cases when you create a nullable number reference such as Int? or use generics. In these cases numbers are boxed in Java classes Integer, Double, and so on.<br>
中文译：在 JVM 平台上，数字存储为原始类型：int、double等。创建可为空的数字引用（例如Int?或使用泛型）时的情况除外。在这些情况下，数字在 Java 类Integer、Double 等中被装箱。<br>
All nullable references to a are actually the same object because of the memory optimization that JVM applies to Integer s between -128 and 127. It doesn't apply to the b references, so they are different objects.<br>
中文译：由于VM对-128到127之间的整数应用了内存优化，因此对a的所有可为null的引用实际上都是同一个对象。而它并不适用于b，b的值已经超出了-128~127的范围，因此它们是不同的对象。</p>
</blockquote>
<p>JDK 从 1.5 版本开始，把 -128~127（high的默认值） 的数字缓存起来了，用于提升性能和节省内存，通过<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>来控制high的取值。所以，当数字在缓存范围内时，通过valueOf()方式拿到的对象引用全部来自于缓存列表，<strong>所以对于相同的值，对象引用相同；若是超过缓存范围，则是重新生成的对象，自然也就不相等了。</strong></p>
<h2 id="3知识汇总">3.知识汇总</h2>
<ul>
<li>Kotlin中的三等号 '===' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间);</li>
<li>Kotlin中的双等号 '=='  比较的是i盎格对象的值。</li>
<li>Kotlin中的非空数字类型对应到JVM平台是基本类型：int,double等等；</li>
<li>Kotlin中的可空数字类型对应到JVM平台是封装类型：Integer，Double等等；</li>
<li>Java中双等号 '==' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间)，与Kotlin中的三等号 '===' 等价。</li>
</ul>
<hr>
<h1 id="二-kotlin中-let-运算符的区别">二、Kotlin中 ?. !!. ?.let ?: 运算符的区别</h1>
<h2 id="1基础知识-2">1.基础知识</h2>
<blockquote>
<p>推荐访问<a href="https://kotlinlang.org/docs/null-safety.html">Kotlin官方-空安全</a></p>
</blockquote>
<p>Kotin支持非空类型与可空类型，同时为了消除空引用的危险，在IDE如果我们是同可空类型命名变量后，访问该变量的其它属性或者方法时，IDE会检测并提出警示，让用户通过<code>?./?.let</code>或者<code>!!./?:</code>运算符来进行安全访问。</p>
<ul>
<li>
<p>对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过;</p>
</li>
<li>
<p>对于一个可空类型：通过<code>？</code>声明，在访问该类型的时候直接访问不能编译通过，需要通过<code>?.</code>或者<code>!!.</code></p>
<ul>
<li><code>?.</code>代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性；</li>
<li><code>!!.</code>代表着如果该类型为空的话就抛出<code>NullPointerException</code>，如果不为空就去访问对应的方法或者属性， 所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出<code>NullPointerException</code>。 而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了。</li>
</ul>
</li>
<li>
<p><code>let</code>语句简化对可空对象对访问：<code>let</code>函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。</p>
</li>
<li>
<p><code>?:</code>简化对空值的处理：<code>?:</code>符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。跟<code>?.let</code>正好相反，例如我们可以用两行代码来简化上面从操作：</p>
</li>
</ul>
<h2 id="2示例-2">2.示例</h2>
<ul>
<li>
<p>不可为空类型</p>
<pre><code class="language-java">var a: String = &quot;123&quot; // Regular initialization means non-null by default
a = null // compilation error-编译错误
</code></pre>
</li>
<li>
<p>可为空类型</p>
<pre><code class="language-java">var b: String? = &quot;123&quot; // can be set to null
b = null // ok
println(b) // print null
println(b.length // print null
</code></pre>
<p>这个时候，如果你使用b的属性，那么会提示你使用<code>?.</code>或者<code>!!.</code>，<strong>只有在你需要NPE异常时，才推荐用!!.，否则，请使用?.来进行访问。</strong></p>
</li>
<li>
<p>?.let (安全调用操作符)<br>
通过let语句，在<code>?.let</code>之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</p>
<pre><code class="language-java">    val person:Person? = getPerson()
    person?.let {
        it.name
        it.age
    }
</code></pre>
</li>
<li>
<p>?: ( Elvis 运算符)<br>
如果<code>?:</code>左侧表达式非空，Elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。</p>
<pre><code class="language-java">    val b:Int? = 0
    val l = b?.length ?: -1
</code></pre>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【团队管理】KPI与OKR]]></title>
        <id>https://jgduan.github.io/post/tuan-dui-guan-li-kpi-yu-okr/</id>
        <link href="https://jgduan.github.io/post/tuan-dui-guan-li-kpi-yu-okr/">
        </link>
        <updated>2021-07-20T15:19:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-kpi-关键绩效指标">一、KPI-关键绩效指标</h1>
<h2 id="1kpi概述">1.KPI概述</h2>
<blockquote>
<p>KPI(<code>Key Performance Indicator</code>)，中文意为关键绩效指标。</p>
</blockquote>
<p><strong>KPI是一种自上而下，首先确定组织目标的管理考核机制</strong>，是通过对组织内部流程的输入端、输出端的关键参数进行设置、取样、计算、分析，衡量流程绩效的一种目标式量化管理指标，是把企业的战略目标分解为可操作 / 执行的工作目标的工具，是企业绩效管理的基础。</p>
<p>KPI可以是部门主管明确部门的主要责任，并以此为基础，明确部门人员的业绩衡量指标。建立明确的切实可行的KPI体系，是做好绩效管理的关键。关键绩效指标是用于衡量工作人员工作绩效表现的量化指标，是绩效计划的重要组成部分。</p>
<p>KPI法符合一个重要的管理原理：<strong>“二八原理”</strong>——在一个企业的价值创造过程中，存在着“80/20”的规律，即20%的骨干人员创造企业80%的价值；而且在每一位员工身上“二八原理”同样适用，即80%的工作任务是由20%的关键行为完成的。因此，必须抓住20%的关键行为，对之进行分析和衡量，这样就能抓住业绩评价的重心。</p>
<blockquote>
<p>二八原理，是由意大利经济学家帕累托提出的一个经济学原理，即一个企业在价值创造过程中，每个部门和每一位员工的80%的工作任务是由20%的关键行为完成的，抓住20%的关键，就抓住了主体。<br>
二八原理为绩效考核指明了方向，即考核工作的主要精力要放在关键的结果和关键的过程上。于是，所谓的绩效考核，一定放在关键绩效指标上，考核工作一定要围绕关键绩效指标展开。</p>
</blockquote>
<h2 id="2kpi绩效考核的目的">2.KPI绩效考核的目的</h2>
<p>以战略为中心，指标体系的设计与运用都为组织战略目标的达成服务。<br>
以控制为中心，指标体系的设计与运用来源于控制的意图，也是为更有效的控制个人的行为服务。</p>
<hr>
<h1 id="二-okr-目标与关键成果法">二、OKR-目标与关键成果法</h1>
<h2 id="1okr概述">1.OKR概述</h2>
<p>OKR（<code>Objectives and Key Results</code>）即目标与关键成果法，是一套明确和跟踪目标及其完成情况的管理工具和方法，由英特尔公司创始人安迪·葛洛夫（AndyGrove）发明，并由约翰·道尔（JohnDoerr）引入到谷歌使用，1999年OKR在谷歌发扬光大，在Facebook、Linked in等企业广泛使用。</p>
<p><strong>OKR的思路是一定程度上的自下而上的、由个人提出，然后由组织确定的管理考核方式。</strong></p>
<p>2014年，OKR传入中国。2015年后，百度、华为、字节跳动等企业都逐渐使用和推广OKR。</p>
<p><strong>OKR的主要目标是明确公司和团队的“目标”以及明确每个目标达成的可衡量的“关键结果”。</strong></p>
<p>一本关于OKR的书将OKR定义为“一个重要的思考框架与不断发展的学科，旨在确保员工共同工作，并集中精力做出可衡量的贡献。”</p>
<p><strong>OKR可以在整个组织中共享，这样团队就可以在整个组织中明确目标，帮助协调和集中精力。</strong></p>
<hr>
<h1 id="kpi与okr">KPI与OKR</h1>
<h2 id="1两者之间的区别">1.两者之间的区别</h2>
<h2 id="2kpi的缺陷">2.KPI的缺陷</h2>
<ol>
<li><strong>没有人对最终结果负责，每个人只对自己的过程负责。</strong></li>
<li><strong>人的主观能动性被压抑。</strong></li>
<li><strong>结果高度依赖机器和管理者的指令。</strong></li>
</ol>
<p>有些事情值得去做，但在做出来一部分之前无法测量因此无法制订目标。为了完成可测量的目标，有可能实际执行手段与该目标要达到的愿景正好相反。</p>
<p>举例来说，我们希望用户更喜欢使用我们的产品，因为喜欢无法测量，所以把PV写进了 KPI 里面。但在实际执行过程中，我们可以把用户原本在一个页面上就能完成的事情分到几个页面上来完成，结果 PV 达到了 KPI 指定的目标，但用户可能更讨厌我们的产品了。</p>
<h2 id="3okr解决了什么">3.OKR解决了什么</h2>
<p>OKR 解决了 KPI 的这些缺陷。首先它和绩效考核分离，把绩效考核交给 peer review来做。然后它强调 Key Result 必须服从 Objective，所以如果你在 Objective上写了要让用户喜欢我们的产品，但你实际执行 Key Result 的手段违反了这一点的话，谁都能看得出来。既然 Key Result 只是用来服务于 Objective 的，那就没必要像 KPI 那样一早制订好然后强制执行了。你可以在做的过程中随意更改 Key Result，只要它们还是服务于原本的 Objective 就行。</p>
<hr>
<h1 id="三-拓展阅读">三、拓展阅读</h1>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E7%BB%A9%E6%95%88%E6%8C%87%E6%A0%87%E6%B3%95/4723067?fr=aladdin"><strong>关键绩效指标法</strong></a></li>
<li><a href="https://baike.baidu.com/item/OKR"><strong>OKR-目标与关键成果法</strong></a></li>
<li><a href="https://www.zhihu.com/question/22471467/answer/220121306"><strong>谷歌内部考核制度 OKR 是怎样的？ - 李会军的回答 - 知乎</strong></a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android应用优化】解决应用启动时黑屏/白屏问题]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-you-hua-jie-jue-ying-yong-qi-dong-shi-hei-ping-bai-ping-wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-you-hua-jie-jue-ying-yong-qi-dong-shi-hei-ping-bai-ping-wen-ti/">
        </link>
        <updated>2021-07-19T16:11:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-app的载入页">Android App的载入页</h1>
<h2 id="什么是载入页">什么是载入页？</h2>
<p>当前主流应用流行在启动时打开一个类似欢迎页的过度页面，我们一般称之为<code>SplashActivity</code>，中文一般用载入页来表示。</p>
<blockquote>
<p>一般来说，载入页都是以全屏的方式展示给用户的。</p>
</blockquote>
<h2 id="载入页能做些什么">载入页能做些什么？</h2>
<ol>
<li><strong>加深用户对产品的印象</strong>：通过在载入页进行应用 / 企业信息的展示来加深用户对产品的印象；</li>
<li><strong>启动过渡</strong>：避免主页初始化过慢给用户不友好的交互体验；</li>
<li><strong>开屏推荐信息 / 广告展示</strong>：简短的信息 / 广告展示，灵活利用<code>App</code>内容初始化的时间进行相关转化；</li>
<li><strong>临时预加载</strong>：提前为主页做一些不耗时的预加载工作。</li>
</ol>
<h2 id="载入页一般存在多久">载入页一般存在多久？</h2>
<p>通常情况下，在用户点击桌面应用的icon后，会进入到<code>SplashActivity</code>载入页，然后一般是在<strong>3s内</strong>进入到应用的主页面（考虑到交互的友好性，载入页不应该存在太久，也不应该存在太多的耗时操作，否则会给用户<strong>很卡</strong>的感觉，它的存在，更多的是起到一些基础信息的展示、初始化及过度作用）。</p>
<hr>
<h1 id="载入页的黑屏-白屏问题">载入页的黑屏 / 白屏问题</h1>
<p>在我们没有对应用进行特殊处理时，我们会发现在一些机型上（尤其是配置相对较差的机器），在桌面点击应用图标首次启动应用时，载入页出现前会出现黑屏 / 白屏的问题。</p>
<h2 id="为什么会出现黑屏-白屏呢">为什么会出现黑屏 / 白屏呢？</h2>
<p>因为在用户点击应用图标后，系统会进行一系列的<code>Framework</code>操作，其中就包括<code>Application</code>的初始化，如果我们在<code>Application</code>初始化的过程中做了过多的操作，就会导致应用明明已经启动了，却迟迟没有界面展示出来，这个时候，就会出现应用黑屏 / 白屏的情况。</p>
<blockquote>
<p><code>Application</code>初始化时注意：</p>
<ol>
<li>尽量不将一些业务逻辑放于<code>Application</code>中；</li>
<li>不以静态变量的方式在<code>Application</code>中保存应用数据；</li>
<li>不要把文件、数据库的操作放在<code>Application</code>中；</li>
<li>不要再<code>Application</code>封装与初始化无关的其它事务。</li>
</ol>
</blockquote>
<h2 id="什么时候出现黑屏什么时候出现白屏">什么时候出现黑屏？什么时候出现白屏？</h2>
<p>App黑屏/白屏，实际上跟设置的主题（<code>Theme</code>）有关，设置<code>Light</code>系列的，会显示白屏，设置<code>Dark</code>系列的，会显示黑屏。</p>
<hr>
<h1 id="解决方法">解决方法</h1>
<h2 id="设置透明的splashactivity">设置透明的SplashActivity</h2>
<p>在应用<code>styles</code>文件内，为载入页（SplashActivity）新增自定义样式，设置Activity的主题样式背景为透明色、全屏、无标题栏、无ActionBar，具体代码如下：</p>
<pre><code class="language-java">&lt;style name=&quot;AppTheme.Splash&quot; parent=&quot;AppTheme.xxx&quot;&gt;
    &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
    &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在<code>AndroidManifest.xml</code>中为SplashActivity设置<code>Theme</code>样式：</p>
<pre><code class="language-java">&lt;activity
    android:name=&quot;.SplashActivity&quot;
    android:theme=&quot;@style/AppTheme.Splash&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1+版本在Module-BuildConfig中找不到VERSION_CODE、VERSION_NAME字段]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41ban-ben-zai-module-buildconfig-zhong-zhao-bu-dao-version_codeversion_name-zi-duan/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41ban-ben-zai-module-buildconfig-zhong-zhao-bu-dao-version_codeversion_name-zi-duan/">
        </link>
        <updated>2021-07-18T16:38:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>最近升级<code>Android Studio</code>到4.2版本后，在项目的其它<code>Module</code>中添加了检查更新功能，本想通过统一配置<code>VersionCode、VersionName</code>然后在<code>Module</code>中直接获取本地的<code>VersionCode</code>来与服务器对比做更新判断的，结果发现<code>BuildConfig</code>文件中，没有这两个字段。最后通过<code>StackOverflow</code>查询后发现<a href="https://issuetracker.google.com/issues/154275579?pli=1#comment3"><strong>Google Issue Tracker</strong></a>文中对问题的原因进行了解释：<code>Google</code>认为<code>VersionCode、VersionName</code>字段在其它<code>Module</code>中不代表任何意义，还容易与<code>app</code>模块中的字段混淆概念，所以认定它不应该再出现在其它模块中。</p>
<p><img src="https://jgduan.github.io//post-images/1626627606725.png" alt="" loading="lazy"><br>
<img src="https://jgduan.github.io//post-images/1626627613034.png" alt="" loading="lazy"><br>
<img src="https://jgduan.github.io//post-images/1626627621216.png" alt="" loading="lazy"></p>
<hr>
<h1 id="解决方法">解决方法</h1>
<ul>
<li><strong>使用App模块中的字段进行判断</strong></li>
<li><strong>在Module中添加VersionCode的配置</strong><br>
我们可以在<code>Module-build.gradle</code>文件中添加对应<code>VersionCode、VersionName</code>的配置，通过该方式，也可以达到目的，不过<em>个人不推荐这样做</em>，按照官方的做法即可。</li>
</ul>
<pre><code class="language-java">debug {
    buildConfigField &quot;String&quot;, &quot;VERSION_NAME&quot;, &quot;1.0.1&quot;
    buildConfigField &quot;int&quot;, &quot;VERSION_CODE&quot;, &quot;1&quot;
}
release {
    buildConfigField &quot;String&quot;, &quot;VERSION_NAME&quot;, &quot;1.0.1&quot;
    buildConfigField &quot;int&quot;, &quot;VERSION_CODE&quot;, &quot;1&quot;
}
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】自定义绘制一个圆环形进度条]]></title>
        <id>https://jgduan.github.io/post/android-zi-ding-yi-hui-zhi-yi-ge-yuan-huan-xing-jin-du-tiao/</id>
        <link href="https://jgduan.github.io/post/android-zi-ding-yi-hui-zhi-yi-ge-yuan-huan-xing-jin-du-tiao/">
        </link>
        <updated>2021-07-07T14:46:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-预期效果">一、预期效果</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625669223339.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="二-绘制分析">二、绘制分析</h1>
<p>根据预期图片可以看出：</p>
<ul>
<li>
<p><strong>需要绘制一个带有文本的圆环形进度条</strong></p>
<ul>
<li>绘制圆环（进度条背景色）</li>
<li>绘制圆环上的进度（进度条前景色）</li>
</ul>
</li>
<li>
<p><strong>它的最大值、进度可自由设置</strong></p>
<ul>
<li>自定义属性：maxValue</li>
<li>自定义属性：progress</li>
</ul>
</li>
<li>
<p><strong>进度线条的形状为圆头</strong></p>
</li>
<li>
<p><strong>进度条中心位置显示标题及任务描述</strong></p>
<ul>
<li>标题文本绘制-drawText</li>
<li>任务描述文本绘制-drawText</li>
<li>文字居中显示</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三-开始绘制">三、开始绘制</h1>
<ul>
<li>
<p><strong>新建一个<code>CircleProgressBar</code>类，继承<code>View</code></strong></p>
</li>
<li>
<p><strong>相关自定义属性的设置</strong></p>
</li>
<li>
<p><strong>控件获取宽高、中心点、初始化画笔</strong></p>
</li>
<li>
<p><strong>绘制圆环及进度</strong></p>
<ul>
<li>绘制圆环（背景色）</li>
<li>绘制进度（前景色）</li>
</ul>
</li>
<li>
<p><strong>绘制显示的文本</strong></p>
<ul>
<li>绘制标题文本</li>
<li>绘制描述文本</li>
</ul>
</li>
<li>
<p><strong>进度条展示动画效果设置</strong></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】Android Paint 画笔的一些偏知识]]></title>
        <id>https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/</id>
        <link href="https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/">
        </link>
        <updated>2021-07-06T15:02:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转载于 抛物线http://hencoder.com/ui-1-2/</p>
</blockquote>
<hr>
<h1 id="setstrokecappaintcap-cap-设置线头的形状">setStrokeCap(Paint.Cap cap) 设置线头的形状</h1>
<p>设置线头的形状。线头形状有三种：<code>BUTT</code> 平头、<code>ROUND</code> 圆头、<code>SQUARE</code> 方头。默认为 <code>BUTT</code>。</p>
<blockquote>
<p>放出「平头」「圆头」「方头」这种翻译我始终有点纠结：既觉得自己翻译得简洁清晰尽显机智，同时又担心用词会不会有点太过通俗，让人觉得我不够高贵冷艳？</p>
</blockquote>
<p>当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：<br>
<img src="https://jgduan.github.io//post-images/1625584089491.jpg" alt="" loading="lazy"></p>
<p>虚线是额外加的，虚线左边是线的实际长度，虚线右边是线头。有了虚线作为辅助，可以清楚地看出 <code>BUTT</code> 和 <code>SQUARE</code> 的区别。</p>
<hr>
<h1 id="setstrokejoinpaintjoin-join">setStrokeJoin(Paint.Join join)</h1>
<p>设置拐角的形状。有三个值可以选择：<code>MITER</code> 尖角、 <code>BEVEL</code> 平角和 <code>ROUND</code> 圆角。默认为 <code>MITER</code>。<br>
<img src="https://jgduan.github.io//post-images/1625584131677.jpg" alt="" loading="lazy"></p>
<p>辅助理解：<br>
<code>MITER</code> 在现实中其实就是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584155362.jpg" alt="" loading="lazy"></p>
<p>而 <code>BEVEL</code> 是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584171460.jpg" alt="" loading="lazy"></p>
<hr>
<h1 id="setstrokemiterfloat-miter">setStrokeMiter(float miter)</h1>
<p>这个方法是对于 <code>setStrokeJoin()</code> 的一个补充，它用于设置 <code>MITER</code> 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：<br>
当线条拐角为 <code>MITER</code> 时，拐角处的外缘需要使用延长线来补偿：<br>
<img src="https://jgduan.github.io//post-images/1625584210033.jpg" alt="" loading="lazy"></p>
<p>而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：<br>
<img src="https://jgduan.github.io//post-images/1625584221599.jpg" alt="" loading="lazy"></p>
<p>所以为了避免意料之外的过长的尖角出现， <code>MITER</code> 型连接点有一个额外的规则：当尖角过长时，自动改用 <code>BEVEL</code> 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 <code>BEVEL</code> 型连接点：<br>
<img src="https://jgduan.github.io//post-images/1625584236255.jpg" alt="" loading="lazy"></p>
<p>至于多尖的角属于过于尖，尖到需要转为使用 <code>BEVEL</code> 来绘制，则是由一个属性控制的，而这个属性就是 <code>setStrokeMiter(miter)</code>方法中的 <code>miter</code> 参数。<code>miter</code> 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：<br>
<img src="https://jgduan.github.io//post-images/1625584259127.jpg" alt="" loading="lazy"></p>
<p>用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1 / sin ( θ / 2 ) 。<br>
这个 <code>miter limit</code> 的默认值是 4，对应的是一个大约 29° 的锐角：<br>
<img src="https://jgduan.github.io//post-images/1625584364544.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」</p>
</blockquote>
<p>所以，这个方法虽然名叫 <code>setStrokeMiter(miter)</code> ，但它其实设置的是「 线条在 <code>Join</code> 类型为 <code>MITER</code> 时对于 <code>MITER</code> 的长度限制」。它的这个名字虽然短，但却存在一定的迷惑性，如果叫 <code>setStrokeJoinMiterLimit(limit)</code> 就更准确了。 Google 的工程师没有这么给它命名，大概也是不想伤害大家的手指吧，毕竟程序员何苦为难程序员。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】各大版本新特性及行为变更]]></title>
        <id>https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/</id>
        <link href="https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/">
        </link>
        <updated>2021-07-05T15:03:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><strong>Android 12.0开发者预览版</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/12/features?hl=zh_cn">概览 API 30</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all">Android 12.0影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12?hl=zh_cn">行为变更：以 Android 12 为目标平台的应用</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/foreground-services?hl=zh_cn">前台服务启动限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/non-sdk-12?hl=zh_cn">Android 12 中有关限制非 SDK 接口的更新</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features">Android 12 功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/work?hl=zh_cn">Android 12 中的企业功能新变化</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/migration?hl=zh_cn">将应用迁移到 Android 12</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/unified-content-api?hl=zh_cn">接收内容的统一 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/compatible-media-transcoding?hl=zh_cn">兼容的媒体转码</a></li>
</ul>
</li>
<li>
<p><strong>Android 11.0</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/11?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-all">影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-11">影响以 Android 11 为目标平台的应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/privacy">Android 11 隐私权变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/features">Android 11 功能和 API 30</a></li>
</ul>
</li>
<li>
<p><strong>Android 10.0(Q)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/10?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/migration?hl=zh_cn">将应用迁移至 Android 10</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/privacy?hl=zh_cn">隐私功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/behavior-changes-all?hl=zh_cn">行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/highlights?hl=zh_cn">新功能和 API 29</a></li>
<li><a href="https://blog.csdn.net/u011216417/article/details/89189741">Android10.0(Q)新特性和行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 9.0(P)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/pie?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0?hl=zh_cn">功能和API 28</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all?hl=zh_cn">针对所有应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-28?hl=zh_cn">针对API 28+应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-migration?hl=zh_cn">迁移至Android 9.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/power?hl=zh_cn">电源管理</a></li>
</ul>
</li>
<li>
<p><strong>Android 8.0(O)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/oreo?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0?hl=zh_cn">Android 8.0 功能和 API 26</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes?hl=zh_cn">Android 8.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-migration?hl=zh_cn">迁移到Android 8.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-samples?hl=zh_cn">Android 8.0示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background?hl=zh_cn">后台执行限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits?hl=zh_cn">后台位置信息限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.1?hl=zh_cn">Android 8.1 功能和 API 27</a></li>
</ul>
</li>
<li>
<p><strong>Android 7.0(N)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/nougat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0?hl=zh_cn">Android 7.0 开发者版本 API 24</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes?hl=zh_cn">Android 7.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-samples?hl=zh_cn">Android 7.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1?hl=zh_cn">Android 7.1 开发者版本 API 25</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1-samples?hl=zh_cn">Android 7.1 示例</a></li>
</ul>
</li>
<li>
<p><strong>Android 6.0(M)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0?hl=zh_cn">Android 6.0 API 23</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes?hl=zh_cn">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-samples?hl=zh_cn">Android 6.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-testing?hl=zh_cn">Android 6.0 测试指南</a></li>
</ul>
</li>
<li>
<p><strong>Android 5.0(L)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/lollipop?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.1?hl=zh_cn">Android 5.1 API 22</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0?hl=zh_cn">Android 5.0 API 21</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0-changes?hl=zh_cn">Android 5.0 行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 4.4(KitKat)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/kitkat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4?hl=zh_cn">Android 4.4 API 19</a></li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://developer.android.google.cn/about/versions?hl=zh_cn">所有Android版本</a></p>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】使用PermissionsDispatcher进行动态权限适配]]></title>
        <id>https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/</id>
        <link href="https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/">
        </link>
        <updated>2021-07-05T12:55:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-permissionsdispatcher简介">一、PermissionsDispatcher简介</h1>
<p>PermissionsDispatcher provides a simple annotation-based API to handle runtime permissions.<br>
<code>PermissionsDispatcher</code>提供了一个简单的基于注解的 API 来处理运行时权限。</p>
<p>This library lifts the burden that comes with writing a bunch of check statements whether a permission has been granted or not from you, in order to keep your code clean and safe.<br>
该库减轻了编写一堆检查语句所带来的负担，无论是否已授予您许可，以保持您的代码清洁和安全。</p>
<ul>
<li>
<p><strong>Fully Kotlin/Java support - 完全支持Kotlin/Java</strong></p>
</li>
<li>
<p><strong><a href="https://github.com/hotchemi/PermissionsDispatcher/blob/master/doc/special_permissions.md">Special permissions support - 特殊权限支持</a></strong></p>
</li>
<li>
<p><strong>100% reflection-free - 100%无反射</strong></p>
</li>
</ul>
<p>本文基于<code>PermissionsDispatcher 4.8.0及 permissionsdispatcher-ktx 1.0.5</code>版本，我们将介绍Kotlin的ktx使用方式，如过需要使用Kotlin kapt或Java使用方式的，请移步<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">Github-PermissionsDispatcher</a></p>
<blockquote>
<p><code>permissionsdispatcher-ktx</code><br>
<code>permissionsdispatcher-ktx</code>旨在让开发人员在不使用注释处理（kapt）的情况下以声明式方式处理运行时权限。</p>
</blockquote>
<hr>
<h1 id="二-使用示例">二、使用示例</h1>
<h2 id="1准备工作添加一个示例权限">1.准备工作——添加一个示例权限</h2>
<p>我们在项目的<code>AndroidManifest.xml</code>中添加如下权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
</code></pre>
<h2 id="2引入库">2.引入库</h2>
<p>在使用该库API的Module的<code>build.gradle</code>文件中，添加如下代码引入<code>PermissionsDispatcher</code>库：</p>
<pre><code class="language-java">dependencies {
  implementation &quot;com.github.permissions-dispatcher:permissionsdispatcher:4.8.0&quot;
  implementation &quot;com.github.permissions-dispatcher:ktx:1.0.5&quot;
}
</code></pre>
<h2 id="3在需要进行权限请求的activityfragment中定义请求者constructpermissionsrequest">3.在需要进行权限请求的Activity/Fragment中，定义请求者constructPermissionsRequest</h2>
<p>该库提供了<code>constructPermissionsRequest</code>您可以使用给定的几个回调函数构造请求者对象的方法，以便在适当的情况下调用。</p>
<pre><code class="language-java">/* * 
* @param 权限 [requiresPermission] 需要的权限。
* @param onShowRationale 该方法解释了为什么需要权限。
* @param onPermissionDenied 用户未授予权限时调用的方法。
* @param onNeverAskAgain 如果用户不使用
*“不再询问”选项
拒绝权限，则调用该方法。* @param requiresPermission 该操作需要 [permissions]。
*/ fun FragmentActivity /*(or Fragment )*/.constructPermissionsRequest(
     vararg permissions : String ,
     onShowRationale : ShowRationaleFunc ? 
    = null,
     onPermissionDenied :  Func ? = null,
     onNeverAskAgain :  Func ? = null,
     requiresPermission :  Func ): PermissionsRequester
</code></pre>
<p>在这里你只需定义<code>showCamera</code>，使用该库，您无需手动覆盖<code>onRequestPermissionsResult.</code></p>
<blockquote>
<p>注意：确保每次创建活动时都构造一个请求者以适当地捕获回调。</p>
</blockquote>
<p>完整使用示例</p>
<pre><code class="language-java">class MainActivity: AppCompatActivity {
    // constructPermissionsRequest must be invoked every time an activity is created 
    private val showCamera = constructPermissionsRequest(Manifest.permission.CAMERA,
        onShowRationale = ::onCameraShowRationale,
        onPermissionDenied = ::onCameraDenied,
        onNeverAskAgain = ::onCameraNeverAskAgain) {
		    // do something here
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        findViewById(R.id.button_camera).setOnClickListener {
            // 这里发起权限请求
            showCamera.launch()
        }
    }

    // 用户未授予权限时调用
    private fun onCameraDenied() {
        Toast.makeText(requireContext(), R.string.permission_camera_denied, Toast.LENGTH_SHORT).show()
    }

    // 解释为什么需要权限
    private fun onCameraShowRationale(request: PermissionRequest) {
        // 继续请求操作
        request.proceed()
    }

    // 用户勾选“不再询问”选项时调用
    private fun onCameraNeverAskAgain() {
        Toast.makeText(requireContext(), R.string.permission_camera_never_ask_again, Toast.LENGTH_SHORT).show()
    }
}
</code></pre>
<hr>
<h1 id="三-拓展用法">三、拓展用法</h1>
<h2 id="1location-permissions位置权限">1.Location Permissions——位置权限</h2>
<blockquote>
<p>Since the location permissions have been one of the most sensitive permission group to deal with, we provide a dedicated method <code>constructLocationPermissionRequest</code>. With the method you don't have to think of which API version you can ask <code>ACCESS_BACKGROUND_LOCATION</code>(see the issue for more detail).<br>
由于位置权限一直是要处理的最敏感的权限组之一，因此我们提供了专门的方法<code>constructLocationPermissionRequest</code>。使用该方法，您不必考虑可以询问<a href="https://developer.android.com/about/versions/10/privacy/changes#app-access-device-location">ACCESS_BACKGROUND_LOCATION</a>的API 版本（有关更多详细信息，请参阅<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/646">问题</a>）。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructLocationPermissionRequest(
    vararg permissions: LocationPermission,
    onShowRationale: ShowRationaleFun? = null,
    onPermissionDenied: Fun? = null,
    onNeverAskAgain: Fun? = null,
    requiresPermission: Fun
): PermissionsRequester

</code></pre>
<p><strong>注：设备位置权限的访问控制</strong><br>
用户可以更好地控制应用何时可以访问设备位置。当在Android Q上运行的应用程序请求位置访问时，会通过对话框的形式给用户进行授权提示。此对话框允许用户授予对两个不同范围的位置访问权限：在使用中（仅限前台）或始终（前台和后台）。<br>
新增权限 <code>ACCESS_BACKGROUND_LOCATION</code><br>
如果你的应用针对 <code>Android Q</code> 并且需要在后台运行时访问用户的位置，则必须在应用的清单文件中声明新权限</p>
<pre><code class="language-java">&lt;manifest&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;
&lt;/manifest&gt;
</code></pre>
<h2 id="2special-permissions特殊权限">2.Special Permissions——特殊权限</h2>
<blockquote>
<p>The library also provides <code>constructWriteSettingsPermissionRequest</code> and <code>constructSystemAlertWindowPermissionRequest</code> to support <code>WRITE_SETTINGS</code> and <code>SYSTEM_ALERT_WINDOW</code> that requires exceptional handling.<br>
该库还提供<code>constructWriteSettingsPermissionRequest</code>和 <code>constructSystemAlertWindowPermissionRequest</code>支持<code>WRITE_SETTINGS</code>，<code>SYSTEM_ALERT_WINDOW</code>这需要特殊处理。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructWriteSettingsPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester

 /**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructSystemAlertWindowPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 实现篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/">
        </link>
        <updated>2021-07-04T15:57:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">CSDN-谷歌开发者 打造 Material 颜色主题 | 实现篇</a><br>
<em>作者 / Nick Rout, Material Developer Advocate</em></p>
</blockquote>
<p>使用 Material 主题自定义 Material 组件，目的是让组件观感与品牌保持一致。Material 主题包括颜色、字体和形状参数，您可以对这些参数进行调整来获得近乎无限的组件变体，同时保持其核心结构和易用性。</p>
<ul>
<li>
<p>Material 主题<br>
https://material.io/design/material-theming/overview.html#material-theming</p>
</li>
<li>
<p>Material 组件<br>
https://material.io/components</p>
</li>
<li>
<p>Material 颜色<br>
https://material.io/design/color/</p>
</li>
<li>
<p>Material 字体<br>
https://material.io/design/typography/</p>
</li>
<li>
<p>Material 形状<br>
https://material.io/design/shape/<br>
<img src="https://jgduan.github.io//post-images/1625414383767.gif" alt="" loading="lazy"></p>
</li>
</ul>
<p>在 Android 上可使用 1.1.0 版本及以上的 Material 组件 (Material Design Components, MDC) 库来实现 Material 主题。如果您希望从 Design Support Library 或 MDC 1.0.0 迁移到新版本的 MDC，请参阅我们的迁移指南。</p>
<ul>
<li>
<p>Material 组件<br>
https://github.com/material-components/material-components-android</p>
</li>
<li>
<p>迁移指南<br>
https://medium.com/androiddevelopers/migrating-to-material-components-for-android-ec6757795351</p>
</li>
</ul>
<p>继上次我们发布<a href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">《打造 Material 颜色主题 | 设计篇》</a>之后，本文为大家介绍如何实现颜色主题。</p>
<hr>
<h2 id="颜色属性">颜色属性</h2>
<p>Material Design 提供可供填充的 12 个颜色 &quot;槽 (slots)&quot;，这些色值构成应用的整体调色板。每个 &quot;槽&quot; 都有一个设计术语 (如 Primary)，该术语则对应一个可在应用主题中覆盖的颜色属性 (如 Primary 这个术语对应 colorPrimary 这个颜色属性)。这些是您的浅色和深色主题默认的基准色值。</p>
<p><img src="https://jgduan.github.io//post-images/1625414532132.png" alt="" loading="lazy"><br>
△ 浅色主题的基准 MDC 颜色属性</p>
<p><img src="https://jgduan.github.io//post-images/1625414555733.png" alt="" loading="lazy"><br>
△ 深色主题的基准 MDC 颜色属性</p>
<p>Material 组件使用这些颜色属性为各个 widget 着色。<br>
<img src="https://jgduan.github.io//post-images/1625414580741.png" alt="" loading="lazy"><br>
△ 一个按钮中用到的颜色属性</p>
<p>例如，将颜色属性用于布局和 widget 样式中，写法如下所示:<br>
<code>app:backgroundTint=”?attr/colorSecondary”</code><br>
您可能会认得下表中的一些颜色属性，如 colorPrimary。这些因为一些颜色属性继承自 AppCompat 和平台本身，而其余属性则来由 MDC。每个颜色属性的完整来源见下表。<br>
<img src="https://jgduan.github.io//post-images/1625414617487.png" alt="" loading="lazy"></p>
<hr>
<h2 id="挑选颜色">挑选颜色</h2>
<p>主题里每个颜色槽应该使用的具体颜色值由设计师负责给出，或是取自您的产品品牌。但是，了解每个颜色的作用、颜色之间的关系以及如何满足无障碍功能要求仍非常有用:</p>
<ul>
<li>
<p>colorPrimary 和 colorSecondary 是用于呈现品牌的颜色</p>
</li>
<li>
<p>colorPrimaryVariant 和 colorSecondaryVariant 是品牌颜色较浅或较深的阴影色</p>
</li>
<li>
<p>colorSurface 用于表单或表面 (如卡片颜色和应用的底部弹出菜单颜色)</p>
</li>
<li>
<p>android:colorBackground 是应用的窗口背景颜色</p>
</li>
<li>
<p>顾名思义，colorError 用于错误和警告</p>
</li>
<li>
<p>各种各样的 &quot;On&quot; 颜色 (colorOnPrimary、colorOnSecondary、colorOnSurface 等) 用于<br>
为显示在其他颜色上方的前景内容 (如文本和图标) 进行着色。这些颜色需要满足无障碍功能要求并与所在表面的颜色有足够的对比度。</p>
</li>
</ul>
<hr>
<h2 id="颜色工具">颜色工具</h2>
<p>Material Design 为大家提供了丰富的工具，用于预览颜色、确定合适的变体颜色以及 &quot;On&quot; 颜色:</p>
<ul>
<li>
<p>Material 颜色工具: 获得主色和辅色的浅色/深色变体以及合适的 &quot;On&quot; 颜色。并能在示例界面中预览这些颜色的效果。<br>
https://material.io/resources/color/</p>
</li>
<li>
<p>Material 调色板生成器: 生成完整的色调调色板 (即包含 Material 色值编号 50 - 900)。另外您还能获得互补色、近似色和三等分配色的建议。<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625414775321.png" alt="" loading="lazy"><br>
△ Material 颜色工具 (左) 和 Material 调色板生成器 (右)</p>
<hr>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>除非您的品牌恰巧使用和基准 Material 主题色完全相同的紫色和蓝绿色，否则请您务必覆盖 colorPrimary、colorSecondary 及其变体色。</li>
<li>您无需覆盖所有颜色。一些颜色 (如 colorSurface) 默认使用的就是中性颜色，因此使用默认值不会有什么问题。</li>
<li>如果您的品牌没有定义任何种类的辅色或强调色，那么可以将一种颜色同时用于 colorPrimary 和 colorSecondary。变体色也可以和主色相同 (即 colorPrimary 和 colorPrimaryVariant 可以相同)。</li>
<li>一个颜色和其变体颜色以及 &quot;On&quot; 颜色尽管是三个单独的颜色属性 (如 colorPrimary、colorPrimaryVariant 和 colorOnPrimary)，但它们之间依然存在紧密的联系。因此如果您覆盖了其中一个，请检查其他颜色属性，以查看是否可行且满足无障碍功能要求。</li>
</ul>
<hr>
<h2 id="其他颜色槽">其他颜色槽</h2>
<p>除 Material 主题指定的 12 个颜色槽以外，您的设计系统可能还会用到其他颜色槽。幸运的是，在 Android 上声明颜色属性的操作很简单:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;attr name=&quot;colorCustom&quot; format=&quot;color&quot; /&gt;
 
&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.MaterialComponents.*&quot;&gt;
    ...
    &lt;item name=&quot;colorCustom&quot;&gt;@color/...&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="颜色资源">颜色资源</h2>
<p>颜色值会被定义为 <code>&lt;color&gt;</code> 资源。对于自定义颜色，我们建议使用以下两种方法，以帮助区分关注点，并在应用中为颜色主题中的色值创建单一来源:</p>
<ul>
<li>将浅色和深色主题用到的全部<code>&lt;color&gt;</code>存储在一个 res/values/colors.xml 文件中</li>
<li><code>&lt;color&gt;</code>色值使用字面名称命名 (而不是基于使用方式命名):
<ul>
<li>如此一来，便可以在使用颜色时更自然地用到 ?attr/ 语法。支持深色主题时也推荐采用此种方法</li>
<li>使用 green_500 或 brand_name_yellow 等名称</li>
<li>避免使用语义名称，如 color_primary<pre><code class="language-java">&lt;!-- In res/values/colors.xml --&gt;
&lt;color name=&quot;navy_500&quot;&gt;#64869B&lt;/color&gt;
&lt;color name=&quot;navy_700&quot;&gt;#37596D&lt;/color&gt;
&lt;color name=&quot;navy_900&quot;&gt;#073042&lt;/color&gt;
&lt;color name=&quot;green_300&quot;&gt;#3DDC84&lt;/color&gt;
&lt;color name=&quot;green_500&quot;&gt;#00A956&lt;/color&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="覆盖应用主题中的颜色">覆盖应用主题中的颜色</h2>
<p>让我们了解一下如何通过覆盖相关属性将您自己的调色板应用到主题中。</p>
<p>首先，您的主题需要在妥善处理浅色和深色调色板的同时减少与基础主题的重复。有关这方面的更多信息，请参阅 Chris Banes 关于深色主题的文章以及 Chris Banes 和 Nick Butcher 的 &quot;如何正确开发外观样式&quot; 演讲。</p>
<p>设置好主题后，覆盖您希望在浅色和深色主题中更改的颜色属性即可:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_700&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_900&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
 
 
&lt;!-- In res/values-night/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_500&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
</code></pre>
<p>Material 组件将根据主题全局应用您覆盖好的颜色:<br>
<img src="https://jgduan.github.io//post-images/1625415001473.gif" alt="" loading="lazy"></p>
<hr>
<h2 id="颜色复用性和最佳实践">颜色复用性和最佳实践</h2>
<p>在许多情况下，都要在布局、可绘制对象、样式和其他位置使用颜色。我们将介绍一些可尽量复用代码的方法，而且不会影响您在应用主题中指定的色值。</p>
<hr>
<h2 id="首选属性">首选属性</h2>
<p>我们强烈建议使用 ?attr/ 语法来设置颜色。在创建可复用的布局和支持多个模式 (如浅色/深色) 的默认样式时，尤其推荐使用这种语法。</p>
<pre><code class="language-java">&lt;Button
    ...
-    app:backgroundTint=&quot;@color/green_300&quot;
+    app:backgroundTint=&quot;?attr/colorPrimary&quot;
-    android:textColor=&quot;@color/black&quot;
+    android:textColor=&quot;?attr/colorOnPrimary&quot;
/&gt;
</code></pre>
<p>请参阅 Nick Butcher 的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce90bb7fb601dd9e144ae796eb466a2ed805bf14dbc0906543509d95c24733b05bd7fc12c&amp;idx=2&amp;mid=2652064078&amp;scene=21&amp;sn=884a85bfa4f9e19ec531b8245dca6314#wechat_redirect">《Android 样式系统 | 主题背景属性》</a>，以了解更多说明和此规则的一些例外情况。</p>
<hr>
<h2 id="带有-alpha-的颜色">带有 alpha 的颜色</h2>
<p>有时，您可能希望使用 MDC 主题中的一种颜色，但带上 alpha 值 (例如 60% 的 colorPrimary)。例如，触发点击时的波纹动画和项目被选中的状态。</p>
<p>Android<code>&lt;color&gt;</code>资源支持 alpha 通道:</p>
<pre><code class="language-java">&lt;!-- 60% alpha = 99 --&gt;
 
 
&lt;color name=”navy_700_alpha_60”&gt;#9937596D&lt;/color&gt;
</code></pre>
<p>但是，在使用此方法时，我们需要将每个带 alpha 的色值视作颜色资源。这也意味着我们不能用 ?attr/ 来使用这些颜色资源，因为这种做法违背了上文提及的唯一来源准则。</p>
<p>因此，我们建议使用 res/color 目录中存储的 ColorStateList (CSL)。CSL 里的项目可以包含一个颜色引用和 alpha 值，这非常适合我们的用例:</p>
<pre><code class="language-java">&lt;!-- In res/color/primary_60.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:alpha=&quot;0.6&quot; android:color=&quot;?attr/colorPrimary&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<p>使用这些 CSL (通过 @color/primary_60 语法进行引用) 可能会让您感到惊讶，但考虑到 CSL 本身也使用 ?attr/ 来引用底层的主题颜色，因此这样做不会有什么问题。</p>
<hr>
<h2 id="每种状态的颜色和主题叠加">每种状态的颜色和主题叠加</h2>
<p>更为常见的情况是根据视图状态使用 ColorStateList 切换颜色 (和 alpha 值)。MDC widget 大量将其用于禁用状态、悬停状态和按压状态等。比如下面是一个 MDC 按钮的背景色源代码:</p>
<pre><code class="language-java">&lt;!-- In button/res/color/mtrl_btn_bg_color_selector.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:color=&quot;?attr/colorPrimary&quot; android:state_enabled=&quot;true&quot; /&gt;
    &lt;item android:alpha=&quot;0.12&quot; android:color=&quot;?attr/colorOnSurface&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<ul>
<li>完整源代码<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/color/mtrl_btn_bg_color_selector.xml</li>
</ul>
<p>和上面这个按钮的示例类似，假设您希望将主背景色从主色改为辅色:<br>
<img src="https://jgduan.github.io//post-images/1625415175159.png" alt="" loading="lazy"><br>
△ 主色按钮 (左) 和辅色按钮 (右)</p>
<p>您当然可以将以上源文件复制一份，然后将 colorPrimary 改为 colorSecondary，但如果源代码恰巧发生更改，那么此操作会很繁琐且会出现问题。</p>
<p>一种更好的方式是使用主题叠加。Nick Butcher 在他的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf83fb7fb71294558ac5b10882278fb1f53ed3fd7038013c19d2554ff85e20b014fe9ac4b&amp;idx=1&amp;mid=2652067962&amp;scene=21&amp;sn=71a1bc1726c40ccda245f366ae4a51bb#wechat_redirect">《Android 样式系统 | 主题背景覆盖》</a>一文中对此有详细的介绍。基本上，我们可以替换 View 或 ViewGroup 的主题属性值 (在我们例子中为 colorPrimary) 以及所有依赖它的项目 (在我们的例子中为按钮)。</p>
<p>下面是一个主题叠加的简单例子。请注意 parent 为空，其作用是确保我们仅覆盖希望更改的属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;ThemeOverlay.App.PrimarySecondary&quot; parent=&quot;&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;?attr/colorSecondary&lt;/item&gt;
    &lt;item name=&quot;colorOnPrimary&quot;&gt;?attr/colorOnSecondary&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在 XML 中应用主题叠加时，应考虑两个选项:</p>
<ul>
<li>android:theme - 用于所有 widget，不会以默认样式工作</li>
<li>app:materialThemeOverlay - 仅用于 MDC widget，以默认样式工作</li>
</ul>
<pre><code class="language-java">&lt;Button
    ...
    &lt;!-- Alternatively apply with android:theme --&gt;
+    app:materialThemeOverlay=&quot;@style/ThemeOverlay.App.PrimarySecondary&quot;
/&gt;
</code></pre>
<hr>
<h2 id="api-兼容性">API 兼容性</h2>
<p>平台是在 API 23 才开始在 CSL 等处增加对 ?attr/ 语法的支持。如果您的 minSdk 是更早的版本，也不要担心: 有兼容性类！事实上，MDC 和 AppCompat widget 都有在底层使用这些兼容性类，因此在使用时无需其他操作。</p>
<p>对于需要以编程方式使用 CSL 的场景，请使用 AppCompatResources:</p>
<pre><code class="language-java">val primary60 = AppCompatResources#getColorStateList(
    context, R.color.primary60
)
</code></pre>
<ul>
<li>AppCompatResources<br>
https://developer.android.google.cn/reference/androidx/appcompat/content/res/AppCompatResources</li>
</ul>
<hr>
<h2 id="mdc-widget-中的颜色">MDC widget 中的颜色</h2>
<p>之前我们曾说过，MDC widget 会响应主题级别的颜色属性覆盖。但是，您是如何知道按钮会将 colorPrimary 用作其背景着色并将 colorOnPrimary 用于其图标和文本呢？让我们来看一下几个选项。</p>
<hr>
<h2 id="构建-material-主题">构建 Material 主题</h2>
<p>构建 Material 主题是一个交互式 Android 项目，支持您通过自定义颜色、字体和形状来创建自己的 Material 主题。项目还包含所有主题中用到的参数和组件的目录。可通过执行以下操作确定哪些 widget 会对主题颜色属性的更改作出响应:</p>
<ul>
<li>
<p>复制这个项目并在 Android Studio 中运行应用</p>
</li>
<li>
<p>调整 res/values/color.xml 以及 res/values/themes.xml 和 res/values-night/themes.xml 中的色值</p>
</li>
<li>
<p>重新运行应用，观察视觉变化</p>
</li>
<li>
<p>构建 Material 主题<br>
https://material.io/resources/build-a-material-theme</p>
</li>
<li>
<p>项目源代码<br>
https://github.com/material-components/material-components-android-examples/tree/develop/MaterialThemeBuilder</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415351635.png" alt="" loading="lazy"><br>
△ 构建 Material 主题中的色值变化</p>
<hr>
<h2 id="mdc-开发者文档">MDC 开发者文档</h2>
<p>最近我们更新了 MDC 开发者文档。在本次更新中，我们加入了属性表，涵盖了开发库中所使用的设计术语和默认值。例如下面是更新的按钮文档的 &quot;Anatomy and key properties&quot; (详解和关键属性) 部分。<br>
<img src="https://jgduan.github.io//post-images/1625415378990.png" alt="" loading="lazy"><br>
△ MDC 按钮开发文档的属性表中提供了默认色值</p>
<ul>
<li>按钮文档<br>
https://github.com/material-components/material-components-android/blob/master/docs/components/Button.md</li>
</ul>
<hr>
<h2 id="源代码">源代码</h2>
<ul>
<li>
<p>MaterialButton 样式<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/styles.xml</p>
</li>
<li>
<p>MaterialButton 属性<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/attrs.xml</p>
</li>
<li>
<p>MaterialButton 源文件<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/MaterialButton.java</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415449219.png" alt="" loading="lazy"><br>
△ MDC 按钮的默认样式和色值</p>
<hr>
<h2 id="自定义视图中的颜色">自定义视图中的颜色</h2>
<p>您的应用可能包含您自己构建或从现有库中获得的自定义 widget。在和 MDC 一起使用时，使这些视图对 Material 主题作出响应非常必要。让我们看一看在将颜色主题用于自定义 widget 时需要牢记的事项。</p>
<p>在<code>&lt;declare-styleable&gt;</code>和默认样式中使用 MDC 属性</p>
<p>为自定义视图设置样式需要使用<code>&lt;declare-styleable&gt;</code>。在保持一致性方面，复用 MDC 中的属性名称非常有用。使用<code>&lt;declare-styleable&gt;</code>的默认样式还可以使用 MDC 主题颜色属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;declare-styleable name=&quot;AppCustomView&quot;&gt;
    &lt;attr name=&quot;backgroundTint&quot; /&gt;
    &lt;attr name=&quot;titleTextColor&quot; /&gt;
    ...
&lt;/declare-styleable&gt;
 
 
&lt;!-- In res/values/styles.xml --&gt;
&lt;style name=&quot;Widget.App.CustomView&quot; parent=&quot;android:Widget&quot;&gt;
    &lt;item name=&quot;backgroundTint&quot;&gt;?attr/colorSurface&lt;/item&gt;
    &lt;item name=&quot;titleTextColor&quot;&gt;
        @color/material_on_surface_emphasis_high_type
    &lt;/item&gt;
    ...
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="materialcolors-实用程序类">MaterialColors 实用程序类</h2>
<p>可以通过便利的新 MDC 类 (MaterialColors) 以编程方式处理主题的颜色属性，这对于自定义视图也非常有用:</p>
<pre><code class="language-java">// Resolve color from theme attr
val primaryColor = MaterialColors.getColor(
    view, R.attr.colorPrimary
)
 
 
// Layer background color with overlay color + alpha
val overlayedColor = MaterialColors.layer(
    view, R.attr.colorSurface, R.attr.colorPrimary, 0.38f
)
</code></pre>
<hr>
<h2 id="下一步">下一步</h2>
<p>现在，我们已经在 Android 应用中使用 MDC 实现了颜色主题。有关 Material 主题的其他课题，请阅读我们相关的介绍文章。</p>
<ul>
<li>
<p>为什么推荐使用 MDC<br>
https://medium.com/androiddevelopers/we-recommend-material-design-components-81e6d165c2dd</p>
</li>
<li>
<p>字体主题<br>
https://material.io/blog/android-material-theme-type</p>
</li>
<li>
<p>形状主题<br>
https://material.io/blog/android-material-theme-shape</p>
</li>
<li>
<p>深色主题<br>
https://medium.com/androiddevelopers/dark-theme-with-mdc-4c6fc357d956</p>
</li>
<li>
<p>动效系统<br>
https://material.io/blog/android-material-motion</p>
</li>
</ul>
<p>我们一如既往地期待您在 GitHub 上提交错误报告和功能需求。另外，请务必查看 Android 组件示例应用。</p>
<ul>
<li>
<p>提交错误报告<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md&amp;title=%5BComponent+name%5D+Short+description+of+issue</p>
</li>
<li>
<p>提交功能需求<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=feature+request&amp;template=feature_request.md&amp;title=%5BComponent+name%5D+Short+description+of+request</p>
</li>
<li>
<p>Android 组件示例应用<br>
https://github.com/material-components/material-components-android-examples</p>
</li>
</ul>
<p>如果您已成功实现颜色主题或您在实现期间遇到问题，欢迎在下方评论区和我们分享。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 设计篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">
        </link>
        <updated>2021-07-01T15:02:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109475532">CSDN-谷歌开发者 打造 Material 颜色主题 | 设计篇</a><br>
<em>作者 / Liam Spradlin, Material Design Advocate</em></p>
</blockquote>
<p>颜色是设计中最清晰的表现形式之一，尤其是当您需要在人们的各种活动场合中传播您的品牌或产品形象时。应用的界面可容纳丰富的颜色，不仅可以用于打造产品形象，而且由于用户可以直接触摸和操作界面，因此在传播产品形象的同时又能与用户的生活和体验紧密联系，并增强产品的功能、实用性和个性。</p>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwODY4OTk2Mg%3D%3D&amp;action=getalbum&amp;album_id=1340817101657014273#wechat_redirect">Material Design</a> 包含全面的颜色系统，可以让设计师和开发者制定全局颜色决策，并能够有效管理界面状态、强调重点和对比度等问题，使这些颜色决策贯穿于产品的各个层级。</p>
<hr>
<h1 id="material-中的颜色">Material 中的颜色</h1>
<p>为了实现上述目标，Material 使用一组定义好的颜色取值，构成 &quot;颜色主题&quot;。颜色主题包含主要 (Primary) 颜色和次要 (Secondary) 颜色，它们可用于关键组件，另外还包含用于自定义背景 (Background) 色、表面 (Surface) 颜色 (用于呈现抬升的表面或 &quot;纸张&quot;) 和错误 (Error) 颜色的色值。<br>
<img src="https://jgduan.github.io//post-images/1625152307401.png" alt="基准 Material 颜色主题" loading="lazy"><br>
△ 基准 Material 颜色主题</p>
<p>还有一些色值用于 &quot;On&quot; 颜色，顾名思义，它们是出现在其他元素上方的颜色。例如，On Primary 可用于呈现在应用的主要颜色上方显示的文本、图标或其他元素。比如下图展示了带有菜单图标和标题的应用栏，其中的图表和文字都使用 &quot;On&quot; 颜色来确保内容具备适当的对比度和可读性。<br>
<img src="https://jgduan.github.io//post-images/1625152360593.png" alt="" loading="lazy"></p>
<p>对于诸如状态等更加细微的颜色使用场景，Material 使用 &quot;色调调色板&quot;。色调调色板会基于您所选择的颜色提供一组十个值，提供了减淡和加深的选项，可使您的颜色主题更加灵活。<br>
<img src="https://jgduan.github.io//post-images/1625152382453.png" alt="" loading="lazy"></p>
<p>△ 上图中的界面使用主要颜色以及两个主要颜色变体，并应用到所有组件中</p>
<hr>
<h1 id="选择品牌颜色">选择品牌颜色</h1>
<h2 id="从头开始">从头开始</h2>
<p>如果您要从头开始构建颜色主题，也就是说如果您没有现成的品牌调色板，那么最好先充分思考您应用的特质。在我们的 Material Studies 专栏 (基于现实用例和产品约束设计的示例应用) 中，您可以看到根据各种应用的功能和个性所采用的多种基于颜色的品牌化方案。</p>
<ul>
<li>
<p>Material Studies<br>
https://material.io/design/material-studies/about-our-material-studies.html</p>
<p>您的应用是否像暗色调的个人理财应用 Rally 一样，是一款可以帮助人们高效解析信息的实用工具？是否像现代而精致的购物应用 Shrine 一样，能够以精致的美学和粉红色调激发用户的兴趣？或者，也许像教育应用 Owl 一样，能够通过生动的配色来提供更加有趣的教学体验。在每个用例中，颜色在打造和增强应用的个性方面都起着重要作用。<br>
<img src="https://jgduan.github.io//post-images/1625152528876.png" alt="" loading="lazy"><br>
△ Rally 的每个信息图表都使用了两种取自其颜色主题的颜色</p>
<p>对于像 Rally 这样的应用而言，其功能旨在查看和管理个人财务数据，因此必须选用一种深沉的配色方案。该应用的主要颜色为绿色，On 颜色为白色，背景色则为深灰色调。其他颜色均极为深沉，用于在各种信息展示界面中以实用的方式呈现数据。</p>
</li>
<li>
<p>Rally<br>
https://material.io/design/material-studies/rally.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152585442.png" alt="" loading="lazy"><br>
△ Owl 使用三种颜色主题来区分应用中的不同部分</p>
<p>与 Rally 截然相反，Owl 通过在其颜色主题中使用三种不同的主要颜色，打造出鲜活有趣的使用氛围。尽管 Owl 事实上可以被视为在同一个应用中采用了三种不同的颜色主题，但这些颜色却因生动鲜明的共同特征而紧密关联 (它们各自趋近色轮中的三原色: 红、黄、蓝)。</p>
</li>
<li>
<p>Owl<br>
https://material.io/design/material-studies/owl.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152619523.png" alt="" loading="lazy"><br>
△ Shrine 在关健组件和版面设计中采用了简单的颜色主题</p>
<p>Shrine 则介于以上两款应用之间。这款应用具有个性鲜明的色彩表现，使用奶油粉色调作为主要颜色和次要颜色，并使用深棕色作为 On 颜色。虽然 Shrine 的调色板十分独特，但在应用中以专注而精致的方式应用这种色调，能够体现出 Shrine 想要展现的个性形象，打造出一个现代而优雅的时尚和生活购物助手。</p>
</li>
<li>
<p>Shrine<br>
https://material.io/design/material-studies/shrine.html</p>
<p>从头开始制作自己的主题时，请考虑您的应用在上述示例所覆盖的范围中所处的位置。首先，请选择一种能够最贴切地表达应用个性和用途的主要颜色。然后，根据您对应用观感的设想，选择可以增强或调节这些特质的次要颜色。请考虑如何使用 On 颜色，或对表面或背景应用新的颜色以增强表现力。</p>
</li>
</ul>
<h2 id="如果您已有品牌调色板">如果您已有品牌调色板</h2>
<p>在为您的应用构建颜色主题时，您可能已经具有可以轻松转换为 Material 颜色主题的品牌调色板。这种情况下，您可能已经拥有品牌指南，其中涵盖了应优先考虑的颜色以及如何概念化品牌个性或色调方面的内容。您可以将指南内容与前文提到的信息相结合，确定要在颜色主题中包含哪些颜色。</p>
<p>如果您已有品牌调色板但没有指南，请浏览现有的品牌物料或界面设计，然后与调色板进行对比，确定应优先考虑采用哪些颜色作为主要颜色和次要颜色。测试这些颜色以确定它们是否能带来方便阅读的对比度。如果效果不佳，您可以从色调调色板中选择效果理想的颜色变体。</p>
<ul>
<li>测试颜色<br>
https://material.io/tools/color</li>
</ul>
<h2 id="使用调色板生成器扩展调色板">使用调色板生成器扩展调色板</h2>
<p>基于确定下来的几种颜色，可以使用调色板生成器对颜色取值进行扩展，从而满足更多场合的需求。只需在生成器右侧添加所选颜色，然后点击每个生成的色样即可复制其十六进制色值。</p>
<ul>
<li>
<p>调色板生成器<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625152728551.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="呈现主题">呈现主题</h2>
<p>选择一些颜色并将其扩展为色调调色板后，您就可以通过将颜色代入到 Material Design 提供的色谱中来实际创建颜色主题了。</p>
<ul>
<li>
<p>色调调色板<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<p>要在设计工具中进行此操作 (并在 Material Components 上获得主题的即时预览)，请下载我们的 Figma 基准设计工具包。在工具包内的 Material Theme 页面中，您将看到一个名为 Color 的框架，该框架全面展示了您的颜色主题，包括了色调调色板。</p>
</li>
<li>
<p>Figma 基准设计工具包<br>
https://www.figma.com/@materialdesign</p>
<figure data-type="image" tabindex="2"><img src="https://jgduan.github.io//post-images/1625152787143.png" alt="" loading="lazy"></figure>
<p>在上图右侧，您会看到一个面板，在 Color Styles 下方包含了与主题中的颜色相符的全局样式。要开始将颜色插入到主题中，请点击每种颜色样式旁边的编辑图标。返回到生成器中的色调调色板，然后点击工具中的每个色样以复制其十六进制色值，然后将其输入到 Figma 中您选择的样式中。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://jgduan.github.io//post-images/1625152807417.png" alt="" loading="lazy"></figure>
<p>当主要颜色和次要颜色的色样处理完成后，请查看 Figma 界面左边的 Stickersheet 页面以查看主题在每个组件上的显示效果。</p>
<hr>
<h1 id="下一步-实现">下一步: 实现</h1>
<p>完成了上述操作后，您还可以尝试调整表面、背景和错误颜色来优化这个全新的颜色主题。您也可以尝试通过创建多个主题 (例如上文中的 Owl 示例) 来利用颜色系统实现更多创意。</p>
<p>在创建出完美的颜色主题后，您就可以准备实现它了。请大家关注我们接下来会发布的文章<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">《打造 Material 颜色主题 | 实现篇》</a>。</p>
<hr>
<h1 id="推荐阅读">推荐阅读</h1>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf031b7fb79276e6792f13b342073c99a0b8118a9bb2b6b995a5cad6fa57dc58b55993e07&amp;idx=1&amp;mid=2652065908&amp;scene=21&amp;sn=8af70145ec89870c138818a38f005ed0#wechat_redirect">跨设备设计基础 | 如何确定任意屏幕的分辨率指标</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cec31b7fb65275fa39b276c69cf670cfcd8f2395b532953c27bb48d368fe40638a225d4f1&amp;idx=1&amp;mid=2652064884&amp;scene=21&amp;sn=e407e1d047f415309b7b120e1265ce9c#wechat_redirect">使用 Material Design 组件实现深色主题</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce8fbb7fb61ede45fa93a0d8d5464935f48f28601f2db5d5ea8d60863fe2392f2361cffae&amp;idx=1&amp;mid=2652063934&amp;scene=21&amp;sn=caeaec14e70b7569c06503b1bb04138b#wechat_redirect">Android Material 组件 1.2.0 现已发布</a></li>
</ul>
<hr>
]]></content>
    </entry>
</feed>