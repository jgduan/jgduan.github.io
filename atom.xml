<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-07-01T15:23:39.970Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 设计篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">
        </link>
        <updated>2021-07-01T15:02:38.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109475532">CSDN-谷歌开发者 打造 Material 颜色主题 | 设计篇</a><br>
<em>作者 / Liam Spradlin, Material Design Advocate</em></p>
</blockquote>
<p>颜色是设计中最清晰的表现形式之一，尤其是当您需要在人们的各种活动场合中传播您的品牌或产品形象时。应用的界面可容纳丰富的颜色，不仅可以用于打造产品形象，而且由于用户可以直接触摸和操作界面，因此在传播产品形象的同时又能与用户的生活和体验紧密联系，并增强产品的功能、实用性和个性。</p>
<p><a href="https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzAwODY4OTk2Mg%3D%3D&amp;action=getalbum&amp;album_id=1340817101657014273#wechat_redirect">Material Design</a> 包含全面的颜色系统，可以让设计师和开发者制定全局颜色决策，并能够有效管理界面状态、强调重点和对比度等问题，使这些颜色决策贯穿于产品的各个层级。</p>
<hr>
<h1 id="material-中的颜色">Material 中的颜色</h1>
<p>为了实现上述目标，Material 使用一组定义好的颜色取值，构成 &quot;颜色主题&quot;。颜色主题包含主要 (Primary) 颜色和次要 (Secondary) 颜色，它们可用于关键组件，另外还包含用于自定义背景 (Background) 色、表面 (Surface) 颜色 (用于呈现抬升的表面或 &quot;纸张&quot;) 和错误 (Error) 颜色的色值。<br>
<img src="https://jgduan.github.io//post-images/1625152307401.png" alt="基准 Material 颜色主题" loading="lazy"><br>
△ 基准 Material 颜色主题</p>
<p>还有一些色值用于 &quot;On&quot; 颜色，顾名思义，它们是出现在其他元素上方的颜色。例如，On Primary 可用于呈现在应用的主要颜色上方显示的文本、图标或其他元素。比如下图展示了带有菜单图标和标题的应用栏，其中的图表和文字都使用 &quot;On&quot; 颜色来确保内容具备适当的对比度和可读性。<br>
<img src="https://jgduan.github.io//post-images/1625152360593.png" alt="" loading="lazy"></p>
<p>对于诸如状态等更加细微的颜色使用场景，Material 使用 &quot;色调调色板&quot;。色调调色板会基于您所选择的颜色提供一组十个值，提供了减淡和加深的选项，可使您的颜色主题更加灵活。<br>
<img src="https://jgduan.github.io//post-images/1625152382453.png" alt="" loading="lazy"></p>
<p>△ 上图中的界面使用主要颜色以及两个主要颜色变体，并应用到所有组件中</p>
<hr>
<h1 id="选择品牌颜色">选择品牌颜色</h1>
<h2 id="从头开始">从头开始</h2>
<p>如果您要从头开始构建颜色主题，也就是说如果您没有现成的品牌调色板，那么最好先充分思考您应用的特质。在我们的 Material Studies 专栏 (基于现实用例和产品约束设计的示例应用) 中，您可以看到根据各种应用的功能和个性所采用的多种基于颜色的品牌化方案。</p>
<ul>
<li>
<p>Material Studies<br>
https://material.io/design/material-studies/about-our-material-studies.html</p>
<p>您的应用是否像暗色调的个人理财应用 Rally 一样，是一款可以帮助人们高效解析信息的实用工具？是否像现代而精致的购物应用 Shrine 一样，能够以精致的美学和粉红色调激发用户的兴趣？或者，也许像教育应用 Owl 一样，能够通过生动的配色来提供更加有趣的教学体验。在每个用例中，颜色在打造和增强应用的个性方面都起着重要作用。<br>
<img src="https://jgduan.github.io//post-images/1625152528876.png" alt="" loading="lazy"><br>
△ Rally 的每个信息图表都使用了两种取自其颜色主题的颜色</p>
<p>对于像 Rally 这样的应用而言，其功能旨在查看和管理个人财务数据，因此必须选用一种深沉的配色方案。该应用的主要颜色为绿色，On 颜色为白色，背景色则为深灰色调。其他颜色均极为深沉，用于在各种信息展示界面中以实用的方式呈现数据。</p>
</li>
<li>
<p>Rally<br>
https://material.io/design/material-studies/rally.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152585442.png" alt="" loading="lazy"><br>
△ Owl 使用三种颜色主题来区分应用中的不同部分</p>
<p>与 Rally 截然相反，Owl 通过在其颜色主题中使用三种不同的主要颜色，打造出鲜活有趣的使用氛围。尽管 Owl 事实上可以被视为在同一个应用中采用了三种不同的颜色主题，但这些颜色却因生动鲜明的共同特征而紧密关联 (它们各自趋近色轮中的三原色: 红、黄、蓝)。</p>
</li>
<li>
<p>Owl<br>
https://material.io/design/material-studies/owl.html</p>
<p><img src="https://jgduan.github.io//post-images/1625152619523.png" alt="" loading="lazy"><br>
△ Shrine 在关健组件和版面设计中采用了简单的颜色主题</p>
<p>Shrine 则介于以上两款应用之间。这款应用具有个性鲜明的色彩表现，使用奶油粉色调作为主要颜色和次要颜色，并使用深棕色作为 On 颜色。虽然 Shrine 的调色板十分独特，但在应用中以专注而精致的方式应用这种色调，能够体现出 Shrine 想要展现的个性形象，打造出一个现代而优雅的时尚和生活购物助手。</p>
</li>
<li>
<p>Shrine<br>
https://material.io/design/material-studies/shrine.html</p>
<p>从头开始制作自己的主题时，请考虑您的应用在上述示例所覆盖的范围中所处的位置。首先，请选择一种能够最贴切地表达应用个性和用途的主要颜色。然后，根据您对应用观感的设想，选择可以增强或调节这些特质的次要颜色。请考虑如何使用 On 颜色，或对表面或背景应用新的颜色以增强表现力。</p>
</li>
</ul>
<h2 id="如果您已有品牌调色板">如果您已有品牌调色板</h2>
<p>在为您的应用构建颜色主题时，您可能已经具有可以轻松转换为 Material 颜色主题的品牌调色板。这种情况下，您可能已经拥有品牌指南，其中涵盖了应优先考虑的颜色以及如何概念化品牌个性或色调方面的内容。您可以将指南内容与前文提到的信息相结合，确定要在颜色主题中包含哪些颜色。</p>
<p>如果您已有品牌调色板但没有指南，请浏览现有的品牌物料或界面设计，然后与调色板进行对比，确定应优先考虑采用哪些颜色作为主要颜色和次要颜色。测试这些颜色以确定它们是否能带来方便阅读的对比度。如果效果不佳，您可以从色调调色板中选择效果理想的颜色变体。</p>
<ul>
<li>测试颜色<br>
https://material.io/tools/color</li>
</ul>
<h2 id="使用调色板生成器扩展调色板">使用调色板生成器扩展调色板</h2>
<p>基于确定下来的几种颜色，可以使用调色板生成器对颜色取值进行扩展，从而满足更多场合的需求。只需在生成器右侧添加所选颜色，然后点击每个生成的色样即可复制其十六进制色值。</p>
<ul>
<li>
<p>调色板生成器<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625152728551.png" alt="" loading="lazy"></figure>
</li>
</ul>
<h2 id="呈现主题">呈现主题</h2>
<p>选择一些颜色并将其扩展为色调调色板后，您就可以通过将颜色代入到 Material Design 提供的色谱中来实际创建颜色主题了。</p>
<ul>
<li>
<p>色调调色板<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
<p>要在设计工具中进行此操作 (并在 Material Components 上获得主题的即时预览)，请下载我们的 Figma 基准设计工具包。在工具包内的 Material Theme 页面中，您将看到一个名为 Color 的框架，该框架全面展示了您的颜色主题，包括了色调调色板。</p>
</li>
<li>
<p>Figma 基准设计工具包<br>
https://www.figma.com/@materialdesign</p>
<figure data-type="image" tabindex="2"><img src="https://jgduan.github.io//post-images/1625152787143.png" alt="" loading="lazy"></figure>
<p>在上图右侧，您会看到一个面板，在 Color Styles 下方包含了与主题中的颜色相符的全局样式。要开始将颜色插入到主题中，请点击每种颜色样式旁边的编辑图标。返回到生成器中的色调调色板，然后点击工具中的每个色样以复制其十六进制色值，然后将其输入到 Figma 中您选择的样式中。</p>
</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://jgduan.github.io//post-images/1625152807417.png" alt="" loading="lazy"></figure>
<p>当主要颜色和次要颜色的色样处理完成后，请查看 Figma 界面左边的 Stickersheet 页面以查看主题在每个组件上的显示效果。</p>
<hr>
<h1 id="下一步-实现">下一步: 实现</h1>
<p>完成了上述操作后，您还可以尝试调整表面、背景和错误颜色来优化这个全新的颜色主题。您也可以尝试通过创建多个主题 (例如上文中的 Owl 示例) 来利用颜色系统实现更多创意。</p>
<p>在创建出完美的颜色主题后，您就可以准备实现它了。请大家关注我们接下来会发布的文章<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">《打造 Material 颜色主题 | 实现篇》</a>。</p>
<hr>
<h1 id="推荐阅读">推荐阅读</h1>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf031b7fb79276e6792f13b342073c99a0b8118a9bb2b6b995a5cad6fa57dc58b55993e07&amp;idx=1&amp;mid=2652065908&amp;scene=21&amp;sn=8af70145ec89870c138818a38f005ed0#wechat_redirect">跨设备设计基础 | 如何确定任意屏幕的分辨率指标</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cec31b7fb65275fa39b276c69cf670cfcd8f2395b532953c27bb48d368fe40638a225d4f1&amp;idx=1&amp;mid=2652064884&amp;scene=21&amp;sn=e407e1d047f415309b7b120e1265ce9c#wechat_redirect">使用 Material Design 组件实现深色主题</a></li>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce8fbb7fb61ede45fa93a0d8d5464935f48f28601f2db5d5ea8d60863fe2392f2361cffae&amp;idx=1&amp;mid=2652063934&amp;scene=21&amp;sn=caeaec14e70b7569c06503b1bb04138b#wechat_redirect">Android Material 组件 1.2.0 现已发布</a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Jetpack之Room]]></title>
        <id>https://jgduan.github.io/post/android-jetpack-zhi-room/</id>
        <link href="https://jgduan.github.io/post/android-jetpack-zhi-room/">
        </link>
        <updated>2021-06-29T14:50:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。</p>
<hr>
<h1 id="声明依赖-引入room到项目中">声明依赖--引入Room到项目中</h1>
<p>在添加Room依赖前，我们需要在Project的<code>build.gradle</code>中，添加Google Maven代码库到项目中，示例如下：</p>
<pre><code class="language-java">allprojects {
    repositories {
        google()

        // 如果您使用的Gradle版本低于4.1，则必须使用：
        // maven {
        //     url 'https://maven.google.com'
        // }
        // 另一个URL是 'https://dl.google.com/dl/android/maven2/'
    }
}
</code></pre>
<p>在app或者使用Room的Module的<code>build.gradle</code>文件中，我这里添加了以下以代码来使用Room：</p>
<pre><code class="language-java">dependencies {
    def room_version = &quot;2.3.0&quot;

    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)
    annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;

    // To use Kotlin annotation processing tool (kapt) --使用Kotlin注释处理工具
    kapt(&quot;androidx.room:room-compiler:$room_version&quot;)

    // optional - Kotlin Extensions and Coroutines support for Room--可选项，在Room上Kotlin扩展和协程
    implementation(&quot;androidx.room:room-ktx:$room_version&quot;)

    // optional - RxJava3 support for Room--可选项，Room RxJava3支持
    implementation &quot;androidx.room:room-rxjava3:$room_version&quot;
}
</code></pre>
<hr>
<h1 id="room库分析">Room库分析</h1>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li>
<p><strong>数据库：</strong> 包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。<br>
使用<code>@Database</code>注释的类应满足以下条件：</p>
<ul>
<li>
<p>是扩展<code>RoomDatabase</code>的抽象类。</p>
</li>
<li>
<p>在注释中添加与数据库关联的实体列表。</p>
</li>
<li>
<p>包含具有 0 个参数且返回使用<code>@Dao</code>注释的类的抽象方法。</p>
</li>
</ul>
<p>在运行时，您可以通过调用<code>Room.databaseBuilder()</code>或<code>Room.inMemoryDatabaseBuilder()</code>获取 Database 的实例。</p>
</li>
<li>
<p><strong>Entity：</strong> 表示数据库中的表。</p>
</li>
<li>
<p><strong>DAO：</strong> 包含用于访问数据库的方法。</p>
</li>
</ul>
<p>应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。</p>
<p>Room 不同组件之间的关系如图 1 所示：<br>
<img src="https://developer.android.google.cn/images/training/data-storage/room_architecture.png" alt="" loading="lazy"></p>
<hr>
<h1 id="room使用示例">Room使用示例</h1>
<h2 id="新建一个实体类user">新建一个实体类User</h2>
<pre><code class="language-java">@Entity
data class User(
    @PrimaryKey val uid: Int,
    @ColumnInfo(name = &quot;first_name&quot;) val firstName: String?,
    @ColumnInfo(name = &quot;last_name&quot;) val lastName: String?
)
</code></pre>
<h2 id="新建一个dao类">新建一个DAO类</h2>
<pre><code class="language-java">@Dao
interface UserDao {
    @Query(&quot;SELECT * FROM user&quot;)
    fun getAll(): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)
    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; +
            &quot;last_name LIKE :last LIMIT 1&quot;)
    fun findByName(first: String, last: String): User

    @Insert
    fun insertAll(vararg users: User)

    @Delete
    fun delete(user: User)
}
</code></pre>
<h2 id="新建一个appdatabase类继承roomdatabase">新建一个AppDatabase类继承RoomDatabase</h2>
<pre><code class="language-java">@Database(entities = arrayOf(User::class), version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
</code></pre>
<h2 id="数据库的使用">数据库的使用</h2>
<blockquote>
<p>创建完上述文件后，您可以使用以下代码获取已创建的数据库的实例了：</p>
</blockquote>
<pre><code class="language-java">val db = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java, &quot;database-name&quot;
        ).build()
</code></pre>
<blockquote>
<p>注意：如果您的应用在单个进程中运行，在实例化 AppDatabase 对象时应遵循单例设计模式。每个 RoomDatabase 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。</p>
</blockquote>
<blockquote>
<p>如果您的应用在多个进程中运行，请在数据库构建器调用中包含 <code>enableMultiInstanceInvalidation()</code>。这样，如果您在每个进程中都有一个 AppDatabase 实例，可以在一个进程中使共享数据库文件失效，并且这种失效会自动传播到其他进程中 AppDatabase 的实例。</p>
</blockquote>
<hr>
<blockquote>
<p>主要内容源自<a href="https://developer.android.google.cn/training/data-storage/room">官方开发者文档Room操作指南</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】应用加固、混淆分析解读]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/">
        </link>
        <updated>2021-06-29T14:30:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>当我们准备发布一个App版本时，出于对App安全性的考虑，我们一般会选择对代码进行混淆、对打包后的apk文件进行加固操作，其目的就是为了防止app被恶意破解，增加破解难度来提高应用安全性。</p>
<h2 id="代码混淆">代码混淆</h2>
<p>代码混淆是一种常用的加密方式，它通过开启代码混淆开关、配置本地文件，对项目打包后的代码进行加密混淆（混淆的原理实际上就是对原来有具体含义的包名,类名,变量名,方法名等名称全部替换成按顺序排列的无意义的英文字母，如：a,b,c等）。</p>
<blockquote>
<p>proguard-rules.pro文件是给Library模块自己使用的混淆规则；<br>
consumer-rules.pro文件则是会合并到app的混淆规则中，是给包括app在内的其他模块调用时使用的混淆规则；<br>
而这两个文件，完全可以使用同一个文件进行配置；当需要进行区分时，可以使用两个不同的文件进行配置；根据项目需求选择所需即可。</p>
</blockquote>
<h2 id="应用加固">应用加固</h2>
<blockquote>
<p>一个apk文件，当我们把它后缀名修改为.zip时（后续我会追加一篇应用打包过程的文章，来描述apk到底是如何生成的，它包含哪些元素），可以找到classes.dex文件，这个文件包含了我们项目的<strong>主要源代码</strong>，通过反编译工具（如dex2jar等），我们可以轻松的拿到对应的源文件jar包并查看源代码。</p>
</blockquote>
<p>应用加固是指，通过对dex文件的的加密、拼接加壳操作，来有效的对项目代码进行保护，防止通过上述方法来拿到dex文件进行反编译。</p>
<p>当apk被安装后，app启动时会有dex的解密过程，然后系统会重新加载解密后的dex文件。</p>
<hr>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<p><a href="https://blog.csdn.net/weixin_45443931/article/details/98869613">浅谈安卓apk加固原理和实现</a><br>
<a href="https://blog.csdn.net/qq_33232521/article/details/114919455">android 混淆 minifyEnabled proguard-rules.pro consumer-rules.pro</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1忽略build文件夹后找不到BuildConfig]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/">
        </link>
        <updated>2021-06-28T15:14:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在Android Studio版本升级到4.1+后，新建了一个项目并在<code>build.gradle</code>文件中配置了<code>buildConfigField-http/log</code>等相关公共字段的配置并同步，然后因要关联至SVN，便修改了项目中的忽略配置以避免上传部分不需要提交的文件内容，具体配置如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628170410668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="忽略配置" loading="lazy"><br>
配置完毕后，当打开使用到<code>BuildConfig</code>文件的类时，发现编辑器报错并提示找不到该文件，具体如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628171128972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="buildConfig" loading="lazy"></p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>刚碰到该问题，第一时间怀疑是<strong>相关文件未构建成功</strong>，多次<code>Build-&gt;ReBuild Project</code>都毫无作用。</p>
<p>后来想到对应Module的<code>build</code>目录下去查看是否已生成文件（BuildConfig默认的生成在<code>xx/ProjectName/ModuleName/build/generated/source/buildConfig/buildTypes(debug/release/xxx/包名、)</code>目录下），发现在Project预览模式下，无法找到build文件。</p>
<p>最后各种尝试后，定位到可能是因为忽略文件配置导致Project无法预览build文件目录下的内容，导致编辑器报错找不到文件，<strong>直接取消setting-&gt;Editor-&gt;File Types-&gt;.gitignore中的build文件夹的忽略配置即可</strong>。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava3实现倒计时功能]]></title>
        <id>https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/</id>
        <link href="https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/">
        </link>
        <updated>2021-06-28T14:52:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-导入rxjava3">一、导入RxJava3</h1>
<p>在需要使用RxJava的Module中，打开<code>build.gradle</code>文件在<code>dependencies</code>标签内添加如下代码引入RxJava：</p>
<pre><code class="language-java">implementation &quot;io.reactivex.rxjava3:rxjava:3.0.6&quot;
implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
</code></pre>
<hr>
<h1 id="二-倒计时实现">二、倒计时实现</h1>
<ul>
<li><strong>使用<code>intervalRange</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">/**
 * start：开始的数值
 * count：输出值的个数（执行几次）
 * initialDelay：延迟多久执行
 * period：间隔多久执行一次
 * TimeUnit：延迟/间隔数值单位，NANOSECONDS（纳秒），MICROSECONDS（微秒），MILLISECONDS（毫秒），
 * SECONDS（秒），MINUTES（分钟），HOURS（小时），DAYS（天）
 */
Observable.intervalRange(0, 1, 5, 0, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnComplete {
        LogUtil.e(TAG,&quot;start to MainActivity...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }.subscribe()
</code></pre>
<ul>
<li><strong>使用<code>timer</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">// 延时1s进入MainActivity
Observable.timer(1, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe {
        LogUtil.e(TAG,&quot;start to MainActivity2...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】创建签名提示“迁移到行业标准格式PKCS12”问题]]></title>
        <id>https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/">
        </link>
        <updated>2021-06-28T14:21:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>Android Studio新建项目签名时创建签名文件时，提示“迁移到行业标准格式PKCS12”。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>在Android Studio上，通过命令行创建签名文件。</p>
<ol>
<li>输入以下命令：</li>
</ol>
<pre><code class="language-java">keytool -genkey -alias 这里替换成你的应用别名 -keypass 这里填写你的别名密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore 签名文件的存储路径\你得项目名称\app\xxx.jks -storepass 你的签名密码
</code></pre>
<p>你需要修改以下四处：</p>
<ul>
<li>应用别名（alias）</li>
<li>别名密码（alias password）</li>
<li>签名文件保存的路径（全路径，如：D:/TestProject/app/test.jks）</li>
<li>签名密码</li>
</ul>
<ol start="2">
<li>第1步完成后，回车，然后填写签名作者相关信息</li>
</ol>
<pre><code class="language-java">您的名字与姓氏是什么?
  [Unknown]:  zihao
您的组织单位名称是什么?
  [Unknown]:  xxxx
您的组织名称是什么?
  [Unknown]:  xxxx
您所在的城市或区域名称是什么?
  [Unknown]:  HeFei
您所在的省/市/自治区名称是什么?
  [Unknown]:  AnHui
该单位的双字母国家/地区代码是什么?
  [Unknown]:  0086
CN=zihao, OU=xxxx, O=xxxx L=HeFei, ST=AnHui, C=0086是否正确?
  [否]:  y
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【DOHENES】基于Kotlin的v3.0架构规范]]></title>
        <id>https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/</id>
        <link href="https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/">
        </link>
        <updated>2021-06-25T14:17:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>项目采用了<code>MVVM</code>架构方式+组件化方案+<code>Jetpack</code>常用库，基于<code>Kotlin 1.4.32</code>编译版本，在个别<code>Module</code>的部分区域混合使用了<code>Java（Java 8版本）</code>来进行开发工作，具体使用的三方库及其使用方法、示例将在文末进行讲解。</p>
<hr>
<h1 id="一-架构模式-mvvm">一、架构模式-MVVM</h1>
<p>项目采用<code>MVVM</code>架构模式，这里通过<code>Jetpack</code>的<code>ViewModel</code>组件来更换传统的<code>ViewModel</code>。</p>
<p><a href="https://www.jianshu.com/p/449136bddff6">Android MVVM 模式</a></p>
<hr>
<h1 id="二-project-组件化">二、Project-组件化</h1>
<p>为了各个功能模块之间解耦、<code>Module</code>灵活组合编译运行，便于团队协作开发及后期维护，3.0版本架构在多<code>Module</code>的基础上，采用了组件化方案来进一步优化项目架构。</p>
<ul>
<li>
<p><strong>模块解耦</strong><br>
项目采用组件化方案进行模块的<strong>解耦</strong>处理。</p>
</li>
<li>
<p><strong>组件分类及命名规范</strong><br>
整体架构分层与v2.0版本类似，除了最上层的<code>base、common</code>两大Library基础库，功能成分库继续采用<code>component-xxx</code>来进行命名，包含界面、具体业务逻辑的Library继续用<code>module-xxx</code>进行命名。</p>
</li>
</ul>
<blockquote>
<p>具体可参考<a href="https://jgduan.github.io/post/dohenes-tb-gai-ban-v20-zheng-ti-jia-gou-gui-fan/">【DOHENES】TB改版v2.0整体架构规范</a></p>
</blockquote>
<ul>
<li>
<p><strong>统一的引用配置</strong><br>
为保持引用库版本一致，规避开发过程中不必要的冲突。项目中通过Project根目录下的<code>config.gradle</code>文件，定义通用的构建元素字段，供各个模块进行引用。</p>
</li>
<li>
<p><strong>独立编译运行</strong><br>
发挥组件化方案的优势，通过在<code>config.gradle</code>中配置对应控制变量对各<code>moudle</code>进行<code>library-&gt;application</code>的灵活控制，让<code>module</code>既可以独立编译运行，又可以集成编译，按需灵活配置，方便开发人员协作。</p>
</li>
</ul>
<hr>
<h1 id="三-屏幕分辨率适配">三、屏幕（分辨率适配）</h1>
<p>依据实际的<code>UI</code>设计图，我们以<code>sw-375dp</code>为基准进行屏幕的适配工作，相应适配文件存放于<code>base-&gt;res/values、values-swxxxdp/measure.xml</code>内。<br>
在实际开发中根据UI设计图尺寸直接设置对应控件的尺寸即可（<code>@dimen/common_measure_xxxdp</code>），具体使用示例如下：</p>
<pre><code class="language-java">// 在需要使用地方添加对应的尺寸
android:layout_height=&quot;@dimen/common_measure_xxxdp&quot;
</code></pre>
<hr>
<h1 id="四-数据存储">四、数据存储</h1>
<ul>
<li>
<p><strong>ROOM</strong><br>
<a href="https://blog.csdn.net/yu540135101/article/details/110670477">Android kotlin+协程+Room数据库的简单使用</a><br>
<a href="https://www.jianshu.com/p/0dde643ac045">Android Room的简单使用</a></p>
</li>
<li>
<p><strong>DataStore</strong></p>
</li>
<li>
<p><strong>Native Files</strong><br>
当我们在开发过程涉及到一些需要缓存的文件时，很多应用采取的策略是到<code>SD卡</code>的根目录上创建自己的文件夹然后保存到对应的文件路径下（之前的泰邦设计也是这样做的），虽然达到了缓存文件的目的，但它并不被Android所推荐——当应用卸载后，这些被创建的文件夹仍然存在，造成手机内多出了不少的垃圾文件，这样是极不友好的。<br>
Android建议我们在缓存文件时使用应用专属（这里又分内部存储与外部存储，建议是尽可能使用外部存储进行缓存）的缓存路径进行文件的缓存，当应用被卸载后，这些数据也会随之而消失，从而规避了上述问题。<br>
关于应用专属内、外部存储的更多了解，建议阅读以下文章或自行了解后再进行相关的操作：<br>
<a href="https://blog.csdn.net/s13383754499/article/details/82910704">彻底搞懂Android文件存储---内部存储，外部存储以及各种存储路径解惑</a><br>
<a href="https://www.jianshu.com/p/b752b2e70b8c">Android文件缓存目录</a><br>
重点关注：getExternalCacheDir、getExternalFilesDir。</p>
</li>
</ul>
<hr>
<h1 id="五-kotlin">五、Kotlin</h1>
<ul>
<li>
<p><strong>协程</strong><br>
<a href="https://www.jianshu.com/p/6e6835573a9c">Kotlin协程</a></p>
</li>
<li>
<p><strong>不再使用findViewById</strong><br>
在Module的build.gradle中加上：<code>apply plugin: 'kotlin-android-extensions'</code>，然后就可以直接使用布局中定义的id去访问对应的控件了。</p>
</li>
</ul>
<blockquote>
<p>在使用的时候，你会发现导入的包是<code>import kotlinx.android.synthetic.main.activity_main.*</code>(如layout名称为activity_main.xml)</p>
</blockquote>
<hr>
<h1 id="六-项目中三方库使用规范及示例">六、项目中三方库使用规范及示例</h1>
<ul>
<li>
<p><strong>ARouter——路由</strong></p>
<ul>
<li>概述<br>
一款阿里开源的路由框架，是一个帮助Android进行模块化、组件化开发的开源库。它支持模块间的路由、通信、解耦。</li>
<li>引入
<ul>
<li>添加依赖和配置<pre><code class="language-java">android {
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile 'com.alibaba:arouter-api:x.x.x'
    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'
    ...
}
// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'
// Kotlin配置参考文末'其他#5'

</code></pre>
<blockquote>
<p>所有使用ARouter的Module都必须在<code>build.gradle</code>中<code>dependencies</code>标签内添加<code>annotationProcessor 'com.alibaba:arouter-compiler:x.x.x</code>注释处理器。</p>
</blockquote>
</li>
<li>添加注解<pre><code class="language-java">// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = &quot;/test/activity&quot;)
public class YourActivity extend Activity {
    ...
}
</code></pre>
</li>
<li>初始化SDK<pre><code class="language-java">if (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
}
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化

</code></pre>
</li>
<li>发起路由操作<pre><code class="language-java">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build(&quot;/test/1&quot;)
            .withLong(&quot;key1&quot;, 666L)
            .withString(&quot;key3&quot;, &quot;888&quot;)
            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))
            .navigation();

</code></pre>
</li>
<li>使用 Gradle 插件实现路由表的自动加载 (可选)<pre><code class="language-java">apply plugin: 'com.alibaba.arouter'

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath &quot;com.alibaba:arouter-register:?&quot;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>使用规范<br>
在开发过程中，当我们对要进行跳转的页面上添加支持路由的注解时，我们需要遵循以下规则：<br>
<strong>路径需要注意的是至少需要有两级，/xx/xx，我们以/moduleName/className为基准进行对应的命名。</strong></li>
<li>使用示例<pre><code class="language-java">    @Route(path = &quot;/mine/mineActivity&quot;)
    class MineActivity {
    ...
    }
</code></pre>
</li>
<li>注意事项<br>
<strong>在使用该库的每个类的build.gradle文件中要添加如下配置：</strong><pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        // ARouter--每个使用到路由的Module必须加
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
        ...
    }
    ...
}
dependencies {
    // ARouter--每个使用到路由的Module必须加
    annotationProcessor rootProject.ext.dependencies['arouter-compiler']
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>DataBinding——数据绑定</strong></p>
<ul>
<li>
<p>概述<br>
数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</li>
<li>
<p>引入<br>
在使用DataBinding的Module中的build.gradle文件中进行如下操作：</p>
<ul>
<li>
<p>在文件最顶端(android标签外部)添加如下插件声明</p>
<pre><code class="language-java">plugins {
    ...
    id 'kotlin-kapt'
}
</code></pre>
</li>
<li>
<p>在android标签内部添加databinding引用（AndroidStudio 4.0+与之前写法不同）</p>
<pre><code class="language-java">buildFeatures {
    dataBinding = true
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用</p>
<ul>
<li>修改对应的布局<br>
使用Databinding的布局，最外层必须套一层layout标签，我们要修改对应的布局如下：<pre><code class="language-java">&lt;layout&gt;
    &lt;data&gt;
        ...
    &lt;/data&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        ...
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;/layout&gt;
</code></pre>
</li>
<li>给对应的控件绑定数据（这里以TextView为例）<br>
首先，在布局中添加一个TextView控件，然后在<code>&lt;data&gt;</code>标签内添加一个属性标签<code>&lt;variable&gt;</code>，其中name属性是指变量名称，type属性是指变量类型<pre><code class="language-java">&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    
    &lt;data&gt;

        &lt;variable
            name=&quot;titleStr&quot;
            type=&quot;String&quot; /&gt;
    &lt;/data&gt;
    
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        &lt;TextView
            android:id=&quot;@+id/tv_title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{titleStr}&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;layou/&gt;
</code></pre>
在页面中进行赋值操作：<pre><code class="language-java">DataBindingUtil.setContentView&lt;ActivitySimpleBindingImpl&gt;(this, R.layout.activity_simple)
    .apply {
        titleStr = &quot;DataBinding test&quot;
    }
</code></pre>
<blockquote>
<p>注：使用DataBinding的Activity会自动生成<code>ActivityXXXBindingImpl</code>，如SimpleActivity会生成ActivitySimpleBindingImpl类。</p>
</blockquote>
</li>
<li>点击事件的使用</li>
<li>RecyclerView的使用</li>
<li>ImageView加载一张网络图片</li>
</ul>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/e8cf690ee8cc">DataBinding + Kotlin</a></p>
</blockquote>
<ul>
<li>
<p><strong>Paging——分页</strong></p>
<ul>
<li>
<p>概述<br>
Paging 库可帮助您加载和显示来自本地存储或网络中更大的数据集中的数据页面。此方法可让您的应用更高效地利用网络带宽和系统资源。Paging 库的组件旨在契合推荐的 Android 应用架构，流畅集成其他 Jetpack 组件，并提供一流的 Kotlin 支持。</p>
<p>使用 Paging 库，您可以更加轻松地在应用的 RecyclerView 中逐步、流畅地加载数据。</p>
</li>
<li>
<p>引入</p>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
<li>
<p><strong>BottomNavigation——底部导航栏</strong><br>
<a href="https://www.jianshu.com/p/f0021265845f">Kotlin-BottomNavigationView</a><br>
<a href="https://blog.csdn.net/afei__/article/details/80950288">Android底部导航栏，三种风格和实现</a><br>
<a href="https://www.jianshu.com/p/1cebf8cd1a86">Android 底部导航之BottomNavigationBar</a><br>
<a href="https://blog.csdn.net/abs1004/article/details/77330726">安卓 BottomNavigationBar 底部导航栏 最简单用法详解</a></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】git命令行登陆github进行操作]]></title>
        <id>https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/</id>
        <link href="https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/">
        </link>
        <updated>2021-06-24T16:32:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>转载自<a href="https://www.jianshu.com/p/6e3f9e4e8e69">git命令行登陆github进行操作</a>，侵删。</strong></p>
</blockquote>
<p>登陆github必须先创建SSH key<br>
因为本地Git仓库和GitHub仓库之间的传输是通过SSH加密传输的，GitHub需要识别是否是你推送，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送，所以需要配置ssh key。</p>
<hr>
<h2 id="1创建ssh-key">1.创建SSH Key。</h2>
<p>在用户主目录（C:\Users\Administrator）下，看看有没有.ssh文件，如果有，再看文件下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接到下一步。如果没有，打开Git Bash，输入命令，创建SSH Key</p>
<p><code>$ ssh-keygen -t rsa -C &quot;你自己注册GitHub的邮箱&quot;</code></p>
<hr>
<h2 id="2接下来到github上打开account-settings-ssh-keys页面然后点击add-ssh-key填上title随意写在key文本框里粘贴-id_rsapub文件里的全部内容">2.接下来到GitHub上，打开“Account settings”--“SSH Keys”页面，然后点击“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容。</h2>
<p>id_rsa.pub 默认在C:\Users\Administrator.ssh</p>
<p>每台想要登陆某个github账号的主机都需要有一个对应的key，例如你有一个github账号，你在你的笔记本和台式上都要创建key</p>
<hr>
<h2 id="3git-bash里输入下面的命令登陆">3.git bash里输入下面的命令登陆</h2>
<p><code>$ ssh -T git@github.com</code></p>
<p>如果看到 hi + 你的用户名说明密钥验证通过了，你已经可以上传下载了<br>
<img src="https://jgduan.github.io//post-images/1624552568098.png" alt="" loading="lazy"></p>
<hr>
<h2 id="4设置username和email因为github每次commit都会记录他们">4.设置username和email，因为github每次commit都会记录他们</h2>
<p>git commit 命令会记录提交者的信息，所以使用git前必须先添加两条信息</p>
<p><code>$ git config --global user.name &quot;你的GitHub登陆名&quot;</code><br>
<code>$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
<blockquote>
<p>（其实可以不和github上面的用户名邮箱一致，只是为了避免混淆）</p>
</blockquote>
<hr>
<h2 id="5接下来就是把本地仓库传到github上去">5.接下来就是把本地仓库传到github上去</h2>
<p><code>$ git remote add origin git@github.com:userName/yourProject.git</code></p>
<p>//关联一个远程库命令，git@后面填写你的github repository（仓库），在github里面创建仓库后有http和ssh的链接，origin是你给这个仓库起的名字，可以自定义，下面命令中的origin也要相应改变</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1624552692583.webp" alt="" loading="lazy"></figure>
<p>git push -u origin master //把本地已经commit 的结果push到github的origin 仓库的master分支中</p>
<hr>
<p>##【拓展阅读】<br>
<a href="https://www.cnblogs.com/luhuan/p/9072820.html">Windows下配置Git多账号github码云</a></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Plugin version (1.4.32) is not the same as library version (1.4.10) 警告的解决办法]]></title>
        <id>https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/</id>
        <link href="https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/">
        </link>
        <updated>2021-06-24T15:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在开发<code>Kotlin</code>项目的过程中，使用<code>kotlin-stdlib</code>标准库时，遇到了如下警告提示：</p>
<pre><code class="language-java">Plugin version(1.4.32) is not the same as library version(1.4.10)
</code></pre>
<p>提示的大致意思是说我们的插件版本和依赖库的版本不一致，原因是因为一些第三方的Library库所依赖的版本比较低，而我们在项目中所指定的依赖版本比较高，从而导致AndroidStudio给我们提出了警示。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p><strong>直接在module的build.gradle中删除依赖即可解决问题</strong></p>
<pre><code class="language-java">// 删除moudle-build.gralde文件中的该段
implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
</code></pre>
<p>详情请移步官网查看官方声明的这篇文章：<a href="https://kotlinlang.org/docs/whatsnew14.html#dependency-on-the-standard-library-added-by-default">What's new in Kotlin 1.4</a><br>
<img src="https://jgduan.github.io//post-images/1624550094222.png" alt="" loading="lazy"></p>
<p>图中的意思是：</p>
<blockquote>
<p>Kotlin默认添加了stdlib的依赖，您不再需要stdlib在任何 Kotlin Gradle 项目（包括多平台项目）中声明对库的依赖。默认情况下添加依赖项。</p>
</blockquote>
<blockquote>
<p>自动添加的标准库将是 Kotlin Gradle 插件的相同版本，因为它们具有相同的版本。</p>
</blockquote>
<blockquote>
<p>对于特定于平台的源集，使用库的相应特定于平台的变体，同时将公共标准库添加到其余部分。Kotlin Gradle 插件将根据您的 Gradle 构建脚本的kotlinOptions.jvmTarget 编译器选项选择合适的 JVM 标准库。</p>
</blockquote>
<p>上面所说的Kotlin插件，是指Project根目录下的build.gradle文件中的Kotlin插件，具体如下图所示：<br>
<img src="https://jgduan.github.io//post-images/1624550446644.png" alt="" loading="lazy"></p>
<p>这样一来，让人糟心的警告就不见了。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Handler】This Handler class should be static or leaks might occur (anonymous android.os.Handler)]]></title>
        <id>https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/</id>
        <link href="https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/">
        </link>
        <updated>2021-06-20T15:12:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Android开发者在日常开发过程中，经常会使用到<code>Handler</code>用来接收消息进行后续处理，然而当我们在<code>Handler#handleMessage(Message msg)</code>方法中做UI相关操作时，AndroidStudio就会报出如下警告：</p>
<pre><code class="language-java">This Handler class should be static or leaks might occur (anonymous android.os.Handler)
Inspection info:Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected.
If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue.
If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows:
   1. Declare the Handler as a static class;
   2. In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler;
   3. Make all references to members of the outer class using the WeakReference object.
</code></pre>
<p>警告内容是提示我们在内部类<code>Handler#handleMessage(Message msg)</code>方法中处理UI相关操作时，可能会造成内存泄漏风险，同时在警告内容中，指导给开发者相应的解决方案——内部类Handler静态化、使用弱引用<code>WeakReference</code>来进行抑制处理、访问所有的外部成员通过<code>WeakReference</code>引用对象来进行访问。</p>
<blockquote>
<p>除此之外，我们还可以在Activity被销毁时通过<code>Handler#removeCallbacksAndMessages(Object token)</code>方法来销毁对应<code>Handler</code>所有的消息队列。</p>
</blockquote>
<hr>
<h1 id="主动创造一个引起内存泄漏的handler">主动创造一个引起内存泄漏的Handler</h1>
<p>这里我们通过创造一个有内存泄漏风险的<code>Handler</code>通过不断切换<code>Activity</code>横竖屏来进行测试，看是否会引发内存泄漏，示例如下：</p>
<pre><code class="language-java">// HandlerTestActivity.java
public class HandlerTestActivity extends AppCompatActivity {
 
    // 创建匿名Handler内部类的对象
    private Handler leakHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };
 
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_handler_test);
 
        leakHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                Logger.d(&quot;leakHandler 延迟执行,内存泄露测试&quot;);
            }
        }, 5 * 60 * 1000);
    }
}
</code></pre>
<p>通过多次运行分析后，我们发现：应用内存占用出现了明显了升高;</p>
<p><strong>简单描述下原因:</strong><br>
由于上面的<code>Handler</code>内部类定义在<code>UI</code>线程中,因此使用的主线程的<code>Looper</code>和 <code>MessageQueue</code>;<br>
<code>MessageQueue</code>中的<code>Message</code>会持有<code>Handler</code>对象;<br>
匿名<code>Handler</code>内部类对象持有着外部<code>Activity</code>的强引用;<br>
以上三点导致当有<code>Message</code>未被处理之前, 外部类<code>Activity</code>会一直被强引用,导致即使发生了销毁,也无法被GC回收;</p>
<p>因此处理方法通常有两种:</p>
<p>在外部类<code>Activity</code>销毁时取消所有的<code>Message</code>,即 <code>leakHandler.removeCallbacksAndMessages(null)</code>;<br>
让内部类不要持有外部<code>Activity</code>的强引用;<br>
<code>AndroidStudio</code>给出的提示方案属于第二种。</p>
<blockquote>
<p>我们通过smali源码来一步步探究验证下;<br>
<a href="https://blog.csdn.net/weixin_33923762/article/details/91430429">[smali] This Handler class should be static or leaks might occur</a></p>
</blockquote>
<hr>
<h1 id="弱引用的handler">弱引用的Handler</h1>
<p>因大家在项目中可能存在多出使用<code>Handler</code>，我们可以封装一个公共的<code>WeakHandler</code>类，抽取公共方法供其它使用区域在此基础上继承实现，实现后的代码如下：</p>
<pre><code class="language-java">public class WeakHandler&lt;T extends Activity&gt; extends Handler {
    private final WeakReference&lt;T&gt; mWkActivity;

    public WeakHandler(T activity) {
        mWkActivity = new WeakReference&lt;&gt;(activity);
    }

    public T getActivity() {
        return mWkActivity.get();
    }

//    @Override
//    public void handleMessage(Message msg) {
//        super.handleMessage(msg);
//        T targetAct = mWkActivity.get();
//        // 通过`WeakReference`对象去操作外部`Activity`属性和事件
//        if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
////           targetAct.对象
//        }
//    }

}
</code></pre>
<p>那么在其它地方我们可以通过继承<code>WeakHandler</code>类的方式来实现弱引用的<code>Handler</code>，示例如下：</p>
<pre><code class="language-java">SimpleWeakHandler simpleWeakHandler = new SimpleWeakHandler(SimpleActivity.this);
    private static class SimpleWeakHandler extends WeakHandler&lt;SimpleActivity&gt; {

        public SimpleWeakHandler(SimpleActivity activity) {
            super(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            SimpleActivity targetAct = getActivity();
            if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
                targetAct.tvTitle.setText(&quot;SimpleWeakHandler&quot;);
            }
        }
    }
</code></pre>
<hr>
]]></content>
    </entry>
</feed>