<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-06-29T15:14:41.054Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【Android】Jetpack之Room]]></title>
        <id>https://jgduan.github.io/post/android-jetpack-zhi-room/</id>
        <link href="https://jgduan.github.io/post/android-jetpack-zhi-room/">
        </link>
        <updated>2021-06-29T14:50:46.000Z</updated>
        <content type="html"><![CDATA[<h1 id="简介">简介</h1>
<p>Room 持久性库在 SQLite 的基础上提供了一个抽象层，让用户能够在充分利用 SQLite 的强大功能的同时，获享更强健的数据库访问机制。</p>
<hr>
<h1 id="声明依赖-引入room到项目中">声明依赖--引入Room到项目中</h1>
<p>在添加Room依赖前，我们需要在Project的<code>build.gradle</code>中，添加Google Maven代码库到项目中，示例如下：</p>
<pre><code class="language-java">allprojects {
    repositories {
        google()

        // 如果您使用的Gradle版本低于4.1，则必须使用：
        // maven {
        //     url 'https://maven.google.com'
        // }
        // 另一个URL是 'https://dl.google.com/dl/android/maven2/'
    }
}
</code></pre>
<p>在app或者使用Room的Module的<code>build.gradle</code>文件中，我这里添加了以下以代码来使用Room：</p>
<pre><code class="language-java">dependencies {
    def room_version = &quot;2.3.0&quot;

    implementation(&quot;androidx.room:room-runtime:$room_version&quot;)
    annotationProcessor &quot;androidx.room:room-compiler:$room_version&quot;

    // To use Kotlin annotation processing tool (kapt) --使用Kotlin注释处理工具
    kapt(&quot;androidx.room:room-compiler:$room_version&quot;)

    // optional - Kotlin Extensions and Coroutines support for Room--可选项，在Room上Kotlin扩展和协程
    implementation(&quot;androidx.room:room-ktx:$room_version&quot;)

    // optional - RxJava3 support for Room--可选项，Room RxJava3支持
    implementation &quot;androidx.room:room-rxjava3:$room_version&quot;
}
</code></pre>
<hr>
<h1 id="room库分析">Room库分析</h1>
<p>Room 包含 3 个主要组件：</p>
<ul>
<li>
<p>**数据库：**包含数据库持有者，并作为应用已保留的持久关系型数据的底层连接的主要接入点。<br>
使用<code>@Database</code>注释的类应满足以下条件：</p>
<ul>
<li>
<p>是扩展<code>RoomDatabase</code>的抽象类。</p>
</li>
<li>
<p>在注释中添加与数据库关联的实体列表。</p>
</li>
<li>
<p>包含具有 0 个参数且返回使用<code>@Dao</code>注释的类的抽象方法。</p>
</li>
</ul>
<p>在运行时，您可以通过调用 Room.databaseBuilder() 或 Room.inMemoryDatabaseBuilder() 获取 Database 的实例。</p>
</li>
<li>
<p>**Entity：**表示数据库中的表。</p>
</li>
<li>
<p>**DAO：**包含用于访问数据库的方法。</p>
</li>
</ul>
<p>应用使用 Room 数据库来获取与该数据库关联的数据访问对象 (DAO)。然后，应用使用每个 DAO 从数据库中获取实体，然后再将对这些实体的所有更改保存回数据库中。 最后，应用使用实体来获取和设置与数据库中的表列相对应的值。</p>
<p>Room 不同组件之间的关系如图 1 所示：<br>
<img src="https://developer.android.google.cn/images/training/data-storage/room_architecture.png" alt="" loading="lazy"></p>
<hr>
<h1 id="room使用示例">Room使用示例</h1>
<h2 id="新建一个实体类user">新建一个实体类User</h2>
<pre><code class="language-java">@Entity
data class User(
    @PrimaryKey val uid: Int,
    @ColumnInfo(name = &quot;first_name&quot;) val firstName: String?,
    @ColumnInfo(name = &quot;last_name&quot;) val lastName: String?
)
</code></pre>
<h2 id="新建一个dao类">新建一个DAO类</h2>
<pre><code class="language-java">@Dao
interface UserDao {
    @Query(&quot;SELECT * FROM user&quot;)
    fun getAll(): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE uid IN (:userIds)&quot;)
    fun loadAllByIds(userIds: IntArray): List&lt;User&gt;

    @Query(&quot;SELECT * FROM user WHERE first_name LIKE :first AND &quot; +
            &quot;last_name LIKE :last LIMIT 1&quot;)
    fun findByName(first: String, last: String): User

    @Insert
    fun insertAll(vararg users: User)

    @Delete
    fun delete(user: User)
}
</code></pre>
<h2 id="新建一个appdatabase类继承roomdatabase">新建一个AppDatabase类继承RoomDatabase</h2>
<pre><code class="language-java">@Database(entities = arrayOf(User::class), version = 1)
abstract class AppDatabase : RoomDatabase() {
    abstract fun userDao(): UserDao
}
</code></pre>
<h2 id="数据库的使用">数据库的使用</h2>
<blockquote>
<p>创建完上述文件后，您可以使用以下代码获取已创建的数据库的实例了：</p>
</blockquote>
<pre><code class="language-java">val db = Room.databaseBuilder(
            applicationContext,
            AppDatabase::class.java, &quot;database-name&quot;
        ).build()
</code></pre>
<blockquote>
<p>注意：如果您的应用在单个进程中运行，在实例化 AppDatabase 对象时应遵循单例设计模式。每个 RoomDatabase 实例的成本相当高，而您几乎不需要在单个进程中访问多个实例。</p>
</blockquote>
<blockquote>
<p>如果您的应用在多个进程中运行，请在数据库构建器调用中包含 <code>enableMultiInstanceInvalidation()</code>。这样，如果您在每个进程中都有一个 AppDatabase 实例，可以在一个进程中使共享数据库文件失效，并且这种失效会自动传播到其他进程中 AppDatabase 的实例。</p>
</blockquote>
<hr>
<blockquote>
<p>主要内容源自<a href="https://developer.android.google.cn/training/data-storage/room">官方开发者文档Room操作指南</a></p>
</blockquote>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】应用加固、混淆分析解读]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-jia-gu-hun-yao-fen-xi-jie-du/">
        </link>
        <updated>2021-06-29T14:30:28.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>当我们准备发布一个App版本时，出于对App安全性的考虑，我们一般会选择对代码进行混淆、对打包后的apk文件进行加固操作，其目的就是为了防止app被恶意破解，增加破解难度来提高应用安全性。</p>
<h2 id="代码混淆">代码混淆</h2>
<p>代码混淆是一种常用的加密方式，它通过开启代码混淆开关、配置本地文件，对项目打包后的代码进行加密混淆（混淆的原理实际上就是对原来有具体含义的包名,类名,变量名,方法名等名称全部替换成按顺序排列的无意义的英文字母，如：a,b,c等）。</p>
<blockquote>
<p>proguard-rules.pro文件是给Library模块自己使用的混淆规则；<br>
consumer-rules.pro文件则是会合并到app的混淆规则中，是给包括app在内的其他模块调用时使用的混淆规则；<br>
而这两个文件，完全可以使用同一个文件进行配置；当需要进行区分时，可以使用两个不同的文件进行配置；根据项目需求选择所需即可。</p>
</blockquote>
<h2 id="应用加固">应用加固</h2>
<blockquote>
<p>一个apk文件，当我们把它后缀名修改为.zip时（后续我会追加一篇应用打包过程的文章，来描述apk到底是如何生成的，它包含哪些元素），可以找到classes.dex文件，这个文件包含了我们项目的<strong>主要源代码</strong>，通过反编译工具（如dex2jar等），我们可以轻松的拿到对应的源文件jar包并查看源代码。</p>
</blockquote>
<p>应用加固是指，通过对dex文件的的加密、拼接加壳操作，来有效的对项目代码进行保护，防止通过上述方法来拿到dex文件进行反编译。</p>
<p>当apk被安装后，app启动时会有dex的解密过程，然后系统会重新加载解密后的dex文件。</p>
<hr>
<hr>
<h1 id="拓展阅读">拓展阅读</h1>
<p><a href="https://blog.csdn.net/weixin_45443931/article/details/98869613">浅谈安卓apk加固原理和实现</a><br>
<a href="https://blog.csdn.net/qq_33232521/article/details/114919455">android 混淆 minifyEnabled proguard-rules.pro consumer-rules.pro</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1忽略build文件夹后找不到BuildConfig]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41-hu-lue-build-wen-jian-jia-hou-zhao-bu-dao-buildconfig/">
        </link>
        <updated>2021-06-28T15:14:53.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在Android Studio版本升级到4.1+后，新建了一个项目并在<code>build.gradle</code>文件中配置了<code>buildConfigField-http/log</code>等相关公共字段的配置并同步，然后因要关联至SVN，便修改了项目中的忽略配置以避免上传部分不需要提交的文件内容，具体配置如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628170410668.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="忽略配置" loading="lazy"><br>
配置完毕后，当打开使用到<code>BuildConfig</code>文件的类时，发现编辑器报错并提示找不到该文件，具体如下图：<br>
<img src="https://img-blog.csdnimg.cn/20210628171128972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0NyYXp5X3ppaGFv,size_16,color_FFFFFF,t_70#pic_center" alt="buildConfig" loading="lazy"></p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>刚碰到该问题，第一时间怀疑是<strong>相关文件未构建成功</strong>，多次<code>Build-&gt;ReBuild Project</code>都毫无作用。</p>
<p>后来想到对应Module的<code>build</code>目录下去查看是否已生成文件（BuildConfig默认的生成在<code>xx/ProjectName/ModuleName/build/generated/source/buildConfig/buildTypes(debug/release/xxx/包名、)</code>目录下），发现在Project预览模式下，无法找到build文件。</p>
<p>最后各种尝试后，定位到可能是因为忽略文件配置导致Project无法预览build文件目录下的内容，导致编辑器报错找不到文件，<strong>直接取消setting-&gt;Editor-&gt;File Types-&gt;.gitignore中的build文件夹的忽略配置即可</strong>。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】RxJava3实现倒计时功能]]></title>
        <id>https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/</id>
        <link href="https://jgduan.github.io/post/android-rxjava3-shi-xian-dao-ji-shi-gong-neng/">
        </link>
        <updated>2021-06-28T14:52:30.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-导入rxjava3">一、导入RxJava3</h1>
<p>在需要使用RxJava的Module中，打开<code>build.gradle</code>文件在<code>dependencies</code>标签内添加如下代码引入RxJava：</p>
<pre><code class="language-java">implementation &quot;io.reactivex.rxjava3:rxjava:3.0.6&quot;
implementation 'io.reactivex.rxjava3:rxandroid:3.0.0'
</code></pre>
<hr>
<h1 id="二-倒计时实现">二、倒计时实现</h1>
<ul>
<li><strong>使用<code>intervalRange</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">/**
 * start：开始的数值
 * count：输出值的个数（执行几次）
 * initialDelay：延迟多久执行
 * period：间隔多久执行一次
 * TimeUnit：延迟/间隔数值单位，NANOSECONDS（纳秒），MICROSECONDS（微秒），MILLISECONDS（毫秒），
 * SECONDS（秒），MINUTES（分钟），HOURS（小时），DAYS（天）
 */
Observable.intervalRange(0, 1, 5, 0, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .doOnComplete {
        LogUtil.e(TAG,&quot;start to MainActivity...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }.subscribe()
</code></pre>
<ul>
<li><strong>使用<code>timer</code>实现倒计时任务</strong></li>
</ul>
<pre><code class="language-java">// 延时1s进入MainActivity
Observable.timer(1, TimeUnit.SECONDS)
    .observeOn(AndroidSchedulers.mainThread())
    .subscribe {
        LogUtil.e(TAG,&quot;start to MainActivity2...&quot;)
        startActivity(Intent(this@SplashActivity, MainActivity::class.java))
    }
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】创建签名提示“迁移到行业标准格式PKCS12”问题]]></title>
        <id>https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-chuang-jian-qian-ming-ti-shi-qian-yi-dao-xing-ye-biao-zhun-ge-shi-pkcs12wen-ti/">
        </link>
        <updated>2021-06-28T14:21:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="背景">背景</h1>
<p>Android Studio新建项目签名时创建签名文件时，提示“迁移到行业标准格式PKCS12”。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p>在Android Studio上，通过命令行创建签名文件。</p>
<ol>
<li>输入以下命令：</li>
</ol>
<pre><code class="language-java">keytool -genkey -alias 这里替换成你的应用别名 -keypass 这里填写你的别名密码 -keyalg RSA -keysize 2048 -validity 36500 -keystore 签名文件的存储路径\你得项目名称\app\xxx.jks -storepass 你的签名密码
</code></pre>
<p>你需要修改以下四处：</p>
<ul>
<li>应用别名（alias）</li>
<li>别名密码（alias password）</li>
<li>签名文件保存的路径（全路径，如：D:/TestProject/app/test.jks）</li>
<li>签名密码</li>
</ul>
<ol start="2">
<li>第1步完成后，回车，然后填写签名作者相关信息</li>
</ol>
<pre><code class="language-java">您的名字与姓氏是什么?
  [Unknown]:  zihao
您的组织单位名称是什么?
  [Unknown]:  xxxx
您的组织名称是什么?
  [Unknown]:  xxxx
您所在的城市或区域名称是什么?
  [Unknown]:  HeFei
您所在的省/市/自治区名称是什么?
  [Unknown]:  AnHui
该单位的双字母国家/地区代码是什么?
  [Unknown]:  0086
CN=zihao, OU=xxxx, O=xxxx L=HeFei, ST=AnHui, C=0086是否正确?
  [否]:  y
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【DOHENES】基于Kotlin的v3.0架构规范]]></title>
        <id>https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/</id>
        <link href="https://jgduan.github.io/post/dohenes-ji-yu-kotlin-de-v30-jia-gou-gui-fan/">
        </link>
        <updated>2021-06-25T14:17:42.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>项目采用了<code>MVVM</code>架构方式+组件化方案+<code>Jetpack</code>常用库，基于<code>Kotlin 1.4.32</code>编译版本，在个别<code>Module</code>的部分区域混合使用了<code>Java（Java 8版本）</code>来进行开发工作，具体使用的三方库及其使用方法、示例将在文末进行讲解。</p>
<hr>
<h1 id="一-架构模式-mvvm">一、架构模式-MVVM</h1>
<p>项目采用<code>MVVM</code>架构模式，这里通过<code>Jetpack</code>的<code>ViewModel</code>组件来更换传统的<code>ViewModel</code>。</p>
<p><a href="https://www.jianshu.com/p/449136bddff6">Android MVVM 模式</a></p>
<hr>
<h1 id="二-project-组件化">二、Project-组件化</h1>
<p>为了各个功能模块之间解耦、<code>Module</code>灵活组合编译运行，便于团队协作开发及后期维护，3.0版本架构在多<code>Module</code>的基础上，采用了组件化方案来进一步优化项目架构。</p>
<ul>
<li>
<p><strong>模块解耦</strong><br>
项目采用组件化方案进行模块的<strong>解耦</strong>处理。</p>
</li>
<li>
<p><strong>组件分类及命名规范</strong><br>
整体架构分层与v2.0版本类似，除了最上层的<code>base、common</code>两大Library基础库，功能成分库继续采用<code>component-xxx</code>来进行命名，包含界面、具体业务逻辑的Library继续用<code>module-xxx</code>进行命名。</p>
</li>
</ul>
<blockquote>
<p>具体可参考<a href="https://jgduan.github.io/post/dohenes-tb-gai-ban-v20-zheng-ti-jia-gou-gui-fan/">【DOHENES】TB改版v2.0整体架构规范</a></p>
</blockquote>
<ul>
<li>
<p><strong>统一的引用配置</strong><br>
为保持引用库版本一致，规避开发过程中不必要的冲突。项目中通过Project根目录下的<code>config.gradle</code>文件，定义通用的构建元素字段，供各个模块进行引用。</p>
</li>
<li>
<p><strong>独立编译运行</strong><br>
发挥组件化方案的优势，通过在<code>config.gradle</code>中配置对应控制变量对各<code>moudle</code>进行<code>library-&gt;application</code>的灵活控制，让<code>module</code>既可以独立编译运行，又可以集成编译，按需灵活配置，方便开发人员协作。</p>
</li>
</ul>
<hr>
<h1 id="三-屏幕分辨率适配">三、屏幕（分辨率适配）</h1>
<p>依据实际的<code>UI</code>设计图，我们以<code>sw-375dp</code>为基准进行屏幕的适配工作，相应适配文件存放于<code>base-&gt;res/values、values-swxxxdp/measure.xml</code>内。<br>
在实际开发中根据UI设计图尺寸直接设置对应控件的尺寸即可（<code>@dimen/common_measure_xxxdp</code>），具体使用示例如下：</p>
<pre><code class="language-java">// 在需要使用地方添加对应的尺寸
android:layout_height=&quot;@dimen/common_measure_xxxdp&quot;
</code></pre>
<hr>
<h1 id="四-数据存储">四、数据存储</h1>
<ul>
<li>
<p><strong>ROOM</strong><br>
<a href="https://blog.csdn.net/yu540135101/article/details/110670477">Android kotlin+协程+Room数据库的简单使用</a><br>
<a href="https://www.jianshu.com/p/0dde643ac045">Android Room的简单使用</a></p>
</li>
<li>
<p><strong>DataStore</strong></p>
</li>
<li>
<p><strong>Native Files</strong><br>
当我们在开发过程涉及到一些需要缓存的文件时，很多应用采取的策略是到<code>SD卡</code>的根目录上创建自己的文件夹然后保存到对应的文件路径下（之前的泰邦设计也是这样做的），虽然达到了缓存文件的目的，但它并不被Android所推荐——当应用卸载后，这些被创建的文件夹仍然存在，造成手机内多出了不少的垃圾文件，这样是极不友好的。<br>
Android建议我们在缓存文件时使用应用专属（这里又分内部存储与外部存储，建议是尽可能使用外部存储进行缓存）的缓存路径进行文件的缓存，当应用被卸载后，这些数据也会随之而消失，从而规避了上述问题。<br>
关于应用专属内、外部存储的更多了解，建议阅读以下文章或自行了解后再进行相关的操作：<br>
<a href="https://blog.csdn.net/s13383754499/article/details/82910704">彻底搞懂Android文件存储---内部存储，外部存储以及各种存储路径解惑</a><br>
<a href="https://www.jianshu.com/p/b752b2e70b8c">Android文件缓存目录</a><br>
重点关注：getExternalCacheDir、getExternalFilesDir。</p>
</li>
</ul>
<hr>
<h1 id="五-kotlin">五、Kotlin</h1>
<ul>
<li>
<p><strong>协程</strong><br>
<a href="https://www.jianshu.com/p/6e6835573a9c">Kotlin协程</a></p>
</li>
<li>
<p><strong>不再使用findViewById</strong><br>
在Module的build.gradle中加上：<code>apply plugin: 'kotlin-android-extensions'</code>，然后就可以直接使用布局中定义的id去访问对应的控件了。</p>
</li>
</ul>
<blockquote>
<p>在使用的时候，你会发现导入的包是<code>import kotlinx.android.synthetic.main.activity_main.*</code>(如layout名称为activity_main.xml)</p>
</blockquote>
<hr>
<h1 id="六-项目中三方库使用规范及示例">六、项目中三方库使用规范及示例</h1>
<ul>
<li>
<p><strong>ARouter——路由</strong></p>
<ul>
<li>概述<br>
一款阿里开源的路由框架，是一个帮助Android进行模块化、组件化开发的开源库。它支持模块间的路由、通信、解耦。</li>
<li>引入
<ul>
<li>添加依赖和配置<pre><code class="language-java">android {
    defaultConfig {
        ...
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
    }
}

dependencies {
    // 替换成最新版本, 需要注意的是api
    // 要与compiler匹配使用，均使用最新版可以保证兼容
    compile 'com.alibaba:arouter-api:x.x.x'
    annotationProcessor 'com.alibaba:arouter-compiler:x.x.x'
    ...
}
// 旧版本gradle插件(&lt; 2.2)，可以使用apt插件，配置方法见文末'其他#4'
// Kotlin配置参考文末'其他#5'

</code></pre>
<blockquote>
<p>所有使用ARouter的Module都必须在<code>build.gradle</code>中<code>dependencies</code>标签内添加<code>annotationProcessor 'com.alibaba:arouter-compiler:x.x.x</code>注释处理器。</p>
</blockquote>
</li>
<li>添加注解<pre><code class="language-java">// 在支持路由的页面上添加注解(必选)
// 这里的路径需要注意的是至少需要有两级，/xx/xx
@Route(path = &quot;/test/activity&quot;)
public class YourActivity extend Activity {
    ...
}
</code></pre>
</li>
<li>初始化SDK<pre><code class="language-java">if (isDebug()) {           // 这两行必须写在init之前，否则这些配置在init过程中将无效
    ARouter.openLog();     // 打印日志
    ARouter.openDebug();   // 开启调试模式(如果在InstantRun模式下运行，必须开启调试模式！线上版本需要关闭,否则有安全风险)
}
ARouter.init(mApplication); // 尽可能早，推荐在Application中初始化

</code></pre>
</li>
<li>发起路由操作<pre><code class="language-java">// 1. 应用内简单的跳转(通过URL跳转在'进阶用法'中)
ARouter.getInstance().build(&quot;/test/activity&quot;).navigation();

// 2. 跳转并携带参数
ARouter.getInstance().build(&quot;/test/1&quot;)
            .withLong(&quot;key1&quot;, 666L)
            .withString(&quot;key3&quot;, &quot;888&quot;)
            .withObject(&quot;key4&quot;, new Test(&quot;Jack&quot;, &quot;Rose&quot;))
            .navigation();

</code></pre>
</li>
<li>使用 Gradle 插件实现路由表的自动加载 (可选)<pre><code class="language-java">apply plugin: 'com.alibaba.arouter'

buildscript {
    repositories {
        mavenCentral()
    }

    dependencies {
        classpath &quot;com.alibaba:arouter-register:?&quot;
    }
}
</code></pre>
</li>
</ul>
</li>
<li>使用规范<br>
在开发过程中，当我们对要进行跳转的页面上添加支持路由的注解时，我们需要遵循以下规则：<br>
<strong>路径需要注意的是至少需要有两级，/xx/xx，我们以/moduleName/className为基准进行对应的命名。</strong></li>
<li>使用示例<pre><code class="language-java">    @Route(path = &quot;/mine/mineActivity&quot;)
    class MineActivity {
    ...
    }
</code></pre>
</li>
<li>注意事项<br>
<strong>在使用该库的每个类的build.gradle文件中要添加如下配置：</strong><pre><code class="language-java">android {
    ...
    defaultConfig {
        ...
        // ARouter--每个使用到路由的Module必须加
        javaCompileOptions {
            annotationProcessorOptions {
                arguments = [AROUTER_MODULE_NAME: project.getName()]
            }
        }
        ...
    }
    ...
}
dependencies {
    // ARouter--每个使用到路由的Module必须加
    annotationProcessor rootProject.ext.dependencies['arouter-compiler']
}
</code></pre>
</li>
</ul>
</li>
<li>
<p><strong>DataBinding——数据绑定</strong></p>
<ul>
<li>
<p>概述<br>
数据绑定库是一种支持库，借助该库，您可以使用声明性格式（而非程序化地）将布局中的界面组件绑定到应用中的数据源。</p>
</li>
<li>
<p>引入<br>
在使用DataBinding的Module中的build.gradle文件中进行如下操作：</p>
<ul>
<li>
<p>在文件最顶端(android标签外部)添加如下插件声明</p>
<pre><code class="language-java">plugins {
    ...
    id 'kotlin-kapt'
}
</code></pre>
</li>
<li>
<p>在android标签内部添加databinding引用（AndroidStudio 4.0+与之前写法不同）</p>
<pre><code class="language-java">buildFeatures {
    dataBinding = true
}
</code></pre>
</li>
</ul>
</li>
<li>
<p>使用</p>
<ul>
<li>修改对应的布局<br>
使用Databinding的布局，最外层必须套一层layout标签，我们要修改对应的布局如下：<pre><code class="language-java">&lt;layout&gt;
    &lt;data&gt;
        ...
    &lt;/data&gt;
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        ...
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;/layout&gt;
</code></pre>
</li>
<li>给对应的控件绑定数据（这里以TextView为例）<br>
首先，在布局中添加一个TextView控件，然后在<code>&lt;data&gt;</code>标签内添加一个属性标签<code>&lt;variable&gt;</code>，其中name属性是指变量名称，type属性是指变量类型<pre><code class="language-java">&lt;layout xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;
    
    &lt;data&gt;

        &lt;variable
            name=&quot;titleStr&quot;
            type=&quot;String&quot; /&gt;
    &lt;/data&gt;
    
    &lt;androidx.constraintlayout.widget.ConstraintLayout&gt;
        &lt;TextView
            android:id=&quot;@+id/tv_title&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;@{titleStr}&quot;
            app:layout_constraintBottom_toBottomOf=&quot;parent&quot;
            app:layout_constraintEnd_toEndOf=&quot;parent&quot;
            app:layout_constraintStart_toStartOf=&quot;parent&quot;
            app:layout_constraintTop_toTopOf=&quot;parent&quot; /&gt;
    &lt;/androidx.constraintlayout.widget.ConstraintLayout&gt;
&lt;layou/&gt;
</code></pre>
在页面中进行赋值操作：<pre><code class="language-java">DataBindingUtil.setContentView&lt;ActivitySimpleBindingImpl&gt;(this, R.layout.activity_simple)
    .apply {
        titleStr = &quot;DataBinding test&quot;
    }
</code></pre>
<blockquote>
<p>注：使用DataBinding的Activity会自动生成<code>ActivityXXXBindingImpl</code>，如SimpleActivity会生成ActivitySimpleBindingImpl类。</p>
</blockquote>
</li>
<li>点击事件的使用</li>
<li>RecyclerView的使用</li>
<li>ImageView加载一张网络图片</li>
</ul>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://www.jianshu.com/p/e8cf690ee8cc">DataBinding + Kotlin</a></p>
</blockquote>
<ul>
<li>
<p><strong>Paging——分页</strong></p>
<ul>
<li>
<p>概述<br>
Paging 库可帮助您加载和显示来自本地存储或网络中更大的数据集中的数据页面。此方法可让您的应用更高效地利用网络带宽和系统资源。Paging 库的组件旨在契合推荐的 Android 应用架构，流畅集成其他 Jetpack 组件，并提供一流的 Kotlin 支持。</p>
<p>使用 Paging 库，您可以更加轻松地在应用的 RecyclerView 中逐步、流畅地加载数据。</p>
</li>
<li>
<p>引入</p>
</li>
<li>
<p>使用规范</p>
</li>
<li>
<p>示例</p>
</li>
<li>
<p>注意事项</p>
</li>
</ul>
</li>
<li>
<p><strong>BottomNavigation——底部导航栏</strong><br>
<a href="https://www.jianshu.com/p/f0021265845f">Kotlin-BottomNavigationView</a><br>
<a href="https://blog.csdn.net/afei__/article/details/80950288">Android底部导航栏，三种风格和实现</a><br>
<a href="https://www.jianshu.com/p/1cebf8cd1a86">Android 底部导航之BottomNavigationBar</a><br>
<a href="https://blog.csdn.net/abs1004/article/details/77330726">安卓 BottomNavigationBar 底部导航栏 最简单用法详解</a></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】git命令行登陆github进行操作]]></title>
        <id>https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/</id>
        <link href="https://jgduan.github.io/post/zhuan-git-ming-ling-xing-deng-lu-github-jin-xing-cao-zuo/">
        </link>
        <updated>2021-06-24T16:32:40.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p><strong>转载自<a href="https://www.jianshu.com/p/6e3f9e4e8e69">git命令行登陆github进行操作</a>，侵删。</strong></p>
</blockquote>
<p>登陆github必须先创建SSH key<br>
因为本地Git仓库和GitHub仓库之间的传输是通过SSH加密传输的，GitHub需要识别是否是你推送，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送，所以需要配置ssh key。</p>
<hr>
<h2 id="1创建ssh-key">1.创建SSH Key。</h2>
<p>在用户主目录（C:\Users\Administrator）下，看看有没有.ssh文件，如果有，再看文件下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接到下一步。如果没有，打开Git Bash，输入命令，创建SSH Key</p>
<p><code>$ ssh-keygen -t rsa -C &quot;你自己注册GitHub的邮箱&quot;</code></p>
<hr>
<h2 id="2接下来到github上打开account-settings-ssh-keys页面然后点击add-ssh-key填上title随意写在key文本框里粘贴-id_rsapub文件里的全部内容">2.接下来到GitHub上，打开“Account settings”--“SSH Keys”页面，然后点击“Add SSH Key”，填上Title（随意写），在Key文本框里粘贴 id_rsa.pub文件里的全部内容。</h2>
<p>id_rsa.pub 默认在C:\Users\Administrator.ssh</p>
<p>每台想要登陆某个github账号的主机都需要有一个对应的key，例如你有一个github账号，你在你的笔记本和台式上都要创建key</p>
<hr>
<h2 id="3git-bash里输入下面的命令登陆">3.git bash里输入下面的命令登陆</h2>
<p><code>$ ssh -T git@github.com</code></p>
<p>如果看到 hi + 你的用户名说明密钥验证通过了，你已经可以上传下载了<br>
<img src="https://jgduan.github.io//post-images/1624552568098.png" alt="" loading="lazy"></p>
<hr>
<h2 id="4设置username和email因为github每次commit都会记录他们">4.设置username和email，因为github每次commit都会记录他们</h2>
<p>git commit 命令会记录提交者的信息，所以使用git前必须先添加两条信息</p>
<p><code>$ git config --global user.name &quot;你的GitHub登陆名&quot;</code><br>
<code>$ git config --global user.email &quot;你的GitHub注册邮箱&quot;</code></p>
<blockquote>
<p>（其实可以不和github上面的用户名邮箱一致，只是为了避免混淆）</p>
</blockquote>
<hr>
<h2 id="5接下来就是把本地仓库传到github上去">5.接下来就是把本地仓库传到github上去</h2>
<p><code>$ git remote add origin git@github.com:userName/yourProject.git</code></p>
<p>//关联一个远程库命令，git@后面填写你的github repository（仓库），在github里面创建仓库后有http和ssh的链接，origin是你给这个仓库起的名字，可以自定义，下面命令中的origin也要相应改变</p>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1624552692583.webp" alt="" loading="lazy"></figure>
<p>git push -u origin master //把本地已经commit 的结果push到github的origin 仓库的master分支中</p>
<hr>
<p>##【拓展阅读】<br>
<a href="https://www.cnblogs.com/luhuan/p/9072820.html">Windows下配置Git多账号github码云</a></p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Plugin version (1.4.32) is not the same as library version (1.4.10) 警告的解决办法]]></title>
        <id>https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/</id>
        <link href="https://jgduan.github.io/post/android-plugin-version-1432-is-not-the-same-as-library-version-1410-jing-gao-de-jie-jue-ban-fa/">
        </link>
        <updated>2021-06-24T15:36:58.000Z</updated>
        <content type="html"><![CDATA[<h1 id="问题">问题</h1>
<p>在开发<code>Kotlin</code>项目的过程中，使用<code>kotlin-stdlib</code>标准库时，遇到了如下警告提示：</p>
<pre><code class="language-java">Plugin version(1.4.32) is not the same as library version(1.4.10)
</code></pre>
<p>提示的大致意思是说我们的插件版本和依赖库的版本不一致，原因是因为一些第三方的Library库所依赖的版本比较低，而我们在项目中所指定的依赖版本比较高，从而导致AndroidStudio给我们提出了警示。</p>
<hr>
<h1 id="解决办法">解决办法</h1>
<p><strong>直接在module的build.gradle中删除依赖即可解决问题</strong></p>
<pre><code class="language-java">// 删除moudle-build.gralde文件中的该段
implementation &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
</code></pre>
<p>详情请移步官网查看官方声明的这篇文章：<a href="https://kotlinlang.org/docs/whatsnew14.html#dependency-on-the-standard-library-added-by-default">What's new in Kotlin 1.4</a><br>
<img src="https://jgduan.github.io//post-images/1624550094222.png" alt="" loading="lazy"></p>
<p>图中的意思是：</p>
<blockquote>
<p>Kotlin默认添加了stdlib的依赖，您不再需要stdlib在任何 Kotlin Gradle 项目（包括多平台项目）中声明对库的依赖。默认情况下添加依赖项。</p>
</blockquote>
<blockquote>
<p>自动添加的标准库将是 Kotlin Gradle 插件的相同版本，因为它们具有相同的版本。</p>
</blockquote>
<blockquote>
<p>对于特定于平台的源集，使用库的相应特定于平台的变体，同时将公共标准库添加到其余部分。Kotlin Gradle 插件将根据您的 Gradle 构建脚本的kotlinOptions.jvmTarget 编译器选项选择合适的 JVM 标准库。</p>
</blockquote>
<p>上面所说的Kotlin插件，是指Project根目录下的build.gradle文件中的Kotlin插件，具体如下图所示：<br>
<img src="https://jgduan.github.io//post-images/1624550446644.png" alt="" loading="lazy"></p>
<p>这样一来，让人糟心的警告就不见了。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Handler】This Handler class should be static or leaks might occur (anonymous android.os.Handler)]]></title>
        <id>https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/</id>
        <link href="https://jgduan.github.io/post/handler-this-handler-class-should-be-static-or-leaks-might-occur-anonymous-androidoshandler/">
        </link>
        <updated>2021-06-20T15:12:00.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>Android开发者在日常开发过程中，经常会使用到<code>Handler</code>用来接收消息进行后续处理，然而当我们在<code>Handler#handleMessage(Message msg)</code>方法中做UI相关操作时，AndroidStudio就会报出如下警告：</p>
<pre><code class="language-java">This Handler class should be static or leaks might occur (anonymous android.os.Handler)
Inspection info:Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected.
If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue.
If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows:
   1. Declare the Handler as a static class;
   2. In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler;
   3. Make all references to members of the outer class using the WeakReference object.
</code></pre>
<p>警告内容是提示我们在内部类<code>Handler#handleMessage(Message msg)</code>方法中处理UI相关操作时，可能会造成内存泄漏风险，同时在警告内容中，指导给开发者相应的解决方案——内部类Handler静态化、使用弱引用<code>WeakReference</code>来进行抑制处理、访问所有的外部成员通过<code>WeakReference</code>引用对象来进行访问。</p>
<blockquote>
<p>除此之外，我们还可以在Activity被销毁时通过<code>Handler#removeCallbacksAndMessages(Object token)</code>方法来销毁对应<code>Handler</code>所有的消息队列。</p>
</blockquote>
<hr>
<h1 id="主动创造一个引起内存泄漏的handler">主动创造一个引起内存泄漏的Handler</h1>
<p>这里我们通过创造一个有内存泄漏风险的<code>Handler</code>通过不断切换<code>Activity</code>横竖屏来进行测试，看是否会引发内存泄漏，示例如下：</p>
<pre><code class="language-java">// HandlerTestActivity.java
public class HandlerTestActivity extends AppCompatActivity {
 
    // 创建匿名Handler内部类的对象
    private Handler leakHandler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
        }
    };
 
    @Override
    protected void onCreate(@Nullable Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_handler_test);
 
        leakHandler.postDelayed(new Runnable() {
            @Override
            public void run() {
                Logger.d(&quot;leakHandler 延迟执行,内存泄露测试&quot;);
            }
        }, 5 * 60 * 1000);
    }
}
</code></pre>
<p>通过多次运行分析后，我们发现：应用内存占用出现了明显了升高;</p>
<p><strong>简单描述下原因:</strong><br>
由于上面的<code>Handler</code>内部类定义在<code>UI</code>线程中,因此使用的主线程的<code>Looper</code>和 <code>MessageQueue</code>;<br>
<code>MessageQueue</code>中的<code>Message</code>会持有<code>Handler</code>对象;<br>
匿名<code>Handler</code>内部类对象持有着外部<code>Activity</code>的强引用;<br>
以上三点导致当有<code>Message</code>未被处理之前, 外部类<code>Activity</code>会一直被强引用,导致即使发生了销毁,也无法被GC回收;</p>
<p>因此处理方法通常有两种:</p>
<p>在外部类<code>Activity</code>销毁时取消所有的<code>Message</code>,即 <code>leakHandler.removeCallbacksAndMessages(null)</code>;<br>
让内部类不要持有外部<code>Activity</code>的强引用;<br>
<code>AndroidStudio</code>给出的提示方案属于第二种。</p>
<blockquote>
<p>我们通过smali源码来一步步探究验证下;<br>
<a href="https://blog.csdn.net/weixin_33923762/article/details/91430429">[smali] This Handler class should be static or leaks might occur</a></p>
</blockquote>
<hr>
<h1 id="弱引用的handler">弱引用的Handler</h1>
<p>因大家在项目中可能存在多出使用<code>Handler</code>，我们可以封装一个公共的<code>WeakHandler</code>类，抽取公共方法供其它使用区域在此基础上继承实现，实现后的代码如下：</p>
<pre><code class="language-java">public class WeakHandler&lt;T extends Activity&gt; extends Handler {
    private final WeakReference&lt;T&gt; mWkActivity;

    public WeakHandler(T activity) {
        mWkActivity = new WeakReference&lt;&gt;(activity);
    }

    public T getActivity() {
        return mWkActivity.get();
    }

//    @Override
//    public void handleMessage(Message msg) {
//        super.handleMessage(msg);
//        T targetAct = mWkActivity.get();
//        // 通过`WeakReference`对象去操作外部`Activity`属性和事件
//        if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
////           targetAct.对象
//        }
//    }

}
</code></pre>
<p>那么在其它地方我们可以通过继承<code>WeakHandler</code>类的方式来实现弱引用的<code>Handler</code>，示例如下：</p>
<pre><code class="language-java">SimpleWeakHandler simpleWeakHandler = new SimpleWeakHandler(SimpleActivity.this);
    private static class SimpleWeakHandler extends WeakHandler&lt;SimpleActivity&gt; {

        public SimpleWeakHandler(SimpleActivity activity) {
            super(activity);
        }

        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg);
            SimpleActivity targetAct = getActivity();
            if (targetAct != null &amp;&amp; !targetAct.isFinishing()) {
                targetAct.tvTitle.setText(&quot;SimpleWeakHandler&quot;);
            }
        }
    }
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【合肥】Android 15k+招聘列表]]></title>
        <id>https://jgduan.github.io/post/he-fei-android-15kzhao-pin-lie-biao/</id>
        <link href="https://jgduan.github.io/post/he-fei-android-15kzhao-pin-lie-biao/">
        </link>
        <updated>2021-06-03T14:58:17.000Z</updated>
        <content type="html"><![CDATA[<table>
<thead>
<tr>
<th>企业名称</th>
<th>规模</th>
<th>薪资范围</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://www.zhipin.com/job_detail/d9520547f8e6810d1nZy3tq9EFdX.html?ka=search_list_jname_8_blank&amp;lid=7e4TsFRJ8rx.search.8&amp;securityId=0MTB9UTp35FML-l1tN71WWrZdpvDkTdQdp0jtNzeS5lcmAtQ8wv1VdQLP3YVyd5Xy3UBVVzjpwpYlY0x9STelScv443n1JGi0G7yWuffajDwOKpI">声智科技</a></td>
<td>100-499人</td>
<td>14-24K·14薪</td>
<td>B轮，BLE优先，注册2000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/74de27973b151e941nZ73dy9ElVQ.html?ka=search_list_jname_3_blank&amp;lid=7e4TsFRJ8rx.search.3&amp;securityId=HfXkRdJw7U651-R1vFwoW-XeqQl5ZoKj1anZnXOqGs60SC1EfasnQnIdIK3EnyhoJ2o1rNlqN9owlPzRsX2wuv-8Ancc2PlIkCqosrsj8puBDtHIvDD0">星河智联</a></td>
<td>100-499人</td>
<td>15-30K·14薪</td>
<td>讯飞+广汽，注册8500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/0d3783ca84c5f16b1nZ73dy9ElJX.html?ka=search_list_jname_71_blank&amp;lid=7e4TsFRJ8rx.search.71&amp;securityId=qdLjqsTw-P7Vu-H1m690t_zxqjhl400DMnDG082DGT-6d006_5a_3fgfMWzNxlvJFSP0vQKe9t-OE4sjYhi1sySlW3TR6R6ml4H6QS2m8jK2VR5fpZPd">星河智联</a></td>
<td>100-499人</td>
<td>16-27K·15薪</td>
<td>4年SDK经验，注册8500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/50f7f60b0a9068d41nV-3ti4FVZS.html?ka=search_list_jname_6_blank&amp;lid=7e4TsFRJ8rx.search.6&amp;securityId=G2WqzXeq8ogk--g1SGrF1nc1V_3PLxRAoYreJU8V-d7AqMY17YqztlCLMUSOZe9eCXs3WTem1LMiAObfsJehCPy6BvPDrTUVQyQM1xxQL8Ul9jBGbw%7E%7E">至博光电</a></td>
<td>20-99人</td>
<td>18-28K·14薪</td>
<td>注册9900万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/49ecb91030fa20e91XVy29S5EFA~.html?ka=search_list_jname_9_blank&amp;lid=7e4TsFRJ8rx.search.9&amp;securityId=eWosVjUVb3HS8-11jIVSN4J16MYm_8CuV__TbocyKiLQxONVmiwuQoiv93OY4U3Jf7D9eSiKwUAyFyZreQbCjhUT29wss61jXiZpxFpTeKx7YFQJ">ZOOM</a></td>
<td>500-999人</td>
<td>12-23K·14薪</td>
<td>已上市，注册730w美元</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/a4d1bf001f7554841nd62tW5E1BW.html?ka=search_list_jname_13_blank&amp;lid=7e4TsFRJ8rx.search.13&amp;securityId=Ofye-K8cl5Mr7-n1spJMDl6QcFkPzBstSB0fn-6nRjeY06nK399YAc--VLHkq3iS0fJKKp_PAG-QupbUsSbxKq8bU59b5iUgvOHg2iqZadmlGmlM">爱点击</a></td>
<td>1000-9999人</td>
<td>15-30K·14薪</td>
<td>注册26900万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/034df4a46d925f801nZz0tu9ElpT.html?ka=search_list_jname_16_blank&amp;lid=7e4TsFRJ8rx.search.16&amp;securityId=a53zI2spdrmlz-B1qslaixw2qt05RR0t8TJgaCw9GGekrRovpiiCEyfnVkNNRnodHLSqZh82KRTcQg6RdmfdusG8FL0Zh9wQtKnkU9lErdkNwvhvXQ%7E%7E">深圳优仕康</a></td>
<td>20-99人</td>
<td>12-24K</td>
<td>独立开发，注册1000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/cefdcaa23625427e33x83Nm_FVE~.html?ka=search_list_jname_17_blank&amp;lid=7e4TsFRJ8rx.search.17&amp;securityId=Cf_9WxXyCOAI5-F1d0cV5Jj3sG8CShCZPtbm32ZUFfG0VtoJYNicvVgv4P-ZG-V9NIZ6Il3orBtjiRGJs62pzajXzOQbWn_UEk5Z7nnLWu7u4ZTG">米娱科技</a></td>
<td>100-499人</td>
<td>12-22K·14薪</td>
<td>注册500万人民币</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/7b8fab8a3f28be1433Ny2d29FVA~.html?ka=search_list_jname_52_blank&amp;lid=7e4TsFRJ8rx.search.52&amp;securityId=yXTSOx7BEdbnS-R1rBucgK20hxY-5uH6Vq4elL65HxvmkHs7WVYxsdoVI4Amst7jCZ1hNhG0AUjJwaiXRZweQUs0sYJu3PUCaGfl7zCDz0scu5bt">米娱科技</a></td>
<td>100-499人</td>
<td>15-25K·14薪</td>
<td>独立开发要求，注册500万人民币</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/3b9003a1a5de83fa1nZ939u8EldU.html?ka=search_list_jname_18_blank&amp;lid=7e4TsFRJ8rx.search.18&amp;securityId=CudY8Fq5WN8e9-a1JkTZp7BZLnF2DGymHrDuxAYGp1nhzrhr6X1TjUdWDhzTcUGWqBSU1PujSTOjpJdOUi3kuqwsGLVKyPCgwP5oUUk3RSYgKeTNVD0%7E">中科数盾</a></td>
<td>100-499人</td>
<td>20-30K·14薪</td>
<td>Android Leader岗，注册2200万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/25f432e3e85bfcd11nRy2tu5GVdT.html?ka=search_list_jname_19_blank&amp;lid=7e4TsFRJ8rx.search.19&amp;securityId=LtF76yyJ_924q-a1BFRtZ61eZYx4n6MgLi17RXcX4jUO2WH0GNO8gWFkPzq6eQQ9vN0mrJB5CFiaU4ks5twx6rQ4oTe4_v6OE8_h75ko_oZbmL_KaXg%7E">徽娱传媒</a></td>
<td>20-99人</td>
<td>12-22K·14薪</td>
<td>注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/ff34bebf7c8627291nd43dq5FltS.html?ka=search_list_jname_21_blank&amp;lid=7e4TsFRJ8rx.search.21&amp;securityId=_Sf8VeIr-oMZQ-p1g-lg_6TMKseg2RKl602khYJHQVj8VO1SJzCZQ8eQOuUel2E6waM9ydSDjtuqxSorCC_gJKswb-MKsRJDm-Kuu98mELqALCM69V0%7E">的卢深视</a></td>
<td>100-499人</td>
<td>14-28K·15薪</td>
<td>Android平台算法SDK，注册595万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/3060c00d3a1713203nJ92Ni4Flc~.html?ka=search_list_jname_24_blank&amp;lid=7e4TsFRJ8rx.search.24&amp;securityId=uZFPD8cGA1FgP-41owavIWLodXP6ho090YOYEFq104bQfmE7C-LL3ZeZmuFRGmzO2ddwIrowMt37bMlBk5JAEJcWx8O4FbXl-HGUZjLg7ikWme6A">瀚茗斯</a></td>
<td>20-99人</td>
<td>14-28K</td>
<td>Android Leader岗，注册1000万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/291d91989aaa84b51nZ-2tS4FlNT.html?ka=search_list_jname_25_blank&amp;lid=7e4TsFRJ8rx.search.25&amp;securityId=IczMxAR1txtjz-v1NacOcigcr-f00fD-68Ziy6wJiEtXyPlKADl7rVKxNNQVd2Qxw0UnvT3-YTA26CGrVJgkhbd0pJBBY5ggZ4LiBDkOBGeQYY0O4dk%7E">屯大软件</a></td>
<td>20-99人</td>
<td>15-23K</td>
<td>可能是外包，注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/d293564f07f222c51nB83ty8ElBY.html?ka=search_list_jname_51_blank&amp;lid=7e4TsFRJ8rx.search.51&amp;securityId=LlQ9wQKZ_pZL3-o1b29PKzxqdFmiAcb6LV8xQErkKfDFgRqtZmLvCJoMIGrZIfi9o_Aq-7Dh3AO-reG8eROmJYM3YWQ8szVjctV0YaiGa_7uRKbo">科大讯飞</a></td>
<td>10000人以上</td>
<td>15-25K·14薪</td>
<td>RN/Flutter优先，注册222473万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/eac33ac5cf350d521nBz3d2_FFBU.html?ka=search_list_jname_66_blank&amp;lid=7e4TsFRJ8rx.search.66&amp;securityId=w3fBWRwbCVmPx-E1jyrIoTX7l-ZnfrtoRp-vgH_fi0Vg6BaFpyGWTD2iph1hYmlneBDJjAKkh9P2BkhnAEwyEMe7K_eNFwwCQyXVGnELtOStkMI%7E">科大讯飞</a></td>
<td>10000人以上</td>
<td>13-23K·14薪</td>
<td>注册222473万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/b1e62a6936767a641nZ_09m-FlpT.html?ka=comp_joblist_1">江湖科技</a></td>
<td>20-99人</td>
<td>15-20K</td>
<td>Flutter，注册500万</td>
</tr>
<tr>
<td><a href="https://www.zhipin.com/job_detail/b2214314e8c5bc131nZz29q4EFBW.html?ka=job_recommend_1">一视科技</a></td>
<td>20-99人</td>
<td>15-25K·14薪</td>
<td>注册500万</td>
</tr>
</tbody>
</table>
<hr>
<blockquote>
<p>持续维护中。。。</p>
</blockquote>
]]></content>
    </entry>
</feed>