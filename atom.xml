<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://jgduan.github.io/</id>
    <title>Zihao&apos;s blog</title>
    <updated>2021-08-04T14:35:48.553Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://jgduan.github.io/"/>
    <link rel="self" href="https://jgduan.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://jgduan.github.io/images/avatar.png</logo>
    <icon>https://jgduan.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Zihao&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[【InterView】Android基础知识回顾]]></title>
        <id>https://jgduan.github.io/post/interview-android-ji-chu-zhi-shi-hui-gu/</id>
        <link href="https://jgduan.github.io/post/interview-android-ji-chu-zhi-shi-hui-gu/">
        </link>
        <updated>2021-08-02T14:44:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-android基础架构">一、Android基础架构</h1>
<ul>
<li>
<p><strong>Android 系统架构</strong><br>
<img src="https://jgduan.github.io//post-images/1627916220584.jpg" alt="" loading="lazy"><br>
Android的系统架构采用分层架构的思想，架构清晰，层次分明，协同工作且各模块之间进行了高度解耦。</p>
<ul>
<li>
<p>Linux Kernel<br>
Linux内核层：Android最底层最核心的部分，为Android提供了核心的系统服务，如：安全系统、内存管理、进程管理、硬件驱动等。</p>
</li>
<li>
<p>Libraries、Android Runtime<br>
系统运行库层：当使用Android应用框架时，Android系统会通过一些C/C++库来支持我们使用的各个组件，使其更好的为我们服务，比如其中的SQLite（关系数据库），Webkit（Web浏览器引擎）。</p>
</li>
<li>
<p>Application Framework<br>
应用框架层：这一层是编写Google发布的核心应用时所使用的API框架，开发人员同样可以使用这些框架来开发自己的应用，这样便简化了程序开发的结构设计，但是必须要遵守其框架的开发原则。</p>
</li>
<li>
<p>Applications<br>
应用层：应用是用java语言编写的运行在虚拟机上的程序，比如Email客户端，SMS短消息程序，日历等。</p>
</li>
</ul>
</li>
<li>
<p><strong>Android 架构总览</strong><br>
<img src="https://jgduan.github.io//post-images/1627916089526.png" alt="" loading="lazy"><br>
详细解析请移步：<a href="https://source.android.google.cn/devices/architecture">Google官方文档</a></p>
</li>
</ul>
<hr>
<h1 id="二-android四大组件">二、Android四大组件</h1>
<ul>
<li>
<p><strong>Activity</strong><br>
活动，作为Android系统中的人机交互的第一界面，负责向用户展示信息和处理结果。<br>
一个App中，至少要有一个Activity。</p>
</li>
<li>
<p><strong>ContentProvider</strong><br>
内容提供者，为不同的应用之间的数据共享提供统一的接口。</p>
<blockquote>
<p>Android系统中，处于安全性的考虑，应用内的数据是对外隔离的，要想让其它应用能够使用自己的数据（如：通讯录等），这个时候就需要使用ContentProvider来进行应用间数据的共享。</p>
</blockquote>
</li>
<li>
<p><strong>Service</strong><br>
服务，可以在后台长时间的运行，不提供用户界面。一个应用程序组件可以启动一个服务，它可以在后台/前台运行。此外，一个组件可以绑定到一个服务与它交互，甚至执行进程间通信(IPC)。例如，一个服务可能处理网络通信、播放音乐、计时操作或与一个内容提供者交互，都在后台执行。</p>
<p>服务从大方向可分为系统服务与应用本地服务（LocalService）。</p>
</li>
<li>
<p><strong>BroadCastReceiver</strong><br>
广播接收器，用于接收应用内、外发出的广播消息。<br>
广播同样可以分为系统广播与应用内广播。</p>
</li>
</ul>
<hr>
<h1 id="三-contenxt">三、Contenxt</h1>
<p><img src="https://jgduan.github.io//post-images/1627917516063.webp" alt="" loading="lazy"><br>
Android上下文对象，用于联系Android应用内的上下沟通，通过它，我们可以获取到应用程序的资源（字符串、图片等），也可以进行广播的收发、服务的启动、接受Intent等。</p>
<p>Application、Activity、Service都继承自Context，在其onCreate时，都会创建对应的Context对象，它们所创建的Context对象的生命周期与其本身相关联。</p>
<hr>
<h1 id="四-android视图架构">四、Android视图架构</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1627917650204.png" alt="" loading="lazy"></figure>
<ul>
<li>
<p>一个Activity对应一个Window（一般为PhoneWindow，这个时候，Activity还没有任何东西展示给用户看）；</p>
</li>
<li>
<p>DecorView实际上才是我们真正看得见摸得着的视图范围，一个Decor View一般包括一个TitleView与一个ContentView，DecorView的所有点击时间，都是通过WMS进行接收，并通过Activity对象来响应对应的OnClickListener；</p>
</li>
<li>
<p>ContentView是一个id为content的FragmentLayout，只有我们在Activity的onCreate中调用setContentView方法设置要显示的View后，ContentView才有内容展示给用户。</p>
</li>
</ul>
<hr>
<h1 id="五-android控件树">五、Android控件树</h1>
<p><img src="https://jgduan.github.io//post-images/1627917712990.png" alt="" loading="lazy"><br>
当Activity在onCreate中调用setContentView后，AMS会调用Activity的onResume方法，这是系统会把DecorView添加到PhoneWindow中，这时界面内容才会展示给用户看到。</p>
<hr>
<h1 id="六-view相关">六、View相关</h1>
<ul>
<li>
<p><strong>View的测量</strong><br>
View的测量，一般在onMeasure中进行，自定义View如果想要适配warp_content的话，一定要重写onMeasure方法对View大小进行测量；</p>
<p>View测量的关键是MeasureSpec，它是一个32位的数据，高两位表示对应的测量模式，总共有以下三种测量模式：</p>
<ul>
<li>EXACFLY<br>
精确模式：只有在指定View宽高数值或match_parent的情况下，才会使用。<br>
它也是默认的测量模式，不重写onMeasure方法，是不能使用其它测量模式的。</li>
<li>AL_MOST<br>
最大值模式：只有设置warp_content的情况下，才会使用这种测量模式。</li>
<li>UNSPECIFIED<br>
不指定大小的测量模式，这个模式比较奇怪，View想多大就可以多大，通常只有在绘制自定义View的时候才有可能会用到。</li>
</ul>
</li>
<li>
<p><strong>View的绘制</strong><br>
View的绘制在onDraw(Canvas canvas)方法中进行，绘制View必须在画布（Canvas）上进行。</p>
</li>
</ul>
<hr>
<h1 id="七-viewgroup相关">七、ViewGroup相关</h1>
<ul>
<li>
<p><strong>ViewGroup测量</strong><br>
当ViewGroup的大小为warp_content时，ViewGroup就需要对其子View进行遍历，以便获得所有子View的大小，通过计算从而决定自己的大小。而在其它情况下，会通过具体的指定值来设置自身的大小。</p>
<p>ViewGroup在测量时通过遍历所有的子View，从而调用子View的Measure方法来获得每一个子View的测量结果。</p>
<p>当子View完成测量后，ViewGroup在执行Layout的过程时，同样会通过遍历子View的Layout方法，来指定其具体的显示位置，从而决定其布局位置。</p>
<p>在自定义ViewGroup时，通常会重写onLayout方法来控制子View的显示逻辑，如果需要支持warp_content的话，还需要重写onMeasure方法。</p>
</li>
<li>
<p><strong>ViewGroup的绘制</strong><br>
ViewGroup通常情况下不需要绘制，因为它本身没有需要绘制的东西。</p>
<p>ViewGroup会通过dispatchDraw方法来绘制其子View，其过程同样是遍历子View，并调用子View的绘制方法来完成绘制工作。</p>
</li>
<li>
<p><strong>自定义一个可滑动的ViewGroup</strong></p>
<ul>
<li>重写<code>onMeasure()</code>方法来对所有的子View进行测量；</li>
<li>重写<code>onLayout()</code>方法来确定调整子View的位置；</li>
<li>重写<code>onTouchEvent()</code>方法来添加对应的滑动响应时间，通过<code>scrollBy()</code>方法来辅助视图的滑动，如果要添加手指离开屏幕的粘性回弹效果，可以通过<code>Scroller</code>类来进行对应的控制。</li>
</ul>
</li>
</ul>
<hr>
<h1 id="八-事件拦截机制">八、事件拦截机制</h1>
<blockquote>
<p>当Android系统捕获到用户的各种输入事件后，如何准确地传递给真正需要这个事件的控件呢？<br>
Android给我们提供了一套完整的事件传递、处理机制来帮助开发者完成准确的事件分配与处理。</p>
</blockquote>
<ul>
<li>
<p><strong>什么是触摸事件</strong><br>
触摸事件就是捕获触摸屏幕后产生的事件。<br>
当点击一个按钮时，通常就会产生两个或者三个事件——按下，滑动，抬起。</p>
</li>
<li>
<p><strong>MotionEvent(运动事件)</strong><br>
Android为触摸事件封装了一个类——<code>MotionEvent</code>，如果重写<code>onTouchEvent()</code>方法，你就会发现该方法的参数就是一个<code>MotionEvent</code>对象。<br>
MotionEvent类里面封装了需要事件相关的东西，如触摸点的坐标，可以通过<code>event.getX()</code>方法和<code>event.getRawX()</code>方法取出坐标点；再比如获取点击事件的类型，可以通过不同的<code>Action(如：MotionEvent.ACTION_DOWN，MotionEvent.ACTION_MOVE，MotionEvent.ACTION_UP)</code>来进行区分，并实现不同的逻辑。</p>
</li>
<li>
<p><strong>触摸事件的拦截</strong></p>
</li>
</ul>
<blockquote>
<p>dispatchTouchEvent--派遣 / 调度触摸事件<br>
onInterceptToucheEvent 拦截 / 截获触摸事件<br>
onTouchEvnet 触摸事件响应<br>
方法的执行顺序：假设从上到下有ViewGroup_A，ViewGroup_B，View_C方法，那么在事件传递时的调用顺序：<code>ViewGroup_A#dispatchTouchEvent()-&gt;ViewGroup_A#onInterceptToucheEvent()-&gt;ViewGroup_B#dispatchTouchEvent()-&gt;ViewGroup_B#onInterceptToucheEvent()-&gt;View_C#dispatchTouchEvent()</code>；<br>
在事件响应时的调用顺序：<code>View_C#onTouchEvent()-&gt;ViewGroup_B#onTouchEvent()-&gt;ViewGroup_A#onTouchEvent()</code>。<br>
Android中的View是以<strong>树形结构</strong>分布的，事件传递是自上而下（从最外层的ViewGroup传递到最下层的View）的，事件的响应处理顺序是自下而上（最下层的子View响应，然后通过<code>onTouchEvent()</code>方法逐级传递至最外层的ViewGroup），<strong>一个触摸事件的处理，是先自上而下进行事件传递，然后再自下而上进行事件处理（自上而下逐步下发指令，上级可直接拦截指令，自下而上逐步上报处理结果，下级可选择跳过不处理交给上级进行事件的处理）。</strong><br>
- 事件传递<br>
事件从最外层的ViewGroup传递到最下层的View逐步进行传递，这时会触发<code>dispatchTouchEvent()</code>方法与<code>onInterceptToucheEvent()</code>方法，ViewGroup相对View，多了<code>onInterceptToucheEvent()</code>方法，它是时间拦截的核心方法。<br>
事件传递的过程中，我们一般通过<code>onInterceptToucheEvent()</code>方法来来接事件的传递，如果返回值是true，则表示当前View / ViewGroup拦截了触摸事件并将它消费掉了，不需要下面的子View / ViewGroup进行特殊的处理；如果返回值是false，则表示当前的View / ViewGroup不拦截消费触摸事件，事件将逐级传递给下面的View。<br>
- 事件处理<br>
事件从自下而上从View到最外层的ViewGroup逐步进行对应的响应处理，这时会触发<code>onTouchEvent()</code>方法，该方法返回true时表示事件已经被处理，不需要上级进行审核处理了；如果返回false，则表示当前View不对事件进行任何处理，交给上一层进行处理。</p>
</blockquote>
<hr>
<h1 id="九-listview-recyclerview的优化技巧">九、ListView / RecyclerView的优化技巧</h1>
<ul>
<li>
<p><strong>ViewHolder模式</strong><br>
ViewHodler模式是提高视图列表效率的一个很重要的方法，它充分利用了试图列表的视图缓存机制，避免了每次在调用<code>getView()</code>时都去通过<code>findViewById()</code>来实例化控件，使用ViewHolder模式能够提高50%以上的效率，同时该缓存复用机制能够有效的降低因不断新建控件对象导致的内存开销。</p>
</li>
<li>
<p><strong>ListView空处理</strong><br>
当我们展示的数据内容为空时，ListView不会展示任何数据或者提示，如果我们需要在这种情况下完善用户需求，在数据为空时进行相应地提示，可以通过ListView提供的一个方法——<code>setEmptyView()</code>来设置空数据情况下的提示内容。</p>
</li>
<li>
<p><strong>ListView的滑动监听</strong></p>
<ul>
<li>OnTouchListener</li>
<li>OnScrollListener<br>
OnScrollListener是AbsListView中提供的监听事件，它相对OnTouchListener更为灵活，有两个回调方法——<code>onScrollStateChanged()和onScroll()</code>（该方法在滚动时会一直调用）。</li>
</ul>
</li>
<li>
<p><strong>ListView弹性效果</strong><br>
通过重写<code>overScrollBy()</code>方法，修改对应的返回值，如：将maxOverScrollY修改为非0值即可看到效果，数值越大越明显。（maxOverScrollY的默认值是0）</p>
</li>
</ul>
<hr>
<h1 id="十-scroll分析">十、Scroll分析</h1>
<ul>
<li>
<p><strong>滑动效果是如何产生的</strong><br>
滑动一个View，本质上就是移动一个View，它的原理与动画效果差不多——都是通过不断改变View的坐标来实现这一效果。因此，要实现View的滑动，必须先监听用户的触摸事件，并且根据事件传入的坐标动态且不断的变更View的坐标，从而实现View跟随用户触摸的滑动而滑动。</p>
<p>Android坐标的原点，以屏幕左上角的位置为（0，0）开始。</p>
</li>
<li>
<p><strong>发生滑动效果的原因</strong></p>
</li>
<li>
<p><strong>如何处理、实现滑动效果</strong></p>
<ul>
<li>layout<br>
通过<code>onTouchEvent()</code>获取用户触摸事件，在该方法内可以通过MotionEvent类获取对应的事件模式、获取对应的坐标，然后通过重写<code>layout()</code>方法调整View的left,top,right,bottom的偏移量来不断的改变子View的位置。</li>
<li>offsetLeftAndRight()与offsetTopAndBottom()<br>
也可以通过<code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code>方法来进行View的移动，这两个方法相当于系统提供给我们一个对左右、上下移动的API封装，当计算出对应的偏移量时，调用该方法即可完成对View的重新布局，效果与上面使用<code>layout()</code>方法是一样的。</li>
<li>LayoutParams<br>
LayoutParams保存了一个View的布局参数，因此可以通过改变LayoutParams来动态修改一个View的布局位置参数，从而达到改变View位置的效果。</li>
<li>scrollTo与scrollBy<br>
scrollTo(x,y)表示移动到一个具体的坐标点(x,y)；scrollBy(dx,dy)表示移动到增量的dx,dy。<br>
<strong>scrollTo与scrollBy的移动只是移动了View的content——即只是移动了View内部包含的内容，并没有移动View本身；如果我们在ViewGorup调用该方法，会移动所有子View；如果在View中使用，那么移动的就是View的内容。通过设置偏移量的相反值即可达到移动效果。</strong></li>
<li>scroller</li>
<li>属性动画</li>
<li>ViewDragHelper</li>
</ul>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】常见语法解惑]]></title>
        <id>https://jgduan.github.io/post/kotlin-chang-jian-yu-fa-jie-huo/</id>
        <link href="https://jgduan.github.io/post/kotlin-chang-jian-yu-fa-jie-huo/">
        </link>
        <updated>2021-07-24T14:13:12.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-kotlin中的与比较符号">一、Kotlin中的'=='与'==='比较符号</h1>
<h2 id="1基础知识">1.基础知识</h2>
<ul>
<li><strong>Kotlin中的三等号 '===' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间);</strong></li>
<li><strong>Kotlin中的双等号 '=='  比较的是i盎格对象的值。</strong></li>
</ul>
<h2 id="2示例">2.示例</h2>
<blockquote>
<p>代码源自<a href="https://kotlinlang.org/docs/basic-types.html">Kotlin官方-Basic types</a></p>
</blockquote>
<ul>
<li>
<p><strong>三等号 '===' 的示例</strong></p>
<pre><code class="language-java">  val a: Int = 100
  val boxedA: Int? = a
  val anotherBoxedA: Int? = a

  val b: Int = 10000
  val boxedB: Int? = b
  val anotherBoxedB: Int? = b

  println(boxedA === anotherBoxedA) // true
  println(boxedB === anotherBoxedB) // false
</code></pre>
</li>
<li>
<p><strong>双等号 '=='  的示例</strong></p>
<pre><code class="language-java">  val b: Int = 10000
  println(b == b) // Prints 'true'
  val boxedB: Int? = b
  val anotherBoxedB: Int? = b
  println(boxedB == anotherBoxedB) // Prints 'true'
</code></pre>
</li>
</ul>
<p>在以上两个示例中，第二段代码可能比较好理解一点，它主要是表现比较两个对象的值是否相等；<br>
对于第一段的代码，可能有人不太理解，同样是使用三等号去比较，为什么第一次比较的值是true，第二次比较的值是false呢？其实Kotlin官方就对此做出了如下解释：</p>
<blockquote>
<p>Numbers representation on the JVM<br>
On the JVM platform, numbers are stored as primitive types: int, double, and so on. Exceptions are cases when you create a nullable number reference such as Int? or use generics. In these cases numbers are boxed in Java classes Integer, Double, and so on.<br>
中文译：在 JVM 平台上，数字存储为原始类型：int、double等。创建可为空的数字引用（例如Int?或使用泛型）时的情况除外。在这些情况下，数字在 Java 类Integer、Double 等中被装箱。<br>
All nullable references to a are actually the same object because of the memory optimization that JVM applies to Integer s between -128 and 127. It doesn't apply to the b references, so they are different objects.<br>
中文译：由于VM对-128到127之间的整数应用了内存优化，因此对a的所有可为null的引用实际上都是同一个对象。而它并不适用于b，b的值已经超出了-128~127的范围，因此它们是不同的对象。</p>
</blockquote>
<p>JDK 从 1.5 版本开始，把 -128~127（high的默认值） 的数字缓存起来了，用于提升性能和节省内存，通过<code>-XX:AutoBoxCacheMax=&lt;size&gt;</code>来控制high的取值。所以，当数字在缓存范围内时，通过valueOf()方式拿到的对象引用全部来自于缓存列表，<strong>所以对于相同的值，对象引用相同；若是超过缓存范围，则是重新生成的对象，自然也就不相等了。</strong></p>
<h2 id="3知识汇总">3.知识汇总</h2>
<ul>
<li><strong>Kotlin中的三等号 '===' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间);</strong></li>
<li><strong>Kotlin中的双等号 '=='  比较的是i盎格对象的值；</strong></li>
<li><strong>Kotlin中的非空数字类型对应到JVM平台是基本类型：int,double等等；</strong></li>
<li><strong>Kotlin中的可空数字类型对应到JVM平台是封装类型：Integer，Double等等；</strong></li>
<li><strong>Java中双等号 '==' 比较的是两个引用在内存中指向的是不是同一对象(即同一内存空间)，与Kotlin中的三等号 '===' 等价。</strong></li>
</ul>
<hr>
<h1 id="二-kotlin中-let-运算符的区别">二、Kotlin中 ?. !!. ?.let ?: 运算符的区别</h1>
<h2 id="1基础知识-2">1.基础知识</h2>
<blockquote>
<p>推荐访问<a href="https://kotlinlang.org/docs/null-safety.html">Kotlin官方-空安全</a><br>
<img src="https://jgduan.github.io//post-images/1627312046689.png" alt="" loading="lazy"></p>
</blockquote>
<p>Kotin支持非空类型与可空类型，同时为了消除空引用的危险，在IDE如果我们是同可空类型命名变量后，访问该变量的其它属性或者方法时，IDE会检测并提出警示，让用户通过<code>?./?.let</code>或者<code>!!./?:</code>运算符来进行安全访问。</p>
<ul>
<li>
<p><strong>对于一个不可为空类型：如果直接给不可为空类型赋值一个可能为空的对象就在编译阶段就不能通过;</strong></p>
</li>
<li>
<p><strong>对于一个可空类型：通过<code>？</code>声明，在访问该类型的时候直接访问不能编译通过，需要通过<code>?.</code>或者<code>!!.</code></strong></p>
<ul>
<li><code>?.</code>代表着如果该类型为空的话就返回null不做后续的操作，如果不为空的话才会去访问对应的方法或者属性；<br>
<img src="https://jgduan.github.io//post-images/1627312078667.png" alt="" loading="lazy"></li>
<li><code>!!.</code>代表着如果该类型为空的话就抛出<code>NullPointerException</code>，如果不为空就去访问对应的方法或者属性， 所以只有在很少的特定场景才用这种符号，代表着程序不处理这种异常的case了，会像java代码一样抛出<code>NullPointerException</code>。 而且代码中一定不用出现下面这种代码，会让代码可读性很差而且如果有空指针异常，我们也不能马上发现是哪空了。<br>
<img src="https://jgduan.github.io//post-images/1627312112958.png" alt="" loading="lazy"></li>
</ul>
</li>
<li>
<p><strong>let<code>语句简化对可空对象对访问：</code>let`函数默认当前这个对象作为闭包的it参数，返回值是函数里面最后一行，或者指定return。</strong></p>
</li>
<li>
<p><strong><code>?:</code>简化对空值的处理：<code>?:</code>符号会在符号左边为空的情况才会进行下面的处理，不为空则不会有任何操作。跟<code>?.let</code>正好相反，例如我们可以用两行代码来简化上面从操作：</strong><br>
<img src="https://jgduan.github.io//post-images/1627312147195.png" alt="" loading="lazy"></p>
</li>
</ul>
<h2 id="2示例-2">2.示例</h2>
<ul>
<li>
<p><strong>不可为空类型</strong></p>
<pre><code class="language-java">var a: String = &quot;123&quot; // Regular initialization means non-null by default
a = null // compilation error-编译错误
</code></pre>
</li>
<li>
<p><strong>可为空类型</strong></p>
<pre><code class="language-java">var b: String? = &quot;123&quot; // can be set to null
b = null // ok
println(b) // print null
println(b.length // print null
</code></pre>
<p>这个时候，如果你使用b的属性，那么会提示你使用<code>?.</code>或者<code>!!.</code>，<strong>只有在你需要NPE异常时，才推荐用!!.，否则，请使用?.来进行访问。</strong></p>
</li>
<li>
<p><strong>?.let (安全调用操作符)</strong><br>
通过let语句，在<code>?.let</code>之后，如果为空不会有任何操作，只有在非空的时候才会执行let之后的操作</p>
<pre><code class="language-java">    val person:Person? = getPerson()
    person?.let {
        it.name
        it.age
    }
</code></pre>
</li>
<li>
<p><strong>?: ( Elvis 运算符)</strong><br>
如果<code>?:</code>左侧表达式非空，Elvis 操作符就返回其左侧表达式，否则返回右侧表达式。 请注意，当且仅当左侧为空时，才会对右侧表达式求值。</p>
<pre><code class="language-java">    val b:Int? = 0
    val l = b?.length ?: -1
</code></pre>
</li>
</ul>
<hr>
<h1 id="三-kotlin中is-is-as-as">三、Kotlin中is !is as as?</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1627312290169.png" alt="" loading="lazy"></figure>
<h2 id="1基础知识-3">1.基础知识</h2>
<ul>
<li>
<p><strong>is与!is</strong><br>
<code>kotlin</code>中<code>API</code>提供的<code>is</code>运算符类似于<code>Java</code>中的<code>instanceof</code>关键字的用法。<br>
<code>is</code>运算符可以检查对象是否与特定的类型兼容(兼容：此对象是该类型，或者派生类)，同时也用来检查对象（变量）是否属于某数据类型（如<code>Int、String、Boolean</code>等）。<br>
<code>!is</code>运算符是它的否定形式。</p>
</li>
<li>
<p><strong>as与as?</strong><br>
<code>as</code>运算符用于执行引用类型的显式类型转换。如果要转换的类型与指定的类型兼容，转换就会成功进行；如果要转换的类型与指定的类型不兼容，就会抛出<code>ClassCastException</code>异常；<br>
<code>as?</code>与<code>as</code>运算符的不同是，如果类型不兼容，使用<code>as?</code>运算符就会返回值<code>null</code>。<br>
在<code>Kotlin</code>中，父类是禁止转换为子类型的。</p>
</li>
</ul>
<h2 id="2示例-3">2.示例</h2>
<ul>
<li>
<p><strong>is与!is</strong></p>
<pre><code class="language-java">  val name = &quot;张三&quot;
  println(name is String)// print true

  val name2 = &quot;张三2&quot;
  println(name !is String)// print false
</code></pre>
</li>
<li>
<p><strong>as与as?</strong></p>
<pre><code class="language-java">  open class Person
  open class Children : Person()

  println(Children as Person)// print Person@xxxxx
  println(Children as Student) 或者 println(Person as Children)// ClassCastException
  println(Children as? Student) 或者 println(Person as? Children)// print null
</code></pre>
</li>
</ul>
<hr>
<h1 id="四-kotlin中的until和">四、Kotlin中的until和..</h1>
<ul>
<li>
<p><strong>until</strong><br>
当我们遍历内容可能并不需要包括结束区间时，使用<code>until</code>来进行内容的遍历；</p>
<pre><code class="language-java">for (i in 1..5) {   // 等价于 for (int i = 1 ; i &lt;= 5 ; i++) { print(i) }
  print(i)  // 12345
}
</code></pre>
<blockquote>
<p>半开半闭区间（<code>Semi open closed interval</code>）是高中数学中函数的一种定义域，常简称为“半开区间”或“半闭区间”。半开半闭区间用“（ ]或[ )”表示，这里的until是指<code>[ )</code>区间，即不包含结束区间。</p>
</blockquote>
</li>
<li>
<p><strong>..</strong><br>
当我们遍历内容需要左右都是闭区间时，使用<code>..</code>来进行内容的遍历；</p>
<pre><code class="language-java">for (i in 1 until 5) {  // 等价于 for (int i = 1 ; i &lt; 5 ; i++) { print(i) }
  print(i) // 1234
}
</code></pre>
<blockquote>
<p>闭区间是直线上的连通的闭集，是直线上介于固定两点间的所有点的集合（包括给定的两点），用[a，b]来表示(包含两个端点a和b）（且<code>a&lt;b</code>）。由于它是有界闭集，所以它是紧致的。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>设<code>a</code>和<code>b</code>是两个不同的实数，且<code>a&lt;b</code>，<br>
满足不等式<code>a&lt;X&lt;b</code>的所有实数<code>X</code>所组成的集合叫开区间，用记号<code>（a，b）</code>表示；<br>
满足不等式<code>a≤X≤b</code>的所有实数<code>X</code>所组成的集合叫闭区间，用记号<code>[a,b]</code>表示；<br>
满足不等式<code>a≤X&lt;b</code>或<code>a&lt;X≤b</code>的所有实数<code>X</code>所组成的集合叫半开半闭区间，分别表示为<code>[a,b),(a,b]</code>。</p>
</blockquote>
<hr>
<h1 id="其它">其它</h1>
<ul>
<li><strong>图片内容引用<a href="https://blog.csdn.net/lckj686/article/details/80448471">Kotlin (一) 复合符号( '?.' '?:' '!!' 'as?' '?' )</a>，侵删</strong></li>
<li><strong><a href="https://kotlinlang.org/docs/null-safety.html">Kotlin官方-空安全</a></strong></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【团队管理】KPI与OKR]]></title>
        <id>https://jgduan.github.io/post/tuan-dui-guan-li-kpi-yu-okr/</id>
        <link href="https://jgduan.github.io/post/tuan-dui-guan-li-kpi-yu-okr/">
        </link>
        <updated>2021-07-20T15:19:52.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-kpi-关键绩效指标">一、KPI-关键绩效指标</h1>
<h2 id="1kpi概述">1.KPI概述</h2>
<blockquote>
<p>KPI(<code>Key Performance Indicator</code>)，中文意为关键绩效指标。</p>
</blockquote>
<p><strong>KPI是一种自上而下，首先确定组织目标的管理考核机制</strong>，是通过对组织内部流程的输入端、输出端的关键参数进行设置、取样、计算、分析，衡量流程绩效的一种目标式量化管理指标，是把企业的战略目标分解为可操作 / 执行的工作目标的工具，是企业绩效管理的基础。</p>
<p>KPI可以是部门主管明确部门的主要责任，并以此为基础，明确部门人员的业绩衡量指标。建立明确的切实可行的KPI体系，是做好绩效管理的关键。关键绩效指标是用于衡量工作人员工作绩效表现的量化指标，是绩效计划的重要组成部分。</p>
<p>KPI法符合一个重要的管理原理：<strong>“二八原理”</strong>——在一个企业的价值创造过程中，存在着“80/20”的规律，即20%的骨干人员创造企业80%的价值；而且在每一位员工身上“二八原理”同样适用，即80%的工作任务是由20%的关键行为完成的。因此，必须抓住20%的关键行为，对之进行分析和衡量，这样就能抓住业绩评价的重心。</p>
<blockquote>
<p>二八原理，是由意大利经济学家帕累托提出的一个经济学原理，即一个企业在价值创造过程中，每个部门和每一位员工的80%的工作任务是由20%的关键行为完成的，抓住20%的关键，就抓住了主体。<br>
二八原理为绩效考核指明了方向，即考核工作的主要精力要放在关键的结果和关键的过程上。于是，所谓的绩效考核，一定放在关键绩效指标上，考核工作一定要围绕关键绩效指标展开。</p>
</blockquote>
<h2 id="2kpi绩效考核的目的">2.KPI绩效考核的目的</h2>
<p>以战略为中心，指标体系的设计与运用都为组织战略目标的达成服务。<br>
以控制为中心，指标体系的设计与运用来源于控制的意图，也是为更有效的控制个人的行为服务。</p>
<hr>
<h1 id="二-okr-目标与关键成果法">二、OKR-目标与关键成果法</h1>
<h2 id="1okr概述">1.OKR概述</h2>
<p>OKR（<code>Objectives and Key Results</code>）即目标与关键成果法，是一套明确和跟踪目标及其完成情况的管理工具和方法，由英特尔公司创始人安迪·葛洛夫（AndyGrove）发明，并由约翰·道尔（JohnDoerr）引入到谷歌使用，1999年OKR在谷歌发扬光大，在Facebook、Linked in等企业广泛使用。</p>
<p><strong>OKR的思路是一定程度上的自下而上的、由个人提出，然后由组织确定的管理考核方式。</strong></p>
<p>2014年，OKR传入中国。2015年后，百度、华为、字节跳动等企业都逐渐使用和推广OKR。</p>
<p><strong>OKR的主要目标是明确公司和团队的“目标”以及明确每个目标达成的可衡量的“关键结果”。</strong></p>
<p>一本关于OKR的书将OKR定义为“一个重要的思考框架与不断发展的学科，旨在确保员工共同工作，并集中精力做出可衡量的贡献。”</p>
<p><strong>OKR可以在整个组织中共享，这样团队就可以在整个组织中明确目标，帮助协调和集中精力。</strong></p>
<hr>
<h1 id="kpi与okr">KPI与OKR</h1>
<h2 id="1两者之间的区别">1.两者之间的区别</h2>
<h2 id="2kpi的缺陷">2.KPI的缺陷</h2>
<ol>
<li><strong>没有人对最终结果负责，每个人只对自己的过程负责。</strong></li>
<li><strong>人的主观能动性被压抑。</strong></li>
<li><strong>结果高度依赖机器和管理者的指令。</strong></li>
</ol>
<p>有些事情值得去做，但在做出来一部分之前无法测量因此无法制订目标。为了完成可测量的目标，有可能实际执行手段与该目标要达到的愿景正好相反。</p>
<p>举例来说，我们希望用户更喜欢使用我们的产品，因为喜欢无法测量，所以把PV写进了 KPI 里面。但在实际执行过程中，我们可以把用户原本在一个页面上就能完成的事情分到几个页面上来完成，结果 PV 达到了 KPI 指定的目标，但用户可能更讨厌我们的产品了。</p>
<h2 id="3okr解决了什么">3.OKR解决了什么</h2>
<p>OKR 解决了 KPI 的这些缺陷。首先它和绩效考核分离，把绩效考核交给 peer review来做。然后它强调 Key Result 必须服从 Objective，所以如果你在 Objective上写了要让用户喜欢我们的产品，但你实际执行 Key Result 的手段违反了这一点的话，谁都能看得出来。既然 Key Result 只是用来服务于 Objective 的，那就没必要像 KPI 那样一早制订好然后强制执行了。你可以在做的过程中随意更改 Key Result，只要它们还是服务于原本的 Objective 就行。</p>
<hr>
<h1 id="三-拓展阅读">三、拓展阅读</h1>
<ul>
<li><a href="https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E7%BB%A9%E6%95%88%E6%8C%87%E6%A0%87%E6%B3%95/4723067?fr=aladdin"><strong>关键绩效指标法</strong></a></li>
<li><a href="https://baike.baidu.com/item/OKR"><strong>OKR-目标与关键成果法</strong></a></li>
<li><a href="https://www.zhihu.com/question/22471467/answer/220121306"><strong>谷歌内部考核制度 OKR 是怎样的？ - 李会军的回答 - 知乎</strong></a></li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android应用优化】解决应用启动时黑屏/白屏问题]]></title>
        <id>https://jgduan.github.io/post/android-ying-yong-you-hua-jie-jue-ying-yong-qi-dong-shi-hei-ping-bai-ping-wen-ti/</id>
        <link href="https://jgduan.github.io/post/android-ying-yong-you-hua-jie-jue-ying-yong-qi-dong-shi-hei-ping-bai-ping-wen-ti/">
        </link>
        <updated>2021-07-19T16:11:54.000Z</updated>
        <content type="html"><![CDATA[<h1 id="android-app的载入页">Android App的载入页</h1>
<h2 id="什么是载入页">什么是载入页？</h2>
<p>当前主流应用流行在启动时打开一个类似欢迎页的过度页面，我们一般称之为<code>SplashActivity</code>，中文一般用载入页来表示。</p>
<blockquote>
<p>一般来说，载入页都是以全屏的方式展示给用户的。</p>
</blockquote>
<h2 id="载入页能做些什么">载入页能做些什么？</h2>
<ol>
<li><strong>加深用户对产品的印象</strong>：通过在载入页进行应用 / 企业信息的展示来加深用户对产品的印象；</li>
<li><strong>启动过渡</strong>：避免主页初始化过慢给用户不友好的交互体验；</li>
<li><strong>开屏推荐信息 / 广告展示</strong>：简短的信息 / 广告展示，灵活利用<code>App</code>内容初始化的时间进行相关转化；</li>
<li><strong>临时预加载</strong>：提前为主页做一些不耗时的预加载工作。</li>
</ol>
<h2 id="载入页一般存在多久">载入页一般存在多久？</h2>
<p>通常情况下，在用户点击桌面应用的icon后，会进入到<code>SplashActivity</code>载入页，然后一般是在<strong>3s内</strong>进入到应用的主页面（考虑到交互的友好性，载入页不应该存在太久，也不应该存在太多的耗时操作，否则会给用户<strong>很卡</strong>的感觉，它的存在，更多的是起到一些基础信息的展示、初始化及过度作用）。</p>
<hr>
<h1 id="载入页的黑屏-白屏问题">载入页的黑屏 / 白屏问题</h1>
<p>在我们没有对应用进行特殊处理时，我们会发现在一些机型上（尤其是配置相对较差的机器），在桌面点击应用图标首次启动应用时，载入页出现前会出现黑屏 / 白屏的问题。</p>
<h2 id="为什么会出现黑屏-白屏呢">为什么会出现黑屏 / 白屏呢？</h2>
<p>因为在用户点击应用图标后，系统会进行一系列的<code>Framework</code>操作，其中就包括<code>Application</code>的初始化，如果我们在<code>Application</code>初始化的过程中做了过多的操作，就会导致应用明明已经启动了，却迟迟没有界面展示出来，这个时候，就会出现应用黑屏 / 白屏的情况。</p>
<blockquote>
<p><code>Application</code>初始化时注意：</p>
<ol>
<li>尽量不将一些业务逻辑放于<code>Application</code>中；</li>
<li>不以静态变量的方式在<code>Application</code>中保存应用数据；</li>
<li>不要把文件、数据库的操作放在<code>Application</code>中；</li>
<li>不要再<code>Application</code>封装与初始化无关的其它事务。</li>
</ol>
</blockquote>
<h2 id="什么时候出现黑屏什么时候出现白屏">什么时候出现黑屏？什么时候出现白屏？</h2>
<p>App黑屏/白屏，实际上跟设置的主题（<code>Theme</code>）有关，设置<code>Light</code>系列的，会显示白屏，设置<code>Dark</code>系列的，会显示黑屏。</p>
<hr>
<h1 id="解决方法">解决方法</h1>
<h2 id="设置透明的splashactivity">设置透明的SplashActivity</h2>
<p>在应用<code>styles</code>文件内，为载入页（SplashActivity）新增自定义样式，设置Activity的主题样式背景为透明色、全屏、无标题栏、无ActionBar，具体代码如下：</p>
<pre><code class="language-java">&lt;style name=&quot;AppTheme.Splash&quot; parent=&quot;AppTheme.xxx&quot;&gt;
    &lt;item name=&quot;android:windowFullscreen&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;android:windowBackground&quot;&gt;@android:color/transparent&lt;/item&gt;
    &lt;item name=&quot;android:colorBackgroundCacheHint&quot;&gt;@null&lt;/item&gt;
    &lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;
    &lt;item name=&quot;windowActionBar&quot;&gt;false&lt;/item&gt;
    &lt;item name=&quot;windowNoTitle&quot;&gt;true&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在<code>AndroidManifest.xml</code>中为SplashActivity设置<code>Theme</code>样式：</p>
<pre><code class="language-java">&lt;activity
    android:name=&quot;.SplashActivity&quot;
    android:theme=&quot;@style/AppTheme.Splash&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】Android Studio 4.1+版本在Module-BuildConfig中找不到VERSION_CODE、VERSION_NAME字段]]></title>
        <id>https://jgduan.github.io/post/android-android-studio-41ban-ben-zai-module-buildconfig-zhong-zhao-bu-dao-version_codeversion_name-zi-duan/</id>
        <link href="https://jgduan.github.io/post/android-android-studio-41ban-ben-zai-module-buildconfig-zhong-zhao-bu-dao-version_codeversion_name-zi-duan/">
        </link>
        <updated>2021-07-18T16:38:05.000Z</updated>
        <content type="html"><![CDATA[<h1 id="前言">前言</h1>
<p>最近升级<code>Android Studio</code>到4.2版本后，在项目的其它<code>Module</code>中添加了检查更新功能，本想通过统一配置<code>VersionCode、VersionName</code>然后在<code>Module</code>中直接获取本地的<code>VersionCode</code>来与服务器对比做更新判断的，结果发现<code>BuildConfig</code>文件中，没有这两个字段。最后通过<code>StackOverflow</code>查询后发现<a href="https://issuetracker.google.com/issues/154275579?pli=1#comment3"><strong>Google Issue Tracker</strong></a>文中对问题的原因进行了解释：<code>Google</code>认为<code>VersionCode、VersionName</code>字段在其它<code>Module</code>中不代表任何意义，还容易与<code>app</code>模块中的字段混淆概念，所以认定它不应该再出现在其它模块中。</p>
<p><img src="https://jgduan.github.io//post-images/1626627606725.png" alt="" loading="lazy"><br>
<img src="https://jgduan.github.io//post-images/1626627613034.png" alt="" loading="lazy"><br>
<img src="https://jgduan.github.io//post-images/1626627621216.png" alt="" loading="lazy"></p>
<hr>
<h1 id="解决方法">解决方法</h1>
<ul>
<li><strong>使用App模块中的字段进行判断</strong></li>
<li><strong>在Module中添加VersionCode的配置</strong><br>
我们可以在<code>Module-build.gradle</code>文件中添加对应<code>VersionCode、VersionName</code>的配置，通过该方式，也可以达到目的，不过<em>个人不推荐这样做</em>，按照官方的做法即可。</li>
</ul>
<pre><code class="language-java">debug {
    buildConfigField &quot;String&quot;, &quot;VERSION_NAME&quot;, &quot;1.0.1&quot;
    buildConfigField &quot;int&quot;, &quot;VERSION_CODE&quot;, &quot;1&quot;
}
release {
    buildConfigField &quot;String&quot;, &quot;VERSION_NAME&quot;, &quot;1.0.1&quot;
    buildConfigField &quot;int&quot;, &quot;VERSION_CODE&quot;, &quot;1&quot;
}
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】自定义绘制一个圆环形进度条]]></title>
        <id>https://jgduan.github.io/post/android-zi-ding-yi-hui-zhi-yi-ge-yuan-huan-xing-jin-du-tiao/</id>
        <link href="https://jgduan.github.io/post/android-zi-ding-yi-hui-zhi-yi-ge-yuan-huan-xing-jin-du-tiao/">
        </link>
        <updated>2021-07-07T14:46:45.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-预期效果">一、预期效果</h1>
<figure data-type="image" tabindex="1"><img src="https://jgduan.github.io//post-images/1625669223339.png" alt="" loading="lazy"></figure>
<hr>
<h1 id="二-绘制分析">二、绘制分析</h1>
<p>根据预期图片可以看出：</p>
<ul>
<li>
<p><strong>需要绘制一个带有文本的圆环形进度条</strong></p>
<ul>
<li>绘制圆环（进度条背景色）</li>
<li>绘制圆环上的进度（进度条前景色）</li>
</ul>
</li>
<li>
<p><strong>它的最大值、进度可自由设置</strong></p>
<ul>
<li>自定义属性：maxValue</li>
<li>自定义属性：progress</li>
</ul>
</li>
<li>
<p><strong>进度线条的形状为圆头</strong></p>
</li>
<li>
<p><strong>进度条中心位置显示标题及任务描述</strong></p>
<ul>
<li>标题文本绘制-drawText</li>
<li>任务描述文本绘制-drawText</li>
<li>文字居中显示</li>
</ul>
</li>
</ul>
<hr>
<h1 id="三-开始绘制">三、开始绘制</h1>
<ul>
<li>
<p><strong>新建一个<code>CircleProgressBar</code>类，继承<code>View</code></strong></p>
</li>
<li>
<p><strong>相关自定义属性的设置</strong></p>
</li>
<li>
<p><strong>控件获取宽高、中心点、初始化画笔</strong></p>
</li>
<li>
<p><strong>绘制圆环及进度</strong></p>
<ul>
<li>绘制圆环（背景色）</li>
<li>绘制进度（前景色）</li>
</ul>
</li>
<li>
<p><strong>绘制显示的文本</strong></p>
<ul>
<li>绘制标题文本</li>
<li>绘制描述文本</li>
</ul>
</li>
<li>
<p><strong>进度条展示动画效果设置</strong></p>
</li>
</ul>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】Android Paint 画笔的一些偏知识]]></title>
        <id>https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/</id>
        <link href="https://jgduan.github.io/post/zhuan-android-paint-hua-bi-de-yi-xie-pian-zhi-shi/">
        </link>
        <updated>2021-07-06T15:02:26.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转载于 抛物线http://hencoder.com/ui-1-2/</p>
</blockquote>
<hr>
<h1 id="setstrokecappaintcap-cap-设置线头的形状">setStrokeCap(Paint.Cap cap) 设置线头的形状</h1>
<p>设置线头的形状。线头形状有三种：<code>BUTT</code> 平头、<code>ROUND</code> 圆头、<code>SQUARE</code> 方头。默认为 <code>BUTT</code>。</p>
<blockquote>
<p>放出「平头」「圆头」「方头」这种翻译我始终有点纠结：既觉得自己翻译得简洁清晰尽显机智，同时又担心用词会不会有点太过通俗，让人觉得我不够高贵冷艳？</p>
</blockquote>
<p>当线条的宽度是 1 像素时，这三种线头的表现是完全一致的，全是 1 个像素的点；而当线条变粗的时候，它们就会表现出不同的样子：<br>
<img src="https://jgduan.github.io//post-images/1625584089491.jpg" alt="" loading="lazy"></p>
<p>虚线是额外加的，虚线左边是线的实际长度，虚线右边是线头。有了虚线作为辅助，可以清楚地看出 <code>BUTT</code> 和 <code>SQUARE</code> 的区别。</p>
<hr>
<h1 id="setstrokejoinpaintjoin-join">setStrokeJoin(Paint.Join join)</h1>
<p>设置拐角的形状。有三个值可以选择：<code>MITER</code> 尖角、 <code>BEVEL</code> 平角和 <code>ROUND</code> 圆角。默认为 <code>MITER</code>。<br>
<img src="https://jgduan.github.io//post-images/1625584131677.jpg" alt="" loading="lazy"></p>
<p>辅助理解：<br>
<code>MITER</code> 在现实中其实就是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584155362.jpg" alt="" loading="lazy"></p>
<p>而 <code>BEVEL</code> 是这玩意：<br>
<img src="https://jgduan.github.io//post-images/1625584171460.jpg" alt="" loading="lazy"></p>
<hr>
<h1 id="setstrokemiterfloat-miter">setStrokeMiter(float miter)</h1>
<p>这个方法是对于 <code>setStrokeJoin()</code> 的一个补充，它用于设置 <code>MITER</code> 型拐角的延长线的最大值。所谓「延长线的最大值」，是这么一回事：<br>
当线条拐角为 <code>MITER</code> 时，拐角处的外缘需要使用延长线来补偿：<br>
<img src="https://jgduan.github.io//post-images/1625584210033.jpg" alt="" loading="lazy"></p>
<p>而这种补偿方案会有一个问题：如果拐角的角度太小，就有可能由于出现连接点过长的情况。比如这样：<br>
<img src="https://jgduan.github.io//post-images/1625584221599.jpg" alt="" loading="lazy"></p>
<p>所以为了避免意料之外的过长的尖角出现， <code>MITER</code> 型连接点有一个额外的规则：当尖角过长时，自动改用 <code>BEVEL</code> 的方式来渲染连接点。例如上图的这个尖角，在默认情况下是不会出现的，而是会由于延长线过长而被转为 <code>BEVEL</code> 型连接点：<br>
<img src="https://jgduan.github.io//post-images/1625584236255.jpg" alt="" loading="lazy"></p>
<p>至于多尖的角属于过于尖，尖到需要转为使用 <code>BEVEL</code> 来绘制，则是由一个属性控制的，而这个属性就是 <code>setStrokeMiter(miter)</code>方法中的 <code>miter</code> 参数。<code>miter</code> 参数是对于转角长度的限制，具体来讲，是指尖角的外缘端点和内部拐角的距离与线条宽度的比。也就是下面这两个长度的比：<br>
<img src="https://jgduan.github.io//post-images/1625584259127.jpg" alt="" loading="lazy"></p>
<p>用几何知识很容易得出这个比值的计算公式：如果拐角的大小为 θ ，那么这个比值就等于 1 / sin ( θ / 2 ) 。<br>
这个 <code>miter limit</code> 的默认值是 4，对应的是一个大约 29° 的锐角：<br>
<img src="https://jgduan.github.io//post-images/1625584364544.jpg" alt="" loading="lazy"></p>
<blockquote>
<p>默认情况下，大于这个角的尖角会被保留，而小于这个夹角的就会被「削成平头」</p>
</blockquote>
<p>所以，这个方法虽然名叫 <code>setStrokeMiter(miter)</code> ，但它其实设置的是「 线条在 <code>Join</code> 类型为 <code>MITER</code> 时对于 <code>MITER</code> 的长度限制」。它的这个名字虽然短，但却存在一定的迷惑性，如果叫 <code>setStrokeJoinMiterLimit(limit)</code> 就更准确了。 Google 的工程师没有这么给它命名，大概也是不想伤害大家的手指吧，毕竟程序员何苦为难程序员。</p>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Android】各大版本新特性及行为变更]]></title>
        <id>https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/</id>
        <link href="https://jgduan.github.io/post/android-ge-da-ban-ben-xin-te-xing-ji-xing-wei-bian-geng/">
        </link>
        <updated>2021-07-05T15:03:37.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>
<p><strong>Android 12.0开发者预览版</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/12/features?hl=zh_cn">概览 API 30</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-all">Android 12.0影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/behavior-changes-12?hl=zh_cn">行为变更：以 Android 12 为目标平台的应用</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/foreground-services?hl=zh_cn">前台服务启动限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/non-sdk-12?hl=zh_cn">Android 12 中有关限制非 SDK 接口的更新</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features">Android 12 功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/work?hl=zh_cn">Android 12 中的企业功能新变化</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/migration?hl=zh_cn">将应用迁移到 Android 12</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/unified-content-api?hl=zh_cn">接收内容的统一 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/12/features/compatible-media-transcoding?hl=zh_cn">兼容的媒体转码</a></li>
</ul>
</li>
<li>
<p><strong>Android 11.0</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/11?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-all">影响所有应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/behavior-changes-11">影响以 Android 11 为目标平台的应用的 Android 11 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/privacy">Android 11 隐私权变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/11/features">Android 11 功能和 API 30</a></li>
</ul>
</li>
<li>
<p><strong>Android 10.0(Q)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/10?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/migration?hl=zh_cn">将应用迁移至 Android 10</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/privacy?hl=zh_cn">隐私功能</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/behavior-changes-all?hl=zh_cn">行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/10/highlights?hl=zh_cn">新功能和 API 29</a></li>
<li><a href="https://blog.csdn.net/u011216417/article/details/89189741">Android10.0(Q)新特性和行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 9.0(P)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/pie?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0?hl=zh_cn">功能和API 28</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-all?hl=zh_cn">针对所有应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-changes-28?hl=zh_cn">针对API 28+应用的行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/android-9.0-migration?hl=zh_cn">迁移至Android 9.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/pie/power?hl=zh_cn">电源管理</a></li>
</ul>
</li>
<li>
<p><strong>Android 8.0(O)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/oreo?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0?hl=zh_cn">Android 8.0 功能和 API 26</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-changes?hl=zh_cn">Android 8.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-migration?hl=zh_cn">迁移到Android 8.0</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.0-samples?hl=zh_cn">Android 8.0示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background?hl=zh_cn">后台执行限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/background-location-limits?hl=zh_cn">后台位置信息限制</a></li>
<li><a href="https://developer.android.google.cn/about/versions/oreo/android-8.1?hl=zh_cn">Android 8.1 功能和 API 27</a></li>
</ul>
</li>
<li>
<p><strong>Android 7.0(N)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/nougat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0?hl=zh_cn">Android 7.0 开发者版本 API 24</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-changes?hl=zh_cn">Android 7.0 行为变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.0-samples?hl=zh_cn">Android 7.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1?hl=zh_cn">Android 7.1 开发者版本 API 25</a></li>
<li><a href="https://developer.android.google.cn/about/versions/nougat/android-7.1-samples?hl=zh_cn">Android 7.1 示例</a></li>
</ul>
</li>
<li>
<p><strong>Android 6.0(M)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0?hl=zh_cn">Android 6.0 API 23</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes?hl=zh_cn">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-samples?hl=zh_cn">Android 6.0 示例</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-testing?hl=zh_cn">Android 6.0 测试指南</a></li>
</ul>
</li>
<li>
<p><strong>Android 5.0(L)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/lollipop?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.1?hl=zh_cn">Android 5.1 API 22</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0?hl=zh_cn">Android 5.0 API 21</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-5.0-changes?hl=zh_cn">Android 5.0 行为变更</a></li>
</ul>
</li>
<li>
<p><strong>Android 4.4(KitKat)</strong></p>
<ul>
<li><a href="https://developer.android.google.cn/about/versions/kitkat?hl=zh_cn">概览</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4?hl=zh_cn">Android 4.4 API 19</a></li>
</ul>
</li>
</ul>
<hr>
<blockquote>
<p><a href="https://developer.android.google.cn/about/versions?hl=zh_cn">所有Android版本</a></p>
</blockquote>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【Kotlin】使用PermissionsDispatcher进行动态权限适配]]></title>
        <id>https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/</id>
        <link href="https://jgduan.github.io/post/kotlin-shi-yong-permissionsdispatcher-jin-xing-dong-tai-quan-xian-gua-pei/">
        </link>
        <updated>2021-07-05T12:55:35.000Z</updated>
        <content type="html"><![CDATA[<h1 id="一-permissionsdispatcher简介">一、PermissionsDispatcher简介</h1>
<p>PermissionsDispatcher provides a simple annotation-based API to handle runtime permissions.<br>
<code>PermissionsDispatcher</code>提供了一个简单的基于注解的 API 来处理运行时权限。</p>
<p>This library lifts the burden that comes with writing a bunch of check statements whether a permission has been granted or not from you, in order to keep your code clean and safe.<br>
该库减轻了编写一堆检查语句所带来的负担，无论是否已授予您许可，以保持您的代码清洁和安全。</p>
<ul>
<li>
<p><strong>Fully Kotlin/Java support - 完全支持Kotlin/Java</strong></p>
</li>
<li>
<p><strong><a href="https://github.com/hotchemi/PermissionsDispatcher/blob/master/doc/special_permissions.md">Special permissions support - 特殊权限支持</a></strong></p>
</li>
<li>
<p><strong>100% reflection-free - 100%无反射</strong></p>
</li>
</ul>
<p>本文基于<code>PermissionsDispatcher 4.8.0及 permissionsdispatcher-ktx 1.0.5</code>版本，我们将介绍Kotlin的ktx使用方式，如过需要使用Kotlin kapt或Java使用方式的，请移步<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher">Github-PermissionsDispatcher</a></p>
<blockquote>
<p><code>permissionsdispatcher-ktx</code><br>
<code>permissionsdispatcher-ktx</code>旨在让开发人员在不使用注释处理（kapt）的情况下以声明式方式处理运行时权限。</p>
</blockquote>
<hr>
<h1 id="二-使用示例">二、使用示例</h1>
<h2 id="1准备工作添加一个示例权限">1.准备工作——添加一个示例权限</h2>
<p>我们在项目的<code>AndroidManifest.xml</code>中添加如下权限：</p>
<pre><code class="language-java">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;
</code></pre>
<h2 id="2引入库">2.引入库</h2>
<p>在使用该库API的Module的<code>build.gradle</code>文件中，添加如下代码引入<code>PermissionsDispatcher</code>库：</p>
<pre><code class="language-java">dependencies {
  implementation &quot;com.github.permissions-dispatcher:permissionsdispatcher:4.8.0&quot;
  implementation &quot;com.github.permissions-dispatcher:ktx:1.0.5&quot;
}
</code></pre>
<h2 id="3在需要进行权限请求的activityfragment中定义请求者constructpermissionsrequest">3.在需要进行权限请求的Activity/Fragment中，定义请求者constructPermissionsRequest</h2>
<p>该库提供了<code>constructPermissionsRequest</code>您可以使用给定的几个回调函数构造请求者对象的方法，以便在适当的情况下调用。</p>
<pre><code class="language-java">/* * 
* @param 权限 [requiresPermission] 需要的权限。
* @param onShowRationale 该方法解释了为什么需要权限。
* @param onPermissionDenied 用户未授予权限时调用的方法。
* @param onNeverAskAgain 如果用户不使用
*“不再询问”选项
拒绝权限，则调用该方法。* @param requiresPermission 该操作需要 [permissions]。
*/ fun FragmentActivity /*(or Fragment )*/.constructPermissionsRequest(
     vararg permissions : String ,
     onShowRationale : ShowRationaleFunc ? 
    = null,
     onPermissionDenied :  Func ? = null,
     onNeverAskAgain :  Func ? = null,
     requiresPermission :  Func ): PermissionsRequester
</code></pre>
<p>在这里你只需定义<code>showCamera</code>，使用该库，您无需手动覆盖<code>onRequestPermissionsResult.</code></p>
<blockquote>
<p>注意：确保每次创建活动时都构造一个请求者以适当地捕获回调。</p>
</blockquote>
<p>完整使用示例</p>
<pre><code class="language-java">class MainActivity: AppCompatActivity {
    // constructPermissionsRequest must be invoked every time an activity is created 
    private val showCamera = constructPermissionsRequest(Manifest.permission.CAMERA,
        onShowRationale = ::onCameraShowRationale,
        onPermissionDenied = ::onCameraDenied,
        onNeverAskAgain = ::onCameraNeverAskAgain) {
		    // do something here
        }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        findViewById(R.id.button_camera).setOnClickListener {
            // 这里发起权限请求
            showCamera.launch()
        }
    }

    // 用户未授予权限时调用
    private fun onCameraDenied() {
        Toast.makeText(requireContext(), R.string.permission_camera_denied, Toast.LENGTH_SHORT).show()
    }

    // 解释为什么需要权限
    private fun onCameraShowRationale(request: PermissionRequest) {
        // 继续请求操作
        request.proceed()
    }

    // 用户勾选“不再询问”选项时调用
    private fun onCameraNeverAskAgain() {
        Toast.makeText(requireContext(), R.string.permission_camera_never_ask_again, Toast.LENGTH_SHORT).show()
    }
}
</code></pre>
<hr>
<h1 id="三-拓展用法">三、拓展用法</h1>
<h2 id="1location-permissions位置权限">1.Location Permissions——位置权限</h2>
<blockquote>
<p>Since the location permissions have been one of the most sensitive permission group to deal with, we provide a dedicated method <code>constructLocationPermissionRequest</code>. With the method you don't have to think of which API version you can ask <code>ACCESS_BACKGROUND_LOCATION</code>(see the issue for more detail).<br>
由于位置权限一直是要处理的最敏感的权限组之一，因此我们提供了专门的方法<code>constructLocationPermissionRequest</code>。使用该方法，您不必考虑可以询问<a href="https://developer.android.com/about/versions/10/privacy/changes#app-access-device-location">ACCESS_BACKGROUND_LOCATION</a>的API 版本（有关更多详细信息，请参阅<a href="https://github.com/permissions-dispatcher/PermissionsDispatcher/issues/646">问题</a>）。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructLocationPermissionRequest(
    vararg permissions: LocationPermission,
    onShowRationale: ShowRationaleFun? = null,
    onPermissionDenied: Fun? = null,
    onNeverAskAgain: Fun? = null,
    requiresPermission: Fun
): PermissionsRequester

</code></pre>
<p><strong>注：设备位置权限的访问控制</strong><br>
用户可以更好地控制应用何时可以访问设备位置。当在Android Q上运行的应用程序请求位置访问时，会通过对话框的形式给用户进行授权提示。此对话框允许用户授予对两个不同范围的位置访问权限：在使用中（仅限前台）或始终（前台和后台）。<br>
新增权限 <code>ACCESS_BACKGROUND_LOCATION</code><br>
如果你的应用针对 <code>Android Q</code> 并且需要在后台运行时访问用户的位置，则必须在应用的清单文件中声明新权限</p>
<pre><code class="language-java">&lt;manifest&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_COARSE_LOCATION&quot; /&gt;
 &lt;uses-permission android:name=&quot;android.permission.ACCESS_BACKGROUND_LOCATION&quot; /&gt;
&lt;/manifest&gt;
</code></pre>
<h2 id="2special-permissions特殊权限">2.Special Permissions——特殊权限</h2>
<blockquote>
<p>The library also provides <code>constructWriteSettingsPermissionRequest</code> and <code>constructSystemAlertWindowPermissionRequest</code> to support <code>WRITE_SETTINGS</code> and <code>SYSTEM_ALERT_WINDOW</code> that requires exceptional handling.<br>
该库还提供<code>constructWriteSettingsPermissionRequest</code>和 <code>constructSystemAlertWindowPermissionRequest</code>支持<code>WRITE_SETTINGS</code>，<code>SYSTEM_ALERT_WINDOW</code>这需要特殊处理。</p>
</blockquote>
<pre><code class="language-java">/**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructWriteSettingsPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester

 /**
 * @param onShowRationale the method explains why the permissions are required.
 * @param onPermissionDenied the method invoked if the user doesn't grant the permissions.
 * @param requiresPermission the action requires [permissions].
 */
fun FragmentActivity/*(or Fragment)*/.constructSystemAlertWindowPermissionRequest(
    onShowRationale: ShowRationaleFunc? = null,
    onPermissionDenied: Func? = null,
    requiresPermission: Func): PermissionsRequester
</code></pre>
<hr>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[【转】打造 Material 颜色主题 | 实现篇]]></title>
        <id>https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/</id>
        <link href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-shi-xian-pian/">
        </link>
        <updated>2021-07-04T15:57:00.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>本文转自<a href="https://blog.csdn.net/jILRvRTrc/article/details/109567406">CSDN-谷歌开发者 打造 Material 颜色主题 | 实现篇</a><br>
<em>作者 / Nick Rout, Material Developer Advocate</em></p>
</blockquote>
<p>使用 Material 主题自定义 Material 组件，目的是让组件观感与品牌保持一致。Material 主题包括颜色、字体和形状参数，您可以对这些参数进行调整来获得近乎无限的组件变体，同时保持其核心结构和易用性。</p>
<ul>
<li>
<p>Material 主题<br>
https://material.io/design/material-theming/overview.html#material-theming</p>
</li>
<li>
<p>Material 组件<br>
https://material.io/components</p>
</li>
<li>
<p>Material 颜色<br>
https://material.io/design/color/</p>
</li>
<li>
<p>Material 字体<br>
https://material.io/design/typography/</p>
</li>
<li>
<p>Material 形状<br>
https://material.io/design/shape/<br>
<img src="https://jgduan.github.io//post-images/1625414383767.gif" alt="" loading="lazy"></p>
</li>
</ul>
<p>在 Android 上可使用 1.1.0 版本及以上的 Material 组件 (Material Design Components, MDC) 库来实现 Material 主题。如果您希望从 Design Support Library 或 MDC 1.0.0 迁移到新版本的 MDC，请参阅我们的迁移指南。</p>
<ul>
<li>
<p>Material 组件<br>
https://github.com/material-components/material-components-android</p>
</li>
<li>
<p>迁移指南<br>
https://medium.com/androiddevelopers/migrating-to-material-components-for-android-ec6757795351</p>
</li>
</ul>
<p>继上次我们发布<a href="https://jgduan.github.io/post/zhuan-da-zao-material-yan-se-zhu-ti-or-she-ji-pian/">《打造 Material 颜色主题 | 设计篇》</a>之后，本文为大家介绍如何实现颜色主题。</p>
<hr>
<h2 id="颜色属性">颜色属性</h2>
<p>Material Design 提供可供填充的 12 个颜色 &quot;槽 (slots)&quot;，这些色值构成应用的整体调色板。每个 &quot;槽&quot; 都有一个设计术语 (如 Primary)，该术语则对应一个可在应用主题中覆盖的颜色属性 (如 Primary 这个术语对应 colorPrimary 这个颜色属性)。这些是您的浅色和深色主题默认的基准色值。</p>
<p><img src="https://jgduan.github.io//post-images/1625414532132.png" alt="" loading="lazy"><br>
△ 浅色主题的基准 MDC 颜色属性</p>
<p><img src="https://jgduan.github.io//post-images/1625414555733.png" alt="" loading="lazy"><br>
△ 深色主题的基准 MDC 颜色属性</p>
<p>Material 组件使用这些颜色属性为各个 widget 着色。<br>
<img src="https://jgduan.github.io//post-images/1625414580741.png" alt="" loading="lazy"><br>
△ 一个按钮中用到的颜色属性</p>
<p>例如，将颜色属性用于布局和 widget 样式中，写法如下所示:<br>
<code>app:backgroundTint=”?attr/colorSecondary”</code><br>
您可能会认得下表中的一些颜色属性，如 colorPrimary。这些因为一些颜色属性继承自 AppCompat 和平台本身，而其余属性则来由 MDC。每个颜色属性的完整来源见下表。<br>
<img src="https://jgduan.github.io//post-images/1625414617487.png" alt="" loading="lazy"></p>
<hr>
<h2 id="挑选颜色">挑选颜色</h2>
<p>主题里每个颜色槽应该使用的具体颜色值由设计师负责给出，或是取自您的产品品牌。但是，了解每个颜色的作用、颜色之间的关系以及如何满足无障碍功能要求仍非常有用:</p>
<ul>
<li>
<p>colorPrimary 和 colorSecondary 是用于呈现品牌的颜色</p>
</li>
<li>
<p>colorPrimaryVariant 和 colorSecondaryVariant 是品牌颜色较浅或较深的阴影色</p>
</li>
<li>
<p>colorSurface 用于表单或表面 (如卡片颜色和应用的底部弹出菜单颜色)</p>
</li>
<li>
<p>android:colorBackground 是应用的窗口背景颜色</p>
</li>
<li>
<p>顾名思义，colorError 用于错误和警告</p>
</li>
<li>
<p>各种各样的 &quot;On&quot; 颜色 (colorOnPrimary、colorOnSecondary、colorOnSurface 等) 用于<br>
为显示在其他颜色上方的前景内容 (如文本和图标) 进行着色。这些颜色需要满足无障碍功能要求并与所在表面的颜色有足够的对比度。</p>
</li>
</ul>
<hr>
<h2 id="颜色工具">颜色工具</h2>
<p>Material Design 为大家提供了丰富的工具，用于预览颜色、确定合适的变体颜色以及 &quot;On&quot; 颜色:</p>
<ul>
<li>
<p>Material 颜色工具: 获得主色和辅色的浅色/深色变体以及合适的 &quot;On&quot; 颜色。并能在示例界面中预览这些颜色的效果。<br>
https://material.io/resources/color/</p>
</li>
<li>
<p>Material 调色板生成器: 生成完整的色调调色板 (即包含 Material 色值编号 50 - 900)。另外您还能获得互补色、近似色和三等分配色的建议。<br>
https://material.io/design/color/the-color-system.html#tools-for-picking-colors</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625414775321.png" alt="" loading="lazy"><br>
△ Material 颜色工具 (左) 和 Material 调色板生成器 (右)</p>
<hr>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>除非您的品牌恰巧使用和基准 Material 主题色完全相同的紫色和蓝绿色，否则请您务必覆盖 colorPrimary、colorSecondary 及其变体色。</li>
<li>您无需覆盖所有颜色。一些颜色 (如 colorSurface) 默认使用的就是中性颜色，因此使用默认值不会有什么问题。</li>
<li>如果您的品牌没有定义任何种类的辅色或强调色，那么可以将一种颜色同时用于 colorPrimary 和 colorSecondary。变体色也可以和主色相同 (即 colorPrimary 和 colorPrimaryVariant 可以相同)。</li>
<li>一个颜色和其变体颜色以及 &quot;On&quot; 颜色尽管是三个单独的颜色属性 (如 colorPrimary、colorPrimaryVariant 和 colorOnPrimary)，但它们之间依然存在紧密的联系。因此如果您覆盖了其中一个，请检查其他颜色属性，以查看是否可行且满足无障碍功能要求。</li>
</ul>
<hr>
<h2 id="其他颜色槽">其他颜色槽</h2>
<p>除 Material 主题指定的 12 个颜色槽以外，您的设计系统可能还会用到其他颜色槽。幸运的是，在 Android 上声明颜色属性的操作很简单:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;attr name=&quot;colorCustom&quot; format=&quot;color&quot; /&gt;
 
&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.MaterialComponents.*&quot;&gt;
    ...
    &lt;item name=&quot;colorCustom&quot;&gt;@color/...&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="颜色资源">颜色资源</h2>
<p>颜色值会被定义为 <code>&lt;color&gt;</code> 资源。对于自定义颜色，我们建议使用以下两种方法，以帮助区分关注点，并在应用中为颜色主题中的色值创建单一来源:</p>
<ul>
<li>将浅色和深色主题用到的全部<code>&lt;color&gt;</code>存储在一个 res/values/colors.xml 文件中</li>
<li><code>&lt;color&gt;</code>色值使用字面名称命名 (而不是基于使用方式命名):
<ul>
<li>如此一来，便可以在使用颜色时更自然地用到 ?attr/ 语法。支持深色主题时也推荐采用此种方法</li>
<li>使用 green_500 或 brand_name_yellow 等名称</li>
<li>避免使用语义名称，如 color_primary<pre><code class="language-java">&lt;!-- In res/values/colors.xml --&gt;
&lt;color name=&quot;navy_500&quot;&gt;#64869B&lt;/color&gt;
&lt;color name=&quot;navy_700&quot;&gt;#37596D&lt;/color&gt;
&lt;color name=&quot;navy_900&quot;&gt;#073042&lt;/color&gt;
&lt;color name=&quot;green_300&quot;&gt;#3DDC84&lt;/color&gt;
&lt;color name=&quot;green_500&quot;&gt;#00A956&lt;/color&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="覆盖应用主题中的颜色">覆盖应用主题中的颜色</h2>
<p>让我们了解一下如何通过覆盖相关属性将您自己的调色板应用到主题中。</p>
<p>首先，您的主题需要在妥善处理浅色和深色调色板的同时减少与基础主题的重复。有关这方面的更多信息，请参阅 Chris Banes 关于深色主题的文章以及 Chris Banes 和 Nick Butcher 的 &quot;如何正确开发外观样式&quot; 演讲。</p>
<p>设置好主题后，覆盖您希望在浅色和深色主题中更改的颜色属性即可:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_700&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_900&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
 
 
&lt;!-- In res/values-night/themes.xml --&gt;
&lt;style name=&quot;Theme.App&quot; parent=&quot;Theme.App.Base&quot;&gt;
    ...
    &lt;item name=&quot;colorPrimary&quot;&gt;@color/navy_500&lt;/item&gt;
    &lt;item name=&quot;colorPrimaryVariant&quot;&gt;@color/navy_900&lt;/item&gt;
    &lt;item name=&quot;colorSecondary&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;item name=&quot;colorSecondaryVariant&quot;&gt;@color/green_300&lt;/item&gt;
    &lt;!-- Using default values for colorOnPrimary, colorSurface, colorError, etc. --&gt;
&lt;/style&gt;
</code></pre>
<p>Material 组件将根据主题全局应用您覆盖好的颜色:<br>
<img src="https://jgduan.github.io//post-images/1625415001473.gif" alt="" loading="lazy"></p>
<hr>
<h2 id="颜色复用性和最佳实践">颜色复用性和最佳实践</h2>
<p>在许多情况下，都要在布局、可绘制对象、样式和其他位置使用颜色。我们将介绍一些可尽量复用代码的方法，而且不会影响您在应用主题中指定的色值。</p>
<hr>
<h2 id="首选属性">首选属性</h2>
<p>我们强烈建议使用 ?attr/ 语法来设置颜色。在创建可复用的布局和支持多个模式 (如浅色/深色) 的默认样式时，尤其推荐使用这种语法。</p>
<pre><code class="language-java">&lt;Button
    ...
-    app:backgroundTint=&quot;@color/green_300&quot;
+    app:backgroundTint=&quot;?attr/colorPrimary&quot;
-    android:textColor=&quot;@color/black&quot;
+    android:textColor=&quot;?attr/colorOnPrimary&quot;
/&gt;
</code></pre>
<p>请参阅 Nick Butcher 的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808ce90bb7fb601dd9e144ae796eb466a2ed805bf14dbc0906543509d95c24733b05bd7fc12c&amp;idx=2&amp;mid=2652064078&amp;scene=21&amp;sn=884a85bfa4f9e19ec531b8245dca6314#wechat_redirect">《Android 样式系统 | 主题背景属性》</a>，以了解更多说明和此规则的一些例外情况。</p>
<hr>
<h2 id="带有-alpha-的颜色">带有 alpha 的颜色</h2>
<p>有时，您可能希望使用 MDC 主题中的一种颜色，但带上 alpha 值 (例如 60% 的 colorPrimary)。例如，触发点击时的波纹动画和项目被选中的状态。</p>
<p>Android<code>&lt;color&gt;</code>资源支持 alpha 通道:</p>
<pre><code class="language-java">&lt;!-- 60% alpha = 99 --&gt;
 
 
&lt;color name=”navy_700_alpha_60”&gt;#9937596D&lt;/color&gt;
</code></pre>
<p>但是，在使用此方法时，我们需要将每个带 alpha 的色值视作颜色资源。这也意味着我们不能用 ?attr/ 来使用这些颜色资源，因为这种做法违背了上文提及的唯一来源准则。</p>
<p>因此，我们建议使用 res/color 目录中存储的 ColorStateList (CSL)。CSL 里的项目可以包含一个颜色引用和 alpha 值，这非常适合我们的用例:</p>
<pre><code class="language-java">&lt;!-- In res/color/primary_60.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:alpha=&quot;0.6&quot; android:color=&quot;?attr/colorPrimary&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<p>使用这些 CSL (通过 @color/primary_60 语法进行引用) 可能会让您感到惊讶，但考虑到 CSL 本身也使用 ?attr/ 来引用底层的主题颜色，因此这样做不会有什么问题。</p>
<hr>
<h2 id="每种状态的颜色和主题叠加">每种状态的颜色和主题叠加</h2>
<p>更为常见的情况是根据视图状态使用 ColorStateList 切换颜色 (和 alpha 值)。MDC widget 大量将其用于禁用状态、悬停状态和按压状态等。比如下面是一个 MDC 按钮的背景色源代码:</p>
<pre><code class="language-java">&lt;!-- In button/res/color/mtrl_btn_bg_color_selector.xml --&gt;
&lt;selector ...&gt;
    &lt;item android:color=&quot;?attr/colorPrimary&quot; android:state_enabled=&quot;true&quot; /&gt;
    &lt;item android:alpha=&quot;0.12&quot; android:color=&quot;?attr/colorOnSurface&quot; /&gt;
&lt;/selector&gt;
</code></pre>
<ul>
<li>完整源代码<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/color/mtrl_btn_bg_color_selector.xml</li>
</ul>
<p>和上面这个按钮的示例类似，假设您希望将主背景色从主色改为辅色:<br>
<img src="https://jgduan.github.io//post-images/1625415175159.png" alt="" loading="lazy"><br>
△ 主色按钮 (左) 和辅色按钮 (右)</p>
<p>您当然可以将以上源文件复制一份，然后将 colorPrimary 改为 colorSecondary，但如果源代码恰巧发生更改，那么此操作会很繁琐且会出现问题。</p>
<p>一种更好的方式是使用主题叠加。Nick Butcher 在他的<a href="http://mp.weixin.qq.com/s?__biz=MzAwODY4OTk2Mg%3D%3D&amp;chksm=808cf83fb7fb71294558ac5b10882278fb1f53ed3fd7038013c19d2554ff85e20b014fe9ac4b&amp;idx=1&amp;mid=2652067962&amp;scene=21&amp;sn=71a1bc1726c40ccda245f366ae4a51bb#wechat_redirect">《Android 样式系统 | 主题背景覆盖》</a>一文中对此有详细的介绍。基本上，我们可以替换 View 或 ViewGroup 的主题属性值 (在我们例子中为 colorPrimary) 以及所有依赖它的项目 (在我们的例子中为按钮)。</p>
<p>下面是一个主题叠加的简单例子。请注意 parent 为空，其作用是确保我们仅覆盖希望更改的属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/themes.xml --&gt;
&lt;style name=&quot;ThemeOverlay.App.PrimarySecondary&quot; parent=&quot;&quot;&gt;
    &lt;item name=&quot;colorPrimary&quot;&gt;?attr/colorSecondary&lt;/item&gt;
    &lt;item name=&quot;colorOnPrimary&quot;&gt;?attr/colorOnSecondary&lt;/item&gt;
&lt;/style&gt;
</code></pre>
<p>在 XML 中应用主题叠加时，应考虑两个选项:</p>
<ul>
<li>android:theme - 用于所有 widget，不会以默认样式工作</li>
<li>app:materialThemeOverlay - 仅用于 MDC widget，以默认样式工作</li>
</ul>
<pre><code class="language-java">&lt;Button
    ...
    &lt;!-- Alternatively apply with android:theme --&gt;
+    app:materialThemeOverlay=&quot;@style/ThemeOverlay.App.PrimarySecondary&quot;
/&gt;
</code></pre>
<hr>
<h2 id="api-兼容性">API 兼容性</h2>
<p>平台是在 API 23 才开始在 CSL 等处增加对 ?attr/ 语法的支持。如果您的 minSdk 是更早的版本，也不要担心: 有兼容性类！事实上，MDC 和 AppCompat widget 都有在底层使用这些兼容性类，因此在使用时无需其他操作。</p>
<p>对于需要以编程方式使用 CSL 的场景，请使用 AppCompatResources:</p>
<pre><code class="language-java">val primary60 = AppCompatResources#getColorStateList(
    context, R.color.primary60
)
</code></pre>
<ul>
<li>AppCompatResources<br>
https://developer.android.google.cn/reference/androidx/appcompat/content/res/AppCompatResources</li>
</ul>
<hr>
<h2 id="mdc-widget-中的颜色">MDC widget 中的颜色</h2>
<p>之前我们曾说过，MDC widget 会响应主题级别的颜色属性覆盖。但是，您是如何知道按钮会将 colorPrimary 用作其背景着色并将 colorOnPrimary 用于其图标和文本呢？让我们来看一下几个选项。</p>
<hr>
<h2 id="构建-material-主题">构建 Material 主题</h2>
<p>构建 Material 主题是一个交互式 Android 项目，支持您通过自定义颜色、字体和形状来创建自己的 Material 主题。项目还包含所有主题中用到的参数和组件的目录。可通过执行以下操作确定哪些 widget 会对主题颜色属性的更改作出响应:</p>
<ul>
<li>
<p>复制这个项目并在 Android Studio 中运行应用</p>
</li>
<li>
<p>调整 res/values/color.xml 以及 res/values/themes.xml 和 res/values-night/themes.xml 中的色值</p>
</li>
<li>
<p>重新运行应用，观察视觉变化</p>
</li>
<li>
<p>构建 Material 主题<br>
https://material.io/resources/build-a-material-theme</p>
</li>
<li>
<p>项目源代码<br>
https://github.com/material-components/material-components-android-examples/tree/develop/MaterialThemeBuilder</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415351635.png" alt="" loading="lazy"><br>
△ 构建 Material 主题中的色值变化</p>
<hr>
<h2 id="mdc-开发者文档">MDC 开发者文档</h2>
<p>最近我们更新了 MDC 开发者文档。在本次更新中，我们加入了属性表，涵盖了开发库中所使用的设计术语和默认值。例如下面是更新的按钮文档的 &quot;Anatomy and key properties&quot; (详解和关键属性) 部分。<br>
<img src="https://jgduan.github.io//post-images/1625415378990.png" alt="" loading="lazy"><br>
△ MDC 按钮开发文档的属性表中提供了默认色值</p>
<ul>
<li>按钮文档<br>
https://github.com/material-components/material-components-android/blob/master/docs/components/Button.md</li>
</ul>
<hr>
<h2 id="源代码">源代码</h2>
<ul>
<li>
<p>MaterialButton 样式<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/styles.xml</p>
</li>
<li>
<p>MaterialButton 属性<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/res/values/attrs.xml</p>
</li>
<li>
<p>MaterialButton 源文件<br>
https://github.com/material-components/material-components-android/blob/master/lib/java/com/google/android/material/button/MaterialButton.java</p>
</li>
</ul>
<p><img src="https://jgduan.github.io//post-images/1625415449219.png" alt="" loading="lazy"><br>
△ MDC 按钮的默认样式和色值</p>
<hr>
<h2 id="自定义视图中的颜色">自定义视图中的颜色</h2>
<p>您的应用可能包含您自己构建或从现有库中获得的自定义 widget。在和 MDC 一起使用时，使这些视图对 Material 主题作出响应非常必要。让我们看一看在将颜色主题用于自定义 widget 时需要牢记的事项。</p>
<p>在<code>&lt;declare-styleable&gt;</code>和默认样式中使用 MDC 属性</p>
<p>为自定义视图设置样式需要使用<code>&lt;declare-styleable&gt;</code>。在保持一致性方面，复用 MDC 中的属性名称非常有用。使用<code>&lt;declare-styleable&gt;</code>的默认样式还可以使用 MDC 主题颜色属性:</p>
<pre><code class="language-java">&lt;!-- In res/values/attrs.xml --&gt;
&lt;declare-styleable name=&quot;AppCustomView&quot;&gt;
    &lt;attr name=&quot;backgroundTint&quot; /&gt;
    &lt;attr name=&quot;titleTextColor&quot; /&gt;
    ...
&lt;/declare-styleable&gt;
 
 
&lt;!-- In res/values/styles.xml --&gt;
&lt;style name=&quot;Widget.App.CustomView&quot; parent=&quot;android:Widget&quot;&gt;
    &lt;item name=&quot;backgroundTint&quot;&gt;?attr/colorSurface&lt;/item&gt;
    &lt;item name=&quot;titleTextColor&quot;&gt;
        @color/material_on_surface_emphasis_high_type
    &lt;/item&gt;
    ...
&lt;/style&gt;
</code></pre>
<hr>
<h2 id="materialcolors-实用程序类">MaterialColors 实用程序类</h2>
<p>可以通过便利的新 MDC 类 (MaterialColors) 以编程方式处理主题的颜色属性，这对于自定义视图也非常有用:</p>
<pre><code class="language-java">// Resolve color from theme attr
val primaryColor = MaterialColors.getColor(
    view, R.attr.colorPrimary
)
 
 
// Layer background color with overlay color + alpha
val overlayedColor = MaterialColors.layer(
    view, R.attr.colorSurface, R.attr.colorPrimary, 0.38f
)
</code></pre>
<hr>
<h2 id="下一步">下一步</h2>
<p>现在，我们已经在 Android 应用中使用 MDC 实现了颜色主题。有关 Material 主题的其他课题，请阅读我们相关的介绍文章。</p>
<ul>
<li>
<p>为什么推荐使用 MDC<br>
https://medium.com/androiddevelopers/we-recommend-material-design-components-81e6d165c2dd</p>
</li>
<li>
<p>字体主题<br>
https://material.io/blog/android-material-theme-type</p>
</li>
<li>
<p>形状主题<br>
https://material.io/blog/android-material-theme-shape</p>
</li>
<li>
<p>深色主题<br>
https://medium.com/androiddevelopers/dark-theme-with-mdc-4c6fc357d956</p>
</li>
<li>
<p>动效系统<br>
https://material.io/blog/android-material-motion</p>
</li>
</ul>
<p>我们一如既往地期待您在 GitHub 上提交错误报告和功能需求。另外，请务必查看 Android 组件示例应用。</p>
<ul>
<li>
<p>提交错误报告<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=bug&amp;template=bug_report.md&amp;title=%5BComponent+name%5D+Short+description+of+issue</p>
</li>
<li>
<p>提交功能需求<br>
https://github.com/material-components/material-components-android/issues/new?assignees=&amp;labels=feature+request&amp;template=feature_request.md&amp;title=%5BComponent+name%5D+Short+description+of+request</p>
</li>
<li>
<p>Android 组件示例应用<br>
https://github.com/material-components/material-components-android-examples</p>
</li>
</ul>
<p>如果您已成功实现颜色主题或您在实现期间遇到问题，欢迎在下方评论区和我们分享。</p>
<hr>
]]></content>
    </entry>
</feed>